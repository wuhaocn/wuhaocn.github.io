<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wuhaocn</title>
  
  
  <link href="https://wuhaocn.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuhaocn.github.io/"/>
  <updated>2021-10-18T03:35:26.285Z</updated>
  <id>https://wuhaocn.github.io/</id>
  
  <author>
    <name>wuhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux定时任务用法与实例</title>
    <link href="https://wuhaocn.github.io/2021/10/18/language/shell/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%B3%95%E4%B8%8E%E5%AE%9E%E4%BE%8B/"/>
    <id>https://wuhaocn.github.io/2021/10/18/language/shell/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%B3%95%E4%B8%8E%E5%AE%9E%E4%BE%8B/</id>
    <published>2021-10-18T03:19:43.244Z</published>
    <updated>2021-10-18T03:35:26.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>**    在**<a href="https://www.linuxprobe.com/">Linux系统</a><strong>的实际使用中，可能会经常碰到让系统在某个特定时间执行某些任务的情况，比如定时采集服务器的状态信息、负载状况；定时执行某些任务/</strong><a href="https://www.linuxcool.com/">脚本</a><strong>来对远端进行数据采集等。这里将介绍下crontab的配置参数以及一些使用实例。</strong><br><strong>​</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/804884/1630977884673-4e4b1724-9235-4016-ae29-267640a57ad5.jpeg#clientId=ubca59353-6701-4&from=paste&id=u78135138&margin=%5Bobject%20Object%5D&originHeight=251&originWidth=620&originalType=url&ratio=1&status=done&style=none&taskId=u78389e0f-56f1-4453-8018-3ad3f3a80e4"><br><strong>crontab配置文件</strong><br><a href="https://www.linuxprobe.com/">Linux</a>下的任务调度分为两类：系统任务调度和用户任务调度。Linux系统任务是由 cron (crond) 这个系统服务来控制的，这个系统服务是默认启动的。用户自己设置的计划任务则使用crontab <a href="https://www.linuxcool.com/">命令</a>。</p><h2 id="2-常见配置"><a href="#2-常见配置" class="headerlink" title="2.常见配置"></a>2.常见配置</h2><h3 id="2-1-配置详情"><a href="#2-1-配置详情" class="headerlink" title="2.1 配置详情"></a>2.1 配置详情</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/crontab</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># /etc/crontab: system-wide crontab</span><br><span class="line"># Unlike any other crontab you don&#x27;t have to run the `crontab&#x27;</span><br><span class="line"># command to install the new version when you edit this file</span><br><span class="line"># and files in /etc/cron.d. These files also have username fields,</span><br><span class="line"># that none of the other crontabs do.</span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"></span><br><span class="line"># m h dom mon dow usercommand</span><br><span class="line">17 ** * *root    cd / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6* * *roottest -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )</span><br><span class="line">47 6* * 7roottest -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )</span><br><span class="line">52 61 * *roottest -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )</span><br></pre></td></tr></table></figure><h3 id="2-2-crontab格式"><a href="#2-2-crontab格式" class="headerlink" title="2.2 crontab格式"></a>2.2 crontab格式</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1630977884651-539dcfb6-109b-400d-8296-b7dfccf87cd6.png#clientId=ubca59353-6701-4&from=paste&id=ufd7c16a7&margin=%5Bobject%20Object%5D&originHeight=446&originWidth=538&originalType=url&ratio=1&status=done&style=none&taskId=u86808066-51b9-4864-8e2b-697bfac61c0"><br>  在以上各个字段中，还可以使用以下特殊字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;*&quot;代表所有的取值范围内的数字，如月份字段为*，则表示1到12个月；</span><br><span class="line">&quot;/&quot;代表每一定时间间隔的意思，如分钟字段为*/10，表示每10分钟执行1次。</span><br><span class="line">&quot;-&quot;代表从某个区间范围，是闭区间。如“2-5”表示“2,3,4,5”，小时字段中0-23/2表示在0~23点范围内每2个小时执行一次。</span><br><span class="line">&quot;,&quot;分散的数字（不一定连续），如1,2,3,4,7,9。</span><br><span class="line">注：由于各个地方每周第一天不一样，因此Sunday=0（第一天）或Sunday=7（最后1天）。</span><br></pre></td></tr></table></figure><p><strong>crontab命令详解</strong></p><h3 id="2-3-配置文件"><a href="#2-3-配置文件" class="headerlink" title="2.3 配置文件"></a>2.3 配置文件</h3><p>​</p><ul><li>其一：/var/spool/cron/<br>该目录下存放的是每个用户（包括root）的crontab任务，文件名以用户名命名</li><li>其二：/etc/cron.d/<br>这个目录用来存放任何要执行的crontab文件或脚本。<h2 id="3-服务状态"><a href="#3-服务状态" class="headerlink" title="3.服务状态"></a>3.服务状态</h2>​</li></ul><ul><li>启动服务</li></ul><p>sudo service cron start      </p><ul><li>关闭服务</li></ul><p>sudo service cron stop      </p><ul><li>重启服务</li></ul><p> sudo service cron restart  </p><ul><li>重新载入配置</li></ul><p> sudo service cron reload </p><ul><li>查看服务状态</li></ul><p>sudo service cron status  </p><h2 id="4-常见命令"><a href="#4-常见命令" class="headerlink" title="4.常见命令"></a>4.常见命令</h2><ul><li>重新指定crontab定时任务列表文件</li></ul><p>crontab $filepath </p><ul><li>查看crontab定时任务</li></ul><p>crontab -l </p><ul><li>编辑定时任务【删除-添加-修改】</li></ul><p>crontab -e </p><ul><li><strong><em>添加定时任务【推荐】</em></strong><br>Step-One : 编辑任务脚本【分目录存放】【ex: backup.sh】<br>Step-Two : 编辑定时文件【命名规则:backup.cron】<br>Step-Three : crontab命令添加到系统crontab backup.cron<br>Step-Four : 查看crontab列表 crontab -l</li></ul><hr><h2 id="5-crontab时间举例"><a href="#5-crontab时间举例" class="headerlink" title="5.crontab时间举例"></a>5.crontab时间举例</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">每一分钟执行一次command（因cron默认每1分钟扫描一次，因此全为*即可）</span><br><span class="line">*    *    *    *    *  command</span><br><span class="line">每小时的第3和第15分钟执行command</span><br><span class="line">3,15   *    *    *    *  command</span><br><span class="line">每天上午8-11点的第3和15分钟执行command：</span><br><span class="line">3,15  8-11  *  *  *  command</span><br><span class="line">每隔2天的上午8-11点的第3和15分钟执行command：</span><br><span class="line">3,15  8-11  */2  *   *  command</span><br><span class="line">每个星期一的上午8点到11点的第3和第15分钟执行command</span><br><span class="line">3,15  8-11   *   *  1 command</span><br><span class="line">每晚的21:30重启smb</span><br><span class="line">30  21   *   *  *  /etc/init.d/smb restart</span><br><span class="line">每月1、10、22日的4 : 45重启smb</span><br><span class="line">45  4  1,10,22  *  *  /etc/init.d/smb restart</span><br><span class="line">每周六、周日的1 : 10重启smb</span><br><span class="line">10  1  *  *  6,0  /etc/init.d/smb restart</span><br><span class="line">每天18 : 00至23 : 00之间每隔30分钟重启smb</span><br><span class="line">0,30  18-23  *  *  *  /etc/init.d/smb restart</span><br><span class="line">每一小时重启smb</span><br><span class="line">*  */1  *  *  *  /etc/init.d/smb restart</span><br><span class="line">晚上11点到早上7点之间，每隔一小时重启smb</span><br><span class="line">*  23-7/1  *   *   *  /etc/init.d/smb restart</span><br><span class="line">每月的4号与每周一到周三的11点重启smb</span><br><span class="line">0  11  4  *  mon-wed  /etc/init.d/smb restart</span><br><span class="line">每小时执行/etc/cron.hourly目录内的脚本</span><br><span class="line">0  1   *   *   *     root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure><p><strong>crontab配置实例</strong></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 每天早上6点 </span><br><span class="line">0 6 * * * echo &quot;Good morning.&quot; &gt;&gt; /tmp/test.txt //注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。</span><br><span class="line"></span><br><span class="line"># 每两个小时 </span><br><span class="line">0 */2 * * * echo &quot;Have a break now.&quot; &gt;&gt; /tmp/test.txt  </span><br><span class="line"></span><br><span class="line"># 晚上11点到早上8点之间每两个小时和早上八点 </span><br><span class="line">0 23-7/2，8 * * * echo &quot;Have a good dream&quot; &gt;&gt; /tmp/test.txt</span><br><span class="line"></span><br><span class="line"># 每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点 </span><br><span class="line">0 11 4 * 1-3 command line</span><br><span class="line"></span><br><span class="line"># 1月1日早上4点 </span><br><span class="line">0 4 1 1 * command line SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root //如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME=/ </span><br><span class="line"></span><br><span class="line"># 每小时（第一分钟）执行/etc/cron.hourly内的脚本</span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br><span class="line"></span><br><span class="line"># 每天（凌晨4：02）执行/etc/cron.daily内的脚本</span><br><span class="line">02 4 * * * root run-parts /etc/cron.daily </span><br><span class="line"></span><br><span class="line"># 每星期（周日凌晨4：22）执行/etc/cron.weekly内的脚本</span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly </span><br><span class="line"></span><br><span class="line"># 每月（1号凌晨4：42）去执行/etc/cron.monthly内的脚本 </span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly </span><br><span class="line"></span><br><span class="line"># 注意:  &quot;run-parts&quot;这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名。 　 </span><br><span class="line"></span><br><span class="line"># 每天的下午4点、5点、6点的5 min、15 min、25 min、35 min、45 min、55 min时执行命令。 </span><br><span class="line">5，15，25，35，45，55 16，17，18 * * * command</span><br><span class="line"></span><br><span class="line"># 每周一，三，五的下午3：00系统进入维护状态，重新启动系统。</span><br><span class="line">00 15 * *1，3，5 shutdown -r +5</span><br><span class="line"></span><br><span class="line"># 每小时的10分，40分执行用户目录下的innd/bbslin这个指令： </span><br><span class="line">10，40 * * * * innd/bbslink </span><br><span class="line"></span><br><span class="line"># 每小时的1分执行用户目录下的bin/account这个指令： </span><br><span class="line">1 * * * * bin/account</span><br><span class="line"></span><br><span class="line"># 每天早晨三点二十分执行用户目录下如下所示的两个指令（每个指令以;分隔）： </span><br><span class="line">203 * * * （/bin/rm -f expire.ls logins.bad;bin/expire$#@62;expire.1st）　</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;**    在**&lt;a href=&quot;https://www.linuxprobe.com/&quot;&gt;Linux系统&lt;/a&gt;&lt;str</summary>
      
    
    
    
    <category term="linux" scheme="https://wuhaocn.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux日期获取</title>
    <link href="https://wuhaocn.github.io/2021/10/18/language/shell/Linux%E6%97%A5%E6%9C%9F%E8%8E%B7%E5%8F%96/"/>
    <id>https://wuhaocn.github.io/2021/10/18/language/shell/Linux%E6%97%A5%E6%9C%9F%E8%8E%B7%E5%8F%96/</id>
    <published>2021-10-18T03:19:29.345Z</published>
    <updated>2021-10-18T03:35:26.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-linux获取日期"><a href="#1-linux获取日期" class="headerlink" title="1.linux获取日期"></a>1.linux获取日期</h2><p> linux中通过date命令获取昨天或明天时间的方法.<br> date命令可以获取当前的时间，通过man，可以看到date有很多参数可以用，很容易做到格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date +<span class="string">&quot;%F&quot;</span></span><br><span class="line">输出格式：<span class="number">2011</span>-<span class="number">12</span>-<span class="number">31</span> </span><br><span class="line"></span><br><span class="line">date +<span class="string">&quot;%F %H:%M:%S&quot;</span></span><br><span class="line">输出格式：<span class="number">2011</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">29</span>:<span class="number">50</span></span><br></pre></td></tr></table></figure><p>这都是打印出系统的当前时间，如果要获取相对当前时间的某个时间，需要怎么做，通过 -d 参数就能实现。例如：<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date -d<span class="string">&quot;tomorrow&quot;</span> +<span class="string">&quot;%F %H:%M:%S&quot;</span></span><br><span class="line">输出明天这个时候的时间</span><br><span class="line"></span><br><span class="line">date -d<span class="string">&quot;yesterday&quot;</span> +<span class="string">&quot;%F %H:%M:%S&quot;</span></span><br><span class="line">输出昨天这个时候的时间</span><br></pre></td></tr></table></figure><p>如果说我想获取13天前的时间怎么办，-d参数还有更加灵活的用法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">date -d<span class="string">&quot;-1 day ago&quot;</span> +<span class="string">&quot;%F %H:%M:%S&quot;</span></span><br><span class="line">输出明天这个时候的时间</span><br><span class="line"></span><br><span class="line">date -d<span class="string">&quot;1 day ago&quot;</span> +<span class="string">&quot;%F %H:%M:%S&quot;</span></span><br><span class="line">输出昨天这个时候的时间</span><br><span class="line"></span><br><span class="line">date -d<span class="string">&quot;1 week ago&quot;</span> +<span class="string">&quot;%F %H:%M:%S&quot;</span></span><br><span class="line">输出<span class="number">7</span>天前这个时候的时间，等价于</span><br><span class="line">date -d<span class="string">&quot;7 day ago&quot;</span> +<span class="string">&quot;%F %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到ago的强大了吧，第一个数字可以是负数，负数表示将来时间，正数表示前面已经过去的时间，第二个参数minute、hour、day、month、week。</p><h2 id="2-使用实例"><a href="#2-使用实例" class="headerlink" title="2.使用实例"></a>2.使用实例</h2><ul><li><p>定时删除三天前类似”2021_10_18_09”文件</p><p>编写shell脚本”clean_tcpdump.sh”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">dumpfile3=`date -d<span class="string">&quot;3 day ago&quot;</span> <span class="string">&#x27;+%Y_%m_%d&#x27;</span>`*</span><br><span class="line">echo $dumpfile3</span><br><span class="line">dumpfile3del=<span class="string">&quot;$dumpfile3*&quot;</span> </span><br><span class="line">rm -rf $dumpfile3del</span><br><span class="line">dumpfile4=`date -d<span class="string">&quot;4 day ago&quot;</span> <span class="string">&#x27;+%Y_%m_%d&#x27;</span>`*</span><br><span class="line">echo $dumpfile4</span><br><span class="line">dumpfile4del=<span class="string">&quot;$dumpfile4*&quot;</span> </span><br><span class="line">rm -rf $dumpfile4del</span><br><span class="line">dumpfile5=`date -d<span class="string">&quot;5 day ago&quot;</span> <span class="string">&#x27;+%Y_%m_%d&#x27;</span>`*</span><br><span class="line">echo $dumpfile5</span><br><span class="line">dumpfile5del=<span class="string">&quot;$dumpfile5*&quot;</span> </span><br><span class="line">rm -rf $dumpfile5del</span><br></pre></td></tr></table></figure><p>暴力一点部署特别优雅，其实可以用循环</p></li></ul><h2 id="3-参考："><a href="#3-参考：" class="headerlink" title="3.参考："></a>3.参考：</h2><p><a href="https://blog.csdn.net/qq_16885135/article/details/52063477">https://blog.csdn.net/qq_16885135/article/details/52063477</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-linux获取日期&quot;&gt;&lt;a href=&quot;#1-linux获取日期&quot; class=&quot;headerlink&quot; title=&quot;1.linux获取日期&quot;&gt;&lt;/a&gt;1.linux获取日期&lt;/h2&gt;&lt;p&gt; linux中通过date命令获取昨天或明天时间的方法.&lt;br&gt; d</summary>
      
    
    
    
    <category term="linux" scheme="https://wuhaocn.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>brew常用设置</title>
    <link href="https://wuhaocn.github.io/2021/10/15/tool/mac/brew%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"/>
    <id>https://wuhaocn.github.io/2021/10/15/tool/mac/brew%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-10-15T06:08:00.262Z</published>
    <updated>2021-10-15T06:30:00.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-brew更新or安装慢"><a href="#1-brew更新or安装慢" class="headerlink" title="1.brew更新or安装慢"></a>1.brew更新or安装慢</h2><ul><li>更新ustc.edu源并设置强制更新</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd $(brew --repo)</span><br><span class="line"> </span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"> </span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line"> </span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line">export HOMEBREW_FORCE_BREWED_GIT=&quot;1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>更新github源并设置强制更新</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">建议配置ssh快一些</span><br><span class="line">cd $(brew --repo)</span><br><span class="line">git clone </span><br><span class="line">git remote set-url origin git@github.com:Homebrew/brew.git</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin git@github.com:Homebrew/homebrew-core.git</span><br><span class="line">export HOMEBREW_FORCE_BREWED_GIT=&quot;1&quot;</span><br></pre></td></tr></table></figure><h2 id="2-brew重启安装"><a href="#2-brew重启安装" class="headerlink" title="2.brew重启安装"></a>2.brew重启安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、卸载</span><br><span class="line"></span><br><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br><span class="line">2、安装【卸载与安装差别只有最后的install和undeinstall】</span><br><span class="line"></span><br><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">3、更新</span><br><span class="line"></span><br><span class="line">brew update</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">遇到问题：</span><br><span class="line"></span><br><span class="line">1、raw.githubusercontent.com 链接不到或者访问太慢</span><br><span class="line"></span><br><span class="line">解决：绑定host</span><br><span class="line"></span><br><span class="line">199.232.28.133 raw.githubusercontent.com</span><br><span class="line">有host修改软件，直接在软件修改即可</span><br><span class="line"></span><br><span class="line">没有的按照如下方式修改追加</span><br><span class="line"></span><br><span class="line">sudo vim /etc/hosts</span><br><span class="line">在hosts文件最后追加如下，保存退出即可：</span><br><span class="line"></span><br><span class="line">199.232.28.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><h2 id="3-常见命令"><a href="#3-常见命令" class="headerlink" title="3.常见命令"></a>3.常见命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">安装软件：brew install 软件名，例：brew install wget</span><br><span class="line"></span><br><span class="line">搜索软件：brew search 软件名，例：brew search wget</span><br><span class="line"></span><br><span class="line">卸载软件：brew uninstall 软件名，例：brew uninstall wget</span><br><span class="line"></span><br><span class="line">更新所有软件：brew update</span><br><span class="line"></span><br><span class="line">更新具体软件：brew upgrade 软件名 ，例：brew upgrade git</span><br><span class="line"></span><br><span class="line">显示已安装软件：brew list</span><br><span class="line"></span><br><span class="line">查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git</span><br><span class="line"></span><br><span class="line">显示包依赖：brew reps</span><br><span class="line"></span><br><span class="line">显示安装的服务：brew services list</span><br><span class="line"></span><br><span class="line">安装服务启动、停止、重启：brew services start/stop/restart serverName</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="全部替换国内源"><a href="#全部替换国内源" class="headerlink" title="全部替换国内源"></a>全部替换国内源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-brew更新or安装慢&quot;&gt;&lt;a href=&quot;#1-brew更新or安装慢&quot; class=&quot;headerlink&quot; title=&quot;1.brew更新or安装慢&quot;&gt;&lt;/a&gt;1.brew更新or安装慢&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;更新ustc.edu源并设置强制更新&lt;/</summary>
      
    
    
    
    <category term="devops" scheme="https://wuhaocn.github.io/categories/devops/"/>
    
    
    <category term="brew" scheme="https://wuhaocn.github.io/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="https://wuhaocn.github.io/2021/10/14/devops/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://wuhaocn.github.io/2021/10/14/devops/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-10-14T02:20:08.920Z</published>
    <updated>2021-10-18T04:11:47.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h2><ul><li><p>模糊删除镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi --force `docker images | grep java | awk &#x27;&#123;print $3&#125;&#x27;`</span><br></pre></td></tr></table></figure></li><li><p>删除停止容器</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure><ul><li>停止/启动容器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line">docker stop $(docker ps -a  | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure><ul><li>提交容器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker commit 81a82e9b5ac2 wuhaocn/java-im:8</span><br><span class="line"></span><br><span class="line">docker tag wuhaocn/java-im:8 wuhaocn/java-im:8</span><br><span class="line"></span><br><span class="line">docker push wuhaocn/java-im:8</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><ul><li>run</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行容器</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest </span><br></pre></td></tr></table></figure><ul><li>start/stop/restart</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">启动/停止/重启容器</span><br><span class="line">docker start myrunoob</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>kill</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">杀死容器</span><br><span class="line">docker kill -s KILL myrunoob</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>rm</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">删除容器</span><br><span class="line">docker rm -f myrunoob1 myrunoob2</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>pause/unpause</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">暂停数据库容器myrunoob提供服务</span><br><span class="line">docker pause myrunoob</span><br></pre></td></tr></table></figure><ul><li>create</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</span><br><span class="line">docker create  --name myrunoob  nginx:latest </span><br></pre></td></tr></table></figure><ul><li>exec</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 exec 命令对指定的容器执行 bash:</span><br><span class="line">docker exec -it 9df70f9a0714 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><ul><li>ps</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">列出容器</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES</span><br><span class="line">09b93464c2f7   nginx:latest   &quot;nginx -g &#x27;daemon off&quot; ...  80/tcp, 443/tcp          myrunoob</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>inspect</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取镜像mysql:5.6的元信息。</span><br><span class="line">docker inspect mysql:5.6</span><br></pre></td></tr></table></figure><ul><li><p>top</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看容器mymysql的进程信息。</span><br><span class="line">docker top mymysql</span><br><span class="line">查看所有运行容器的进程信息。</span><br><span class="line">for i in  `docker ps |grep Up|awk &#x27;&#123;print $1&#125;&#x27;`;do echo \ &amp;&amp;docker top $i; done</span><br></pre></td></tr></table></figure></li><li><p>attach</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。</span><br><span class="line">docker attach --sig-proxy=false mynginx</span><br></pre></td></tr></table></figure></li><li><p>events</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显示docker 2016年7月1日后的所有事件。</span><br><span class="line">docker events  --since=&quot;1467302400&quot;</span><br><span class="line">显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。</span><br><span class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot; </span><br></pre></td></tr></table></figure><ul><li>logs</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">跟踪查看容器mynginx的日志输出。</span><br><span class="line">docker logs -f mynginx</span><br><span class="line">查看容器mynginx从2016年7月1日后的最新10条日志。</span><br><span class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>wait</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。</span><br><span class="line"></span><br><span class="line">docker wait CONTAINER</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>export</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将id为a404c6c174a2的容器按日期保存为tar文件。</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure><ul><li>port</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看容器mynginx的端口映射情况。</span><br><span class="line"></span><br><span class="line">docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h3><ul><li><p>commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span><br><span class="line">docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1</span><br><span class="line">简化参考</span><br><span class="line">docker commit faa474c052c6 java-sctp:8</span><br></pre></td></tr></table></figure></li><li><p>cp</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</span><br><span class="line"></span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><ul><li>diff</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看容器mymysql的文件结构更改。</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><ul><li><p>login</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">登陆到Docker Hub</span><br><span class="line"></span><br><span class="line">docker login -u 用户名 -p 密码</span><br></pre></td></tr></table></figure></li><li><p>pull</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从Docker Hub下载java最新版镜像。</span><br><span class="line"></span><br><span class="line">docker pull java</span><br></pre></td></tr></table></figure></li><li><p>push</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上传本地镜像myapache:v1到镜像仓库中。</span><br><span class="line"></span><br><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure><ul><li>search</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像</span><br><span class="line"></span><br><span class="line">docker search -f stars=10 java</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><ul><li><p>images</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看本地镜像列表。</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql                 v1                  37af1236adef        5 minutes ago       329 MB</span><br></pre></td></tr></table></figure></li><li><p>rmi</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">强制删除本地镜像 runoob/ubuntu:v4。    </span><br><span class="line"></span><br><span class="line">docker rmi -f runoob/ubuntu:v4</span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br></pre></td></tr></table></figure><ul><li>tag</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。</span><br><span class="line"></span><br><span class="line">docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br></pre></td></tr></table></figure><ul><li>build</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。</span><br><span class="line"></span><br><span class="line">docker build -t runoob/ubuntu:v1 . </span><br></pre></td></tr></table></figure><ul><li>history</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看本地镜像runoob/ubuntu:v3的创建历史。</span><br><span class="line"></span><br><span class="line">root@runoob:~# docker history runoob/ubuntu:v3</span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c sed -i &#x27;s/^#\s*\(deb.*universe\)$/   1.863 kB            </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c set -xe   &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt; /u   701 B               </span><br><span class="line">&lt;missing&gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></pre></td></tr></table></figure><ul><li>save</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>load</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导入镜像：</span><br><span class="line">$ docker load &lt; busybox.tar.gz</span><br><span class="line">Loaded image: busybox:latest</span><br></pre></td></tr></table></figure><ul><li>import</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A:export/import 是根据容器来导出镜像（因此没有镜像的历史记录）而 save/load 操作的对象是镜像</span><br><span class="line">B:export/import 镜像的历史记录再导后无法进行回滚操作，而save/load镜像有完整的历史记录可以回滚</span><br><span class="line">docker import : 从归档文件中创建镜像。</span><br><span class="line">docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br></pre></td></tr></table></figure><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><ul><li>info</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">Containers: 12</span><br><span class="line">Images: 41</span><br><span class="line">Storage Driver: aufs</span><br><span class="line"> Root Dir: /var/lib/docker/aufs</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Dirs: 66</span><br><span class="line"> Dirperm1 Supported: false</span><br><span class="line">Execution Driver: native-0.2</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Kernel Version: 3.13.0-32-generic</span><br><span class="line">Operating System: Ubuntu 14.04.1 LTS</span><br><span class="line">CPUs: 1</span><br><span class="line">Total Memory: 1.954 GiB</span><br><span class="line">Name: iZ23mtq8bs1Z</span><br><span class="line">ID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW</span><br></pre></td></tr></table></figure><ul><li>version</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">显示 Docker 版本信息。</span><br><span class="line"></span><br><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      1.8.2</span><br><span class="line"> API version:  1.20</span><br><span class="line"> Go version:   go1.4.2</span><br><span class="line"> Git commit:   0a8c2e3</span><br><span class="line"> Built:        Thu Sep 10 19:19:00 UTC 2015</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line">Server:</span><br><span class="line"> Version:      1.8.2</span><br><span class="line"> API version:  1.20</span><br><span class="line"> Go version:   go1.4.2</span><br><span class="line"> Git commit:   0a8c2e3</span><br><span class="line"> Built:        Thu Sep 10 19:19:00 UTC 2015</span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组合命令&quot;&gt;&lt;a href=&quot;#组合命令&quot; class=&quot;headerlink&quot; title=&quot;组合命令&quot;&gt;&lt;/a&gt;组合命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模糊删除镜像&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="devops" scheme="https://wuhaocn.github.io/categories/devops/"/>
    
    
    <category term="docker" scheme="https://wuhaocn.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>hexo-配置</title>
    <link href="https://wuhaocn.github.io/2021/10/01/tool/hexo-config/"/>
    <id>https://wuhaocn.github.io/2021/10/01/tool/hexo-config/</id>
    <published>2021-10-01T13:12:11.461Z</published>
    <updated>2021-10-01T13:12:11.461Z</updated>
    
    <content type="html"><![CDATA[<p>hexo配置详解，包含分类，归档，标题等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title:  #主页标题</span><br><span class="line">subtitle:  #副标题</span><br><span class="line">description: #网站描述description主要用于SEO</span><br><span class="line">keywords:  #博客关键字</span><br><span class="line">author: #作者，左下角显示</span><br><span class="line">language: zh_Hans # 选择中文简体</span><br><span class="line">timezone: &#x27;Asia/Shanghai&#x27;  #时区:国内选择上海</span><br><span class="line"># Url</span><br><span class="line">url: http://yoursite.com  #填自己的github pages网址 </span><br><span class="line">root: /                   #网站根目录</span><br><span class="line">permalink: :year/:month/:day/:title/        #文章的 永久链接 格式</span><br><span class="line">permalink_defaults:                         #永久链接中各部分的默认值</span><br><span class="line">pretty_urls:                                #改写 permalink 的值来美化 URL</span><br><span class="line">trailing_index: false # 比如，一个页面的永久链接是 https://wuhaocn.github.io/foo/bar/index.html 是否在                         永久链接中保留尾部的 index.html，设置为 false 时去除</span><br><span class="line">trailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source        #资源文件夹，这个文件夹用来存放内容。</span><br><span class="line">public_dir: public        #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class="line">tag_dir: tags             #标签文件夹</span><br><span class="line">archive_dir: archives     #归档文件夹</span><br><span class="line">category_dir: categories  #分类文件夹</span><br><span class="line">code_dir: downloads/code  #Include code 文件夹，source_dir 下的子目录</span><br><span class="line">i18n_dir: :lang           #国际化（i18n）文件夹</span><br><span class="line">skip_render:              #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可                           使用 glob 表达式来匹配路径。</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博                                               文。 </span><br><span class="line">default_layout: post    #预设布局</span><br><span class="line">titlecase: false  #把标题转换为 title case</span><br><span class="line">external_link:    #在新标签中打开链接</span><br><span class="line">  enable: true #在新标签中打开链接</span><br><span class="line">  field: site #对整个网站（site）生效或仅对文章（post）生效</span><br><span class="line">  exclude: &#x27;&#x27;  #需要排除的域名。主域名和子域名如 www 需分别配置</span><br><span class="line">filename_case: 0  #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class="line">render_drafts: false #显示草稿</span><br><span class="line">post_asset_folder: false  #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹</span><br><span class="line">relative_link: false  #把链接改为与根目录的相对位址</span><br><span class="line">future: true  #显示未来的文章</span><br><span class="line">highlight:</span><br><span class="line">  enable: true  #开启代码块高亮</span><br><span class="line">  line_number: true  #显示行数</span><br><span class="line">  auto_detect: false  #如果未指定语言，则启用自动检测</span><br><span class="line">  tab_replace: &#x27;&#x27;  #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</span><br><span class="line">  wrap: true    # 将代码块包装到&lt;table&gt;</span><br><span class="line">  hljs: false   # CSS类使用hljs-*前缀</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized  #默认分类</span><br><span class="line">category_map:   #分类别名</span><br><span class="line">tag_map:   #标签别名</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">meta_generator: true   # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD  #日期格式</span><br><span class="line">time_format: HH:mm:ss   #时间格式</span><br><span class="line">use_date_for_updated: false  #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10  #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class="line">pagination_dir: page  #分页目录</span><br><span class="line"></span><br><span class="line"># Include / Exclude file(s)</span><br><span class="line">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="line">include:  #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和            _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</span><br><span class="line">exclude:  #Hexo 会忽略这些文件和目录</span><br><span class="line">ignore:   #Ignore files/folders</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: icarus #当前主题名称。值为false时禁用主题</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:   #部署部分的设置</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo配置详解，包含分类，归档，标题等&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AtomicInteger</title>
    <link href="https://wuhaocn.github.io/2021/10/01/language/java/juc/atomic/AtomicInteger/"/>
    <id>https://wuhaocn.github.io/2021/10/01/language/java/juc/atomic/AtomicInteger/</id>
    <published>2021-10-01T13:12:11.460Z</published>
    <updated>2021-10-01T13:12:11.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码导读"><a href="#源码导读" class="headerlink" title="源码导读"></a>源码导读</h3><pre><code>AtomicInteger，应该是atomic框架中用得最多的原子类了。顾名思义，AtomicInteger是Integer类型的线程安全原子类，可以在应用程序中以原子的方式更新int值。 采用volatile int value类型原子变量保证内存可见性 采用Unsafe类 compareAndSwapInt方法实现变量值valueOffset的修改知识参考点：Unsafe类/ volatile 关键字/ CAS</code></pre><h3 id="源码参考"><a href="#源码参考" class="headerlink" title="源码参考"></a>源码参考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Written by Doug Lea with assistance from members of JCP JSR-166</span></span><br><span class="line"><span class="comment"> * Expert Group and released to the public domain, as explained at</span></span><br><span class="line"><span class="comment"> * http://creativecommons.org/publicdomain/zero/1.0/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntUnaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@code</span> int&#125; value that may be updated atomically.  See the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.concurrent.atomic&#125; package specification for</span></span><br><span class="line"><span class="comment"> * description of the properties of atomic variables. An</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> AtomicInteger&#125; is used in applications such as atomically</span></span><br><span class="line"><span class="comment"> * incremented counters, and cannot be used as a replacement for an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Integer&#125;. However, this class does extend</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Number&#125; to allow uniform access by tools and utilities that</span></span><br><span class="line"><span class="comment"> * deal with numerically-based classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets to the given value and returns the old value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;a href=&quot;package-summary.html#weakCompareAndSet&quot;&gt;May fail</span></span><br><span class="line"><span class="comment">     * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is</span></span><br><span class="line"><span class="comment">     * only rarely an appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function, returning the previous value. The</span></span><br><span class="line"><span class="comment">     * function should be side-effect-free, since it may be re-applied</span></span><br><span class="line"><span class="comment">     * when attempted updates fail due to contention among threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateFunction a side-effect-free function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.applyAsInt(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function, returning the updated value. The</span></span><br><span class="line"><span class="comment">     * function should be side-effect-free, since it may be re-applied</span></span><br><span class="line"><span class="comment">     * when attempted updates fail due to contention among threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateFunction a side-effect-free function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.applyAsInt(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function to the current and given values,</span></span><br><span class="line"><span class="comment">     * returning the previous value. The function should be</span></span><br><span class="line"><span class="comment">     * side-effect-free, since it may be re-applied when attempted</span></span><br><span class="line"><span class="comment">     * updates fail due to contention among threads.  The function</span></span><br><span class="line"><span class="comment">     * is applied with the current value as its first argument,</span></span><br><span class="line"><span class="comment">     * and the given update as the second argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the update value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulatorFunction a side-effect-free function of two arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function to the current and given values,</span></span><br><span class="line"><span class="comment">     * returning the updated value. The function should be</span></span><br><span class="line"><span class="comment">     * side-effect-free, since it may be re-applied when attempted</span></span><br><span class="line"><span class="comment">     * updates fail due to contention among threads.  The function</span></span><br><span class="line"><span class="comment">     * is applied with the current value as its first argument,</span></span><br><span class="line"><span class="comment">     * and the given update as the second argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the update value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulatorFunction a side-effect-free function of two arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the String representation of the current value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the String representation of the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> AtomicInteger&#125; as an &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> AtomicInteger&#125; as a &#123;<span class="doctag">@code</span> long&#125;</span></span><br><span class="line"><span class="comment">     * after a widening primitive conversion.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 5.1.2 Widening Primitive Conversions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> AtomicInteger&#125; as a &#123;<span class="doctag">@code</span> float&#125;</span></span><br><span class="line"><span class="comment">     * after a widening primitive conversion.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 5.1.2 Widening Primitive Conversions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> AtomicInteger&#125; as a &#123;<span class="doctag">@code</span> double&#125;</span></span><br><span class="line"><span class="comment">     * after a widening primitive conversion.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 5.1.2 Widening Primitive Conversions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;源码导读&quot;&gt;&lt;a href=&quot;#源码导读&quot; class=&quot;headerlink&quot; title=&quot;源码导读&quot;&gt;&lt;/a&gt;源码导读&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;AtomicInteger，应该是atomic框架中用得最多的原子类了。顾名思义，
AtomicIntege</summary>
      
    
    
    
    <category term="java" scheme="https://wuhaocn.github.io/categories/java/"/>
    
    
    <category term="atomic" scheme="https://wuhaocn.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>LogAdder</title>
    <link href="https://wuhaocn.github.io/2021/10/01/language/java/juc/atomic/LogAdder/"/>
    <id>https://wuhaocn.github.io/2021/10/01/language/java/juc/atomic/LogAdder/</id>
    <published>2021-10-01T13:12:11.460Z</published>
    <updated>2021-10-01T13:12:11.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>（1）java8 中为什么要新增 LongAdder？</p><p>（2）LongAdder 的实现方式？</p><p>（3）LongAdder 与 AtomicLong 的对比？</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>LongAdder 是 java8 中新增的原子类，在多线程环境中，它比 AtomicLong 性能要高出不少，特别是写多的场景。</p><p>它是怎么实现的呢？让我们一起来学习吧。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>LongAdder 的原理是，在最初无竞争时，只更新 base 的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的 LongAdder 存储的值。</p><p>LongAdder</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>LongAdder 继承自 Striped64 抽象类，Striped64 中定义了 Cell 内部类和各重要属性。</p><h4 id="主要内部类"><a href="#主要内部类" class="headerlink" title="主要内部类"></a>主要内部类</h4><p>// Striped64 中的内部类，使用@sun.misc.Contended 注解，说明里面的值消除伪共享</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended static final class Cell &#123;</span><br><span class="line">    // 存储元素的值，使用volatile修饰保证可见性</span><br><span class="line">    volatile long value;</span><br><span class="line">    Cell(long x) &#123; value = x; &#125;</span><br><span class="line">    // CAS更新value的值</span><br><span class="line">    final boolean cas(long cmp, long val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Unsafe实例</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    // value字段的偏移量</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cell 类使用<a href="Java8%E7%9A%84@sun.misc.Contended%E6%B3%A8%E8%A7%A3.md">@sun.misc.Contended 注解</a>，说明是要避免伪共享的。</p><p>使用 Unsafe 的 CAS 更新 value 的值，其中 value 的值使用 volatile 修饰，保证可见性。</p><p>关于 Unsafe 的介绍请查看【死磕 java 魔法类之 Unsafe 解析】。</p><p>关于伪共享的介绍请查看【杂谈 什么是伪共享（false sharing）？】。<br><a href="https://blog.csdn.net/qq_27680317/article/details/78486220">一篇对伪共享、缓存行填充和 CPU 缓存讲的很透彻的文章</a></p><p>主要属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 这三个属性都在Striped64中</span><br><span class="line">// cells数组，存储各个段的值</span><br><span class="line">transient volatile Cell[] cells;</span><br><span class="line">// 最初无竞争时使用的，也算一个特殊的段</span><br><span class="line">transient volatile long base;</span><br><span class="line">// 标记当前是否有线程在创建或扩容cells，或者在创建Cell</span><br><span class="line">// 通过CAS更新该值，相当于是一个锁</span><br><span class="line">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure><p>最初无竞争或有其它线程在创建 cells 数组时使用 base 更新值，有过竞争时使用 cells 更新值。<br>最初无竞争是指一开始没有线程之间的竞争，但也有可能是多线程在操作，只是这些线程没有同时去更新 base 的值。<br>有过竞争是指只要出现过竞争不管后面有没有竞争都使用 cells 更新值，规则是不同的线程 hash 到不同的 cell 上去更新，减少竞争。</p><h4 id="add-x-方法"><a href="#add-x-方法" class="headerlink" title="add(x)方法"></a>add(x)方法</h4><p>add(x)方法是 LongAdder 的主要方法，使用它可以使 LongAdder 中存储的值增加 x，x 可为正可为负。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void add(long x) &#123;</span><br><span class="line">    // as是Striped64中的cells属性</span><br><span class="line">    // b是Striped64中的base属性</span><br><span class="line">    // v是当前线程hash到的Cell中存储的值</span><br><span class="line">    // m是cells的长度减1，hash时作为掩码使用</span><br><span class="line">    // a是当前线程hash到的Cell</span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">    // 条件1：cells不为空，说明出现过竞争，cells已经创建</span><br><span class="line">    // 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span><br><span class="line">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        // true表示当前竞争还不激烈</span><br><span class="line">        // false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        // 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span><br><span class="line">        // 条件2：应该不会出现</span><br><span class="line">        // 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span><br><span class="line">        // 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            // getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span><br><span class="line">            // 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span><br><span class="line">            // 除非刻意修改它</span><br><span class="line">            (a = as[getProbe() &amp; m]) == null ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            // 调用Striped64中的方法处理</span><br><span class="line">            longAccumulate(x, null, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*（1）最初无竞争时只更新 base；</p><p>*（2）直到更新 base 失败时，创建 cells 数组；</p><p>*（3）当多个线程竞争同一个 Cell 比较激烈时，可能要扩容；</p><h4 id="longAccumulate-方法"><a href="#longAccumulate-方法" class="headerlink" title="longAccumulate()方法"></a>longAccumulate()方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">final void longAccumulate(long x, LongBinaryOperator fn,</span><br><span class="line">                              boolean wasUncontended) &#123;</span><br><span class="line">    // 存储线程的probe值</span><br><span class="line">    int h;</span><br><span class="line">    // 如果getProbe()方法返回0，说明随机数未初始化</span><br><span class="line">    if ((h = getProbe()) == 0) &#123;</span><br><span class="line">        // 强制初始化</span><br><span class="line">        ThreadLocalRandom.current(); // force initialization</span><br><span class="line">        // 重新获取probe值</span><br><span class="line">        h = getProbe();</span><br><span class="line">        // 都未初始化，肯定还不存在竞争激烈</span><br><span class="line">        wasUncontended = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否发生碰撞</span><br><span class="line">    boolean collide = false;                // True if last slot nonempty</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; int n; long v;</span><br><span class="line">        // cells已经初始化过</span><br><span class="line">        if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;</span><br><span class="line">            // 当前线程所在的Cell未初始化</span><br><span class="line">            if ((a = as[(n - 1) &amp; h]) == null) &#123;</span><br><span class="line">                // 当前无其它线程在创建或扩容cells，也没有线程在创建Cell</span><br><span class="line">                if (cellsBusy == 0) &#123;       // Try to attach new Cell</span><br><span class="line">                    // 新建一个Cell，值为当前需要增加的值</span><br><span class="line">                    Cell r = new Cell(x);   // Optimistically create</span><br><span class="line">                    // 再次检测cellsBusy，并尝试更新它为1</span><br><span class="line">                    // 相当于当前线程加锁</span><br><span class="line">                    if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        // 是否创建成功</span><br><span class="line">                        boolean created = false;</span><br><span class="line">                        try &#123;               // Recheck under lock</span><br><span class="line">                            Cell[] rs; int m, j;</span><br><span class="line">                            // 重新获取cells，并找到当前线程hash到cells数组中的位置</span><br><span class="line">                            // 这里一定要重新获取cells，因为as并不在锁定范围内</span><br><span class="line">                            // 有可能已经扩容了，这里要重新获取</span><br><span class="line">                            if ((rs = cells) != null &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                                rs[j = (m - 1) &amp; h] == null) &#123;</span><br><span class="line">                                // 把上面新建的Cell放在cells的j位置处</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                // 创建成功</span><br><span class="line">                                created = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            // 相当于释放锁</span><br><span class="line">                            cellsBusy = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 创建成功了就返回</span><br><span class="line">                        // 值已经放在新建的Cell里面了</span><br><span class="line">                        if (created)</span><br><span class="line">                            break;</span><br><span class="line">                        continue;           // Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 标记当前未出现冲突</span><br><span class="line">                collide = false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前线程所在的Cell不为空，且更新失败了</span><br><span class="line">            // 这里简单地设为true，相当于简单地自旋一次</span><br><span class="line">            // 通过下面的语句修改线程的probe再重新尝试</span><br><span class="line">            else if (!wasUncontended)       // CAS already known to fail</span><br><span class="line">                wasUncontended = true;      // Continue after rehash</span><br><span class="line">            // 再次尝试CAS更新当前线程所在Cell的值，如果成功了就返回</span><br><span class="line">            else if (a.cas(v = a.value, ((fn == null) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                break;</span><br><span class="line">            // 如果cells数组的长度达到了CPU核心数，或者cells扩容了</span><br><span class="line">            // 设置collide为false并通过下面的语句修改线程的probe再重新尝试</span><br><span class="line">            else if (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = false;            // At max size or stale</span><br><span class="line">            // 上上个elseif都更新失败了，且上个条件不成立，说明出现冲突了</span><br><span class="line">            else if (!collide)</span><br><span class="line">                collide = true;</span><br><span class="line">            // 明确出现冲突了，尝试占有锁，并扩容</span><br><span class="line">            else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 检查是否有其它线程已经扩容过了</span><br><span class="line">                    if (cells == as) &#123;      // Expand table unless stale</span><br><span class="line">                        // 新数组为原数组的两倍</span><br><span class="line">                        Cell[] rs = new Cell[n &lt;&lt; 1];</span><br><span class="line">                        // 把旧数组元素拷贝到新数组中</span><br><span class="line">                        for (int i = 0; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        // 重新赋值cells为新数组</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // 释放锁</span><br><span class="line">                    cellsBusy = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // 已解决冲突</span><br><span class="line">                collide = false;</span><br><span class="line">                // 使用扩容后的新数组重新尝试</span><br><span class="line">                continue;                   // Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新失败或者达到了CPU核心数，重新生成probe，并重试</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        // 未初始化过cells数组，尝试占有锁并初始化cells数组</span><br><span class="line">        else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            // 是否初始化成功</span><br><span class="line">            boolean init = false;</span><br><span class="line">            try &#123;                           // Initialize table</span><br><span class="line">                // 检测是否有其它线程初始化过</span><br><span class="line">                if (cells == as) &#123;</span><br><span class="line">                    // 新建一个大小为2的Cell数组</span><br><span class="line">                    Cell[] rs = new Cell[2];</span><br><span class="line">                    // 找到当前线程hash到数组中的位置并创建其对应的Cell</span><br><span class="line">                    rs[h &amp; 1] = new Cell(x);</span><br><span class="line">                    // 赋值给cells数组</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    // 初始化成功</span><br><span class="line">                    init = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放锁</span><br><span class="line">                cellsBusy = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            // 初始化成功直接返回</span><br><span class="line">            // 因为增加的值已经同时创建到Cell中了</span><br><span class="line">            if (init)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果有其它线程在初始化cells数组中，就尝试更新base</span><br><span class="line">        // 如果成功了就返回</span><br><span class="line">        else if (casBase(v = base, ((fn == null) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            break;                          // Fall back on using base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*（1）如果 cells 数组未初始化，当前线程会尝试占有 cellsBusy 锁并创建 cells 数组；</p><p>*（2）如果当前线程尝试创建 cells 数组时，发现有其它线程已经在创建了，就尝试更新 base，如果成功就返回；</p><p>*（3）通过线程的 probe 值找到当前线程应该更新 cells 数组中的哪个 Cell；</p><p>*（4）如果当前线程所在的 Cell 未初始化，就占有占有 cellsBusy 锁并在相应的位置创建一个 Cell；</p><p>*（5）尝试 CAS 更新当前线程所在的 Cell，如果成功就返回，如果失败说明出现冲突；</p><p>*（5）当前线程更新 Cell 失败后并不是立即扩容，而是尝试更新 probe 值后再重试一次；</p><p>*（6）如果在重试的时候还是更新失败，就扩容；</p><p>*（7）扩容时当前线程占有 cellsBusy 锁，并把数组容量扩大到两倍，再迁移原 cells 数组中元素到新数组中；</p><p>*（8）cellsBusy 在创建 cells 数组、创建 Cell、扩容 cells 数组三个地方用到；</p><h4 id="sum-方法"><a href="#sum-方法" class="headerlink" title="sum()方法"></a>sum()方法</h4><p>sum()方法是获取 LongAdder 中真正存储的值的大小，通过把 base 和所有段相加得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public long sum() &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    // sum初始等于base</span><br><span class="line">    long sum = base;</span><br><span class="line">    // 如果cells不为空</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        // 遍历所有的Cell</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            // 如果所在的Cell不为空，就把它的value累加到sum中</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回sum</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 sum()方法是把 base 和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到 sum 上的 Cell 的 value 有修改，不是就没法计算到了么？</p><p>答案确实如此，所以 LongAdder 可以说不是强一致性的，它是最终一致性的。</p><h4 id="LongAdder-VS-AtomicLong"><a href="#LongAdder-VS-AtomicLong" class="headerlink" title="LongAdder VS AtomicLong"></a>LongAdder VS AtomicLong</h4><p>直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class LongAdderVSAtomicLongTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        testAtomicLongVSLongAdder(1, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(10, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(20, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(40, 10000000);</span><br><span class="line">        testAtomicLongVSLongAdder(80, 10000000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testAtomicLongVSLongAdder(final int threadCount, final int times)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;threadCount：&quot; + threadCount + &quot;, times：&quot; + times);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            testLongAdder(threadCount, times);</span><br><span class="line">            System.out.println(&quot;LongAdder elapse：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">            long start2 = System.currentTimeMillis();</span><br><span class="line">            testAtomicLong(threadCount, times);</span><br><span class="line">            System.out.println(&quot;AtomicLong elapse：&quot; + (System.currentTimeMillis() - start2) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testAtomicLong(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class="line">        AtomicLong atomicLong = new AtomicLong();</span><br><span class="line">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class="line">            list.add(new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class="line">                    atomicLong.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void testLongAdder(final int threadCount, final int times) throws InterruptedException &#123;</span><br><span class="line">        LongAdder longAdder = new LongAdder();</span><br><span class="line">        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i=0;i&lt;threadCount;i++)&#123;</span><br><span class="line">            list.add(new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j&lt;times; j++)&#123;</span><br><span class="line">                    longAdder.add(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Thread thread : list)&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadCount：1, times：10000000</span><br><span class="line">LongAdder elapse：158ms</span><br><span class="line">AtomicLong elapse：64ms</span><br><span class="line">threadCount：10, times：10000000</span><br><span class="line">LongAdder elapse：206ms</span><br><span class="line">AtomicLong elapse：2449ms</span><br><span class="line">threadCount：20, times：10000000</span><br><span class="line">LongAdder elapse：429ms</span><br><span class="line">AtomicLong elapse：5142ms</span><br><span class="line">threadCount：40, times：10000000</span><br><span class="line">LongAdder elapse：840ms</span><br><span class="line">AtomicLong elapse：10506ms</span><br><span class="line">threadCount：80, times：10000000</span><br><span class="line">LongAdder elapse：1369ms</span><br><span class="line">AtomicLong elapse：20482ms</span><br></pre></td></tr></table></figure><p>可以看到当只有一个线程的时候，AtomicLong 反而性能更高，随着线程越来越多，AtomicLong 的性能急剧下降，而 LongAdder 的性能影响很小。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>*（1）LongAdder 通过 base 和 cells 数组来存储值；</p><p>*（2）不同的线程会 hash 到不同的 cell 上去更新，减少了竞争；</p><p>*（3）LongAdder 的性能非常高，最终会达到一种无竞争的状态；</p><p>在 longAccumulate()方法中有个条件是 n &gt;= NCPU 就不会走到扩容逻辑了，而 n 是 2 的倍数，那是不是代表 cells 数组最大只能达到大于等于 NCPU 的最小 2 次方？<br>答案是明确的。因为同一个 CPU 核心同时只会运行一个线程，而更新失败了说明有两个不同的核心更新了同一个 Cell，<br>这时会重新设置更新失败的那个线程的 probe 值，这样下一次它所在的 Cell 很大概率会发生改变，如果运行的时间足够长，<br>最终会出现同一个核心的所有线程都会 hash 到同一个 Cell（大概率，但不一定全在一个 Cell 上）上去更新，<br>所以，这里 cells 数组中长度并不需要太长，达到 CPU 核心数足够了。<br>比如，笔者的电脑是 8 核的，所以这里 cells 的数组最大只会到 8，达到 8 就不会扩容了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;（1）java8 中为什么要新增 LongAdder？&lt;/p&gt;
&lt;p&gt;（2）LongAdder 的实现方式？&lt;/p&gt;
&lt;p&gt;（3）LongA</summary>
      
    
    
    
    <category term="java" scheme="https://wuhaocn.github.io/categories/java/"/>
    
    
    <category term="atomic" scheme="https://wuhaocn.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>atomic</title>
    <link href="https://wuhaocn.github.io/2021/10/01/language/java/juc/atomic/readme/"/>
    <id>https://wuhaocn.github.io/2021/10/01/language/java/juc/atomic/readme/</id>
    <published>2021-10-01T13:12:11.460Z</published>
    <updated>2021-10-01T13:12:11.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>早期的JDK版本中，如果要并发的对Integer、Long、Double之类的Java原始类型或引用类型进行操作，一般都需要通过锁来控制并发，以防止数据不一致。JUC-Atomic原子类位于java.util.concurrent.atomic包下。该包提供了许多Java原始/引用类型的映射类。如AtomicInteger、AtomicLong、AtomicBoolean，这些类可以通过一种“无锁算法”，线程安全的操作Integer、Long、Boolean等原始类型。包中类分为五种：基本类型：    AtomicBoolean：布尔型原子类    AtomicInteger：整型原子类    AtomicLong：长整型原子类数组：    AtomicIntegerArray：整形数组原子类    AtomicLongArray：长整形数组原子类    AtomicReferenceArray：引用类型数组原子类引用类型：    AtomicReference：引用类型原子类    AtomicStampedRerence：原子更新引用类型里的字段原子类    AtomicMarkableReference：原子更新带有标记位的引用类型对象的属性：    AtomicIntegerFieldUpdater：原子更新整形字段的更新器    AtomicLongFieldUpdater：原子更新长整形字段的更新器    AtomicReferenceFieldUpdater：原子更新带有版本号的引用类型。        该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题    　　本文不会详细介绍这几种类型的api及使用，只是列出Atomic的实现原理，及比较重点的类基本类型原子类：    AtomicBoolean：布尔型原子类    AtomicInteger：整型原子类    AtomicLong：长整型原子类    这几个类的共同特点是都提供单个变量的原子方式访问和更新功能。以AtomicLong为代表，进行介绍。</code></pre><h3 id="2-实例解析"><a href="#2-实例解析" class="headerlink" title="2.实例解析"></a>2.实例解析</h3><ul><li>例子：我们使用 AtomicLong 来演示之前的线程不安全的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//变成了AtomicLong类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//定义计数器 闭锁</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;exception:&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;count:&#123;&#125;&quot;</span>+count.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count.incrementAndGet();<span class="comment">//先做增加再获取当前值</span></span><br><span class="line">        <span class="comment">//count.getAndIncrement();先获取当前值再做增加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解析</p><pre><code>  当使用AtomicLong去执行自增操作时，得出的最终结果count就是5000。数次运行情况下结果一致。不会带来线程不安全的情况。  那我们来看看AtomicLong是如何保证线程安全的呢。  我们看看incrementAndGet方法，看看AtomicLong如何实现单个变量的原子方式更新。Unsafe是CAS的核心类，AtomicLong是基于CAS实现的。  此处就介绍AtomicLong，AtomicBoolean、AtomicInteger、AtomicReference与之相似，就不一一介绍</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>incrementAndGet 方法实际上是调用 Unsafe 类的方法来执行操作，我们进入 Unsafe 里看看具体的 getAndAddLong 是如何实现原子方式更新的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> var6;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line">    <span class="keyword">return</span> var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 我们来解析一下这个方法，var1为当前调用这个方法的对象，var2是当前值，假如执行的2+1=3的操作，那么var4就是1。 var6是调用底层方法获得底层当前值。假设没有其他线程来处理count，那么var6就是var2。此处使用了一个do while循环。 compareAndSwapLong方法是native的，代表是java底层的方法。也是遵循CAS算法的api。compareAndSwap，比较并交换。 在getAndAddLong的while判断中，该方法实现的是：对于var1这个对象，如果当前值var2和底层值var6相同的话，就更新为后面的操作结果值。 当我们执行更新结果时，可能被其他线程修改，因此此处判断当前值与期望值相同时才允许更新。否则重新取出当前的底层值，和当前count的值再做比较。 保证当前值与底层值完全一致时才进行结果更新，以此保证线程安全。这也是Atomic使用CAS原理实现的机制。底层值是主内存中的值，当前值是源自于工作内存。 由于该方法的逻辑是采用自旋的方式不断更新目标值，直到更新成功，在并发量较低的环境下，线程冲突较少，自旋次数不会很多。 但是在高并发情况下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时的AtomicLong的自旋会成为瓶颈， 因此为了解决高并发环境下的AtomicLong的自旋瓶颈问题，引入了LongAdder。</code></pre><p><strong>LongAdder：</strong></p><p>AtomicLong 中有个内部变量 value 保存着实际的 long 值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value 变量其实是一个热点，也就是 N 个线程竞争一个热点。LongAdder 的基本思路就是分散热点，将 value 值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的 long 值，只要将各个槽中的变量值累加返回。</p><p>低并发、一般的业务场景下 AtomicLong 是足够了。如果并发量很多，存在大量写多读少的情况，那 LongAdder 可能更合适。</p><p><strong>AtomicBoolean：</strong></p><p>针对该类我们主要研究 compareAndSet 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实现的功能是高并发情况下只有一个线程能访问这个属性值，常用于初始化一次的功能中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean initialized = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( initialized.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>) )<span class="comment">//如果为false，更新为true</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化操作代码....</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>各原子类api及使用demo，可以参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/Multithread/Atomic.md">https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/Multithread/Atomic.md</a></p><p>主要是掌握CAS算法的设计思想，了解原子类如何保证原子操作。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/zhangbLearn/p/9922790.html">https://www.cnblogs.com/zhangbLearn/p/9922790.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;早期的JDK版本中，如果要并发的对Integer、Long、Double之类的Java原始类型或引用类型进行</summary>
      
    
    
    
    <category term="java" scheme="https://wuhaocn.github.io/categories/java/"/>
    
    
    <category term="atomic" scheme="https://wuhaocn.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>深入理解单例模式:静态内部类单例</title>
    <link href="https://wuhaocn.github.io/2021/10/01/language/java/design/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E5%8E%9F%E7%90%86/"/>
    <id>https://wuhaocn.github.io/2021/10/01/language/java/design/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E5%8E%9F%E7%90%86/</id>
    <published>2021-10-01T13:12:11.459Z</published>
    <updated>2021-10-01T13:12:11.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解单例模式：静态内部类单例原理"><a href="#深入理解单例模式：静态内部类单例原理" class="headerlink" title="深入理解单例模式：静态内部类单例原理"></a>深入理解单例模式：静态内部类单例原理</h1><p>本文主要介绍 java 的单例模式，以及详细剖析静态内部类之所以能够实现单例的原理。OK，废话不多说，进入正文。</p><h2 id="1-单例原则"><a href="#1-单例原则" class="headerlink" title="1.单例原则"></a>1.单例原则</h2><p>首先我们要先了解下单例的四大原则：</p><ul><li>1.构造私有。</li><li>2.以静态方法或者枚举返回实例。</li><li>3.确保实例只有一个，尤其是多线程环境。</li><li>4.确保反序列换时不会重新构建对象。</li></ul><h2 id="2-常用的单例模式："><a href="#2-常用的单例模式：" class="headerlink" title="2.常用的单例模式："></a>2.常用的单例模式：</h2><p>饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。</p><h3 id="2-1-饿汉模式："><a href="#2-1-饿汉模式：" class="headerlink" title="2.1.饿汉模式："></a>2.1.饿汉模式：</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。<br>参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon&#123;</span><br><span class="line">    private static SingleTon INSTANCE = new SingleTon();</span><br><span class="line">    private SingleTon()&#123;&#125;</span><br><span class="line">    public static SingleTon getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-懒汉模式："><a href="#2-2-懒汉模式：" class="headerlink" title="2.2.懒汉模式："></a>2.2.懒汉模式：</h3><p>懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险。<br>参考如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon&#123;</span><br><span class="line">    private static SingleTon  INSTANCE = null;</span><br><span class="line">    private SingleTon()&#123;&#125;</span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new SingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-双重锁懒汉模式-Double-Check-Lock"><a href="#2-3-双重锁懒汉模式-Double-Check-Lock" class="headerlink" title="2.3.双重锁懒汉模式(Double Check Lock)"></a>2.3.双重锁懒汉模式(Double Check Lock)</h3><p>DCL 模式的优点就是，只有在对象需要被使用时才创建，第一次判断 INSTANCE == null 为了避免非必要加锁，<br>当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全。<br>但是，由于 jvm 存在乱序执行功能，DCL 也会出现线程不安全的情况。具体分析如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon&#123;</span><br><span class="line">    private static SingleTon INSTANCE = null;</span><br><span class="line">    private SingleTon()&#123;&#125;</span><br><span class="line">    public static SingleTon getInstance()&#123;if(INSTANCE == null)&#123;</span><br><span class="line">        synchronized(SingleTon.class)&#123;</span><br><span class="line">            if(INSTANCE == null)&#123;</span><br><span class="line">                INSTANCE = new SingleTon();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>INSTANCE = new SingleTon();<br>这个步骤，其实在 jvm 里面的执行分为三步：</p><ul><li>1.在堆内存开辟内存空间。</li><li>2.在堆内存中实例化 SingleTon 里面的各个参数。</li><li>3.把对象指向堆内存空间。</li></ul><p>由于 jvm 存在乱序执行功能，所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，<br>INSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的 DCL 失效问题。</p><p>不过在 JDK1.5 之后，官方也发现了这个问题，故而具体化了 volatile，即在 JDK1.6 及以后，只要定义为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile static SingleTon INSTANCE = null;</span><br></pre></td></tr></table></figure><p>就可解决 DCL 失效问题。volatile 确保 INSTANCE 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</p><h3 id="2-4-静态内部类模式："><a href="#2-4-静态内部类模式：" class="headerlink" title="2.4.静态内部类模式："></a>2.4.静态内部类模式：</h3><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化 INSTANCE，故而不占内存。<br>即当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance()方法第一次被调用时，<br>才会去初始化 INSTANCE,第一次调用 getInstance()方法会导致虚拟机加载 SingleTonHoler 类，<br>这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon&#123;</span><br><span class="line">    private SingleTon()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingleTonHoler&#123;</span><br><span class="line">        private static SingleTon INSTANCE = new SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingleTon getInstance()&#123;</span><br><span class="line">        return SingleTonHoler.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。<br>类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。</p><ul><li>1.遇到 new、getstatic、setstatic 或者 invokestatic 这 4 个字节码指令时，对应的 java 代码场景为：<br>new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时(final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。</li><li>2.使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。</li><li>3.当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。</li><li>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的类)，虚拟机会先初始化这个类。</li><li>5.当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、<br>REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><p>这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，<br>那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。</p><p>我们再回头看下 getInstance()方法，调用的是 SingleTonHoler.INSTANCE，取的是 SingleTonHoler 里的 INSTANCE 对象，<br>跟上面那个 DCL 方法不同的是，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance()方法，<br>取的都是同一个 INSTANCE 对象，而不用去重新创建。当 getInstance()方法被调用时，SingleTonHoler 才在 SingleTon 的运行时常量池里，<br>把符号引用替换为直接引用，这时静态对象 INSTANCE 也真正被创建，然后再被 getInstance()方法返回出去，这点同饿汉模式。<br>那么 INSTANCE 在创建过程中又是如何保证线程安全的呢？在《深入理解 JAVA 虚拟机》中，有这么一句话:</p><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，<br>如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，<br>直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，<br>就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，<br>其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。</p><p>故而，可以看出 INSTANCE 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p><p>那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，<br>由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。</p><h3 id="2-5-枚举类型单例模式"><a href="#2-5-枚举类型单例模式" class="headerlink" title="2.5.枚举类型单例模式"></a>2.5.枚举类型单例模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//枚举单例：</span><br><span class="line">public enum SingleTon&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">    //TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举在 java 中与普通类一样，都能拥有字段与方法，而且枚举实例创建是线程安全的，在任何情况下，它都是一个单例。我们可直接以<br>SingleTon.INSTANCE 的方式调用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/mnb65482/article/details/80458571">https://blog.csdn.net/mnb65482/article/details/80458571</a><br>《深入理解 JAVA 虚拟机》<br>《Android 源码设计模式解析与实战》<br>《java 虚拟机规范》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解单例模式：静态内部类单例原理&quot;&gt;&lt;a href=&quot;#深入理解单例模式：静态内部类单例原理&quot; class=&quot;headerlink&quot; title=&quot;深入理解单例模式：静态内部类单例原理&quot;&gt;&lt;/a&gt;深入理解单例模式：静态内部类单例原理&lt;/h1&gt;&lt;p&gt;本文主要介绍</summary>
      
    
    
    
    <category term="java" scheme="https://wuhaocn.github.io/categories/java/"/>
    
    
    <category term="design" scheme="https://wuhaocn.github.io/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>AtomicBoolean</title>
    <link href="https://wuhaocn.github.io/2021/10/01/language/java/juc/atomic/AtomicBoolean/"/>
    <id>https://wuhaocn.github.io/2021/10/01/language/java/juc/atomic/AtomicBoolean/</id>
    <published>2021-10-01T13:12:11.459Z</published>
    <updated>2021-10-01T13:12:11.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码导读"><a href="#源码导读" class="headerlink" title="源码导读"></a>源码导读</h3><pre><code>java.util.concurrent.atomic.AtomicBoolean类提供了可以原子读取和写入的底层布尔值的操作，并且还包含高级原子操作。AtomicBoolean支持基础布尔变量上的原子操作。 它具有获取和设置方法，如在volatile变量上的读取和写入。也就是说，一个集合与同一变量上的任何后续get相关联。 原子compareAndSet方法也具有这些内存一致性功能。一般情况下，我们使用 AtomicBoolean 高效并发处理 “只初始化一次” 的功能要求采用volatile int value类型原子变量保证内存可见性采用Unsafe类 compareAndSwapInt方法实现变量值valueOffset的修改知识参考点：Unsafe类/ volatile 关键字/ CAS</code></pre><h3 id="源码参考"><a href="#源码参考" class="headerlink" title="源码参考"></a>源码参考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> boolean&#125; value that may be updated atomically. See the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.concurrent.atomic&#125; package specification for</span></span><br><span class="line"><span class="comment"> * description of the properties of atomic variables. An</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> AtomicBoolean&#125; is used in applications such as atomically</span></span><br><span class="line"><span class="comment"> * updated flags, and cannot be used as a replacement for a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Boolean&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicBoolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4654671469794556979L</span>;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicBoolean.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AtomicBoolean&#125; with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicBoolean</span><span class="params">(<span class="keyword">boolean</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AtomicBoolean&#125; with initial value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;a href=&quot;package-summary.html#weakCompareAndSet&quot;&gt;May fail</span></span><br><span class="line"><span class="comment">     * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is</span></span><br><span class="line"><span class="comment">     * only rarely an appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unconditionally sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">boolean</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">boolean</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = newValue ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets to the given value and returns the previous value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">boolean</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> prev;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, newValue));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the String representation of the current value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the String representation of the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.toString(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;源码导读&quot;&gt;&lt;a href=&quot;#源码导读&quot; class=&quot;headerlink&quot; title=&quot;源码导读&quot;&gt;&lt;/a&gt;源码导读&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicBoolean类提供了可以原子读取和写入</summary>
      
    
    
    
    <category term="java" scheme="https://wuhaocn.github.io/categories/java/"/>
    
    
    <category term="atomic" scheme="https://wuhaocn.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>分布式算法-raft</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8Fraft%E7%AE%97%E6%B3%95/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8Fraft%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-01T13:12:11.458Z</published>
    <updated>2021-10-01T13:12:11.458Z</updated>
    
    <content type="html"><![CDATA[<p>raft算法介绍</p><h3 id="Raft-算法"><a href="#Raft-算法" class="headerlink" title="Raft 算法"></a>Raft 算法</h3><h4 id="一、更加直观的-Raft-算法"><a href="#一、更加直观的-Raft-算法" class="headerlink" title="一、更加直观的 Raft 算法"></a>一、更加直观的 Raft 算法</h4><p>Raft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。<br>为了提高理解性，Raft 将一致性算法分为了几个部分，包括领导选取（leader selection）、日志复制（log replication）、安全（safety），并且使用了更强的一致性来减少了必须需要考虑的状态。</p><h4 id="1-解决什么问题"><a href="#1-解决什么问题" class="headerlink" title="1.解决什么问题"></a>1.解决什么问题</h4><p>分布式存储系统通常通过维护多个副本来提高系统的 availability，带来的代价就是分布式存储系统的核心问题之一：维护多个副本的一致性。</p><p>Raft 协议基于复制状态机（replicated state machine），即一组 server 从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一直的状态，一组 server 记录相同的操作日志，并以相同的顺序应用到状态机。</p><p><img src="https://img.alicdn.com/tfs/TB1fmKeiWmWBuNjy1XaXXXCbXXa-879-306.jpg" alt="replicated state machine" title="replicated state machine"></p><p>Raft 有一个明确的场景，就是管理复制日志的一致性。</p><p>如图，每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。<br>一致性算法管理来自客户端状态命令的复制日志，保证状态机处理的日志中的命令的顺序都是一致的，因此会得到相同的执行结果。</p><p><img src="https://img.alicdn.com/tfs/TB1PTN7i25TBuNjSspmXXaDRVXa-605-319.jpg" alt="state machine" title="state machine"></p><h4 id="2-Raft-概览"><a href="#2-Raft-概览" class="headerlink" title="2.Raft 概览"></a>2.Raft 概览</h4><p>先看一段动画演示，<a href="http://thesecretlivesofdata.com/raft/">Understandable Distributed Consensus</a> 。</p><p>相比 Paxos，Raft 算法理解起来直观的很。</p><p>Raft 算法将 Server 划分为 3 种状态，或者也可以称作角色：</p><ul><li>Leader</li></ul><p>负责 Client 交互和 log 复制，同一时刻系统中最多存在 1 个。</p><ul><li>Follower</li></ul><p>被动响应请求 RPC，从不主动发起请求 RPC。</p><ul><li>Candidate</li></ul><p>一种临时的角色，只存在于 leader 的选举阶段，某个节点想要变成 leader，那么就发起投票请求，同时自己变成 candidate。如果选举成功，则变为 candidate，否则退回为 follower</p><p>状态或者说角色的流转如下：</p><p><img src="https://img.alicdn.com/tfs/TB1UEuni.R1BeNjy0FmXXb0wVXa-1152-480.png" alt="state" title="state"></p><p>在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。</p><p>复制状态机通过复制日志来实现：</p><ul><li>日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令</li><li>状态机：状态机会按顺序执行这些命令</li><li>一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的</li></ul><h2 id="二、Raft-算法流程"><a href="#二、Raft-算法流程" class="headerlink" title="二、Raft 算法流程"></a>二、Raft 算法流程</h2><p>Raft 中使用心跳机制来出发 leader 选举。当服务器启动的时候，服务器成为 follower。只要 follower 从 leader 或者 candidate 收到有效的 RPCs 就会保持 follower 状态。如果 follower 在一段时间内（该段时间被称为 election timeout）没有收到消息，则它会假设当前没有可用的 leader，然后开启选举新 leader 的流程。</p><h3 id="1-Term"><a href="#1-Term" class="headerlink" title="1.Term"></a>1.Term</h3><p>Term 的概念类比中国历史上的朝代更替，Raft 算法将时间划分成为任意不同长度的任期（term）。</p><p>任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p><h3 id="2-RPC"><a href="#2-RPC" class="headerlink" title="2.RPC"></a>2.RPC</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs，为了在服务器之间传输快照增加了第三种 RPC。</p><p>RPC 有三种：</p><ul><li>RequestVote RPC：候选人在选举期间发起</li><li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成</li><li>InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者</li></ul><h3 id="3-选举流程"><a href="#3-选举流程" class="headerlink" title="3.选举流程"></a>3.选举流程</h3><p>（1）follower 增加当前的 term，转变为 candidate。<br>（2）candidate 投票给自己，并发送 RequestVote RPC 给集群中的其他服务器。<br>（3）收到 RequestVote 的服务器，在同一 term 中只会按照先到先得投票给至多一个 candidate。且只会投票给 log 至少和自身一样新的 candidate。</p><p><img src="https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200723272-896605592.png"></p><p><img src="https://images2018.cnblogs.com/blog/524341/201804/524341-20180416200738632-44217418.png"></p><p>candidate 节点保持（2）的状态，直到下面三种情况中的一种发生。</p><ul><li>该节点赢得选举。即收到大多数的节点的投票。则其转变为 leader 状态。</li><li>另一个服务器成为了 leader。即收到了 leader 的合法心跳包（term 值等于或大于当前自身 term 值）。则其转变为 follower 状态。</li><li>一段时间后依然没有胜者。该种情况下会开启新一轮的选举。</li></ul><p>Raft 中使用随机选举超时时间来解决当票数相同无法确定 leader 的问题。</p><h3 id="4-日志复制"><a href="#4-日志复制" class="headerlink" title="4.日志复制"></a>4.日志复制</h3><p>日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。</p><p>当 Leader 选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过 Leader 处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。</p><p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p><h2 id="三、Raft-和-Paxos-的工程应用"><a href="#三、Raft-和-Paxos-的工程应用" class="headerlink" title="三、Raft 和 Paxos 的工程应用"></a>三、Raft 和 Paxos 的工程应用</h2><p>Raft 算法的论文相比 Paxos 直观很多，更容易在工程上实现。</p><p>可以看到 Raft 算法的实现已经非常多了，<a href="https://raft.github.io/#implementations">https://raft.github.io//#implementations</a></p><h3 id="1-Raft-的应用"><a href="#1-Raft-的应用" class="headerlink" title="1.Raft 的应用"></a>1.Raft 的应用</h3><p>这里用 ETCD 来关注 Raft 的应用，ETCD 目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。<br>Etcd 主要用途是共享配置和服务发现，实现一致性使用了 Raft 算法。<br>更多 Etcd 的应用可以查看文档：<a href="https://coreos.com/etcd/docs/latest/">https://coreos.com/etcd/docs/latest/</a></p><h3 id="2-Zookeeper-中的-Paxos"><a href="#2-Zookeeper-中的-Paxos" class="headerlink" title="2.Zookeeper 中的 Paxos"></a>2.Zookeeper 中的 Paxos</h3><p>Zookeeper 使用了一种修改后的 Paxos 协议。</p><p>在 Zookeeper 中，始终分为两种场景:</p><ul><li>Leader activation</li></ul><p>在这个场景里，系统中缺乏 Leader(primary)，通过一个类似 paxos 协议的过程完成 Leader 选举。</p><ul><li>Active messaging<br>在 这个场景里，Leader 接收客户端发送的更新操作，以一种类似两阶段提交的过程在各个 follower (secondary)节点上进行更新操作。</li></ul><p>在 Leader activation 场景中完成 leader 选举及数据同步后，系统转入 Active messaging 场景，在 active messaging 中 leader 异常后，系统转入 Leader activation 场景。</p><p>无论在那种场景，Zookeeper 依赖于一个全局版本号:zxid。zxid 由(epoch, count)两部分组成， 高位的 epoch 部分是选举编号，每次提议进行新的 leader 选举时 epoch 都会增加，低位的 count 部分 是 leader 为每个更新操作决定的序号。可以认为，一个 leader 对应一个唯一的 epoch，每个 leader 任期内产生的更新操作对应一个唯一的有序的 count，从而从全局的视野，一个 zxid 代表了一个更新操作的全局序号(版本号)。</p><p>Zookeeper 通过 zxid 将两个场景阶段较好的结合起来，且能保证全局的强一致性。由于同一时刻只有一个 zookeeper 节点能获得超过半数的 follower，所以同一时刻最多只存在唯一的 leader;每个 leader 利用 FIFO 以 zxid 顺序更新各个 follower，只有成功完成前一个更新操作的才会进行下一个更新操作，在同一个 leader 任期内，数据在全局满足 quorum 约束的强一致，即读超过半数的节点 一定可以读到最新已提交的数据;每个成功的更新操作都至少被超过半数的节点确认，使得新选举 的 leader 一定可以包括最新的已成功提交的数据。</p><h3 id="3-如何解决-split-brain-问题"><a href="#3-如何解决-split-brain-问题" class="headerlink" title="3.如何解决 split brain 问题"></a>3.如何解决 split brain 问题</h3><p>分布式协议一个著名问题就是 split brain 问题。</p><p>简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。</p><p>区块链的分叉其实类似分布式系统的 split brain。</p><p>一般来说，Zookeeper 会默认设置：</p><ul><li>zookeeper cluster 的节点数目必须是奇数。</li><li>zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。</li></ul><p>Majority 就是一种 Qunroms 的方式来支持 Leader 选举，可以防止 split brain 出现。奇数个节点可以在相同容错能力的情况下节省资源。</p><h2 id="四、从-CAP-的角度理解几种不同的算法"><a href="#四、从-CAP-的角度理解几种不同的算法" class="headerlink" title="四、从 CAP 的角度理解几种不同的算法"></a>四、从 CAP 的角度理解几种不同的算法</h2><h3 id="1-两阶段提交协议"><a href="#1-两阶段提交协议" class="headerlink" title="1.两阶段提交协议"></a>1.两阶段提交协议</h3><p>两阶段提交系统具有完全的 C，很糟糕的 A，很糟糕的 P。<br>首先，两阶段提交协议保证了副本间是完全一致的，这也是协议的设计目的。再者，协议在一个节点出现异常时，就无法更新数据，其服务可用性较低。最后，一旦协调者与参与者之间网络分化，无法提供服务。</p><h3 id="2-Paxos-和-Raft-算法"><a href="#2-Paxos-和-Raft-算法" class="headerlink" title="2.Paxos 和 Raft 算法"></a>2.Paxos 和 Raft 算法</h3><p>Paxos 协议和 Raft 算法都是强一致性协议。Paxos 只有两种情况下服务不可用:一是超过半数的 Proposer 异常，二是出现活锁。前者可以通过增加 Proposer 的个数来 降低由于 Proposer 异常影响服务的概率，后者本身发生的概率就极低。最后，只要能与超过半数的 Proposer 通信就可以完成协议流程，协议本身具有较好的容忍网络分区的能力。</p><p>参考<br><a href="https://blog.csdn.net/cszhouwei/article/details/38374603">Raft 一致性算法</a><br><a href="http://www.infoq.com/cn/articles/raft-paper">Raft 一致性算法论文译文</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;raft算法介绍&lt;/p&gt;
&lt;h3 id=&quot;Raft-算法&quot;&gt;&lt;a href=&quot;#Raft-算法&quot; class=&quot;headerlink&quot; title=&quot;Raft 算法&quot;&gt;&lt;/a&gt;Raft 算法&lt;/h3&gt;&lt;h4 id=&quot;一、更加直观的-Raft-算法&quot;&gt;&lt;a href=&quot;#一、</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java动态调试技术原理及实践</title>
    <link href="https://wuhaocn.github.io/2021/10/01/language/java/bytecode/Java%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
    <id>https://wuhaocn.github.io/2021/10/01/language/java/bytecode/Java%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-10-01T13:12:11.458Z</published>
    <updated>2021-10-01T13:12:11.459Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java动态调试技术原理及实践"><a href="#Java动态调试技术原理及实践" class="headerlink" title="Java动态调试技术原理及实践"></a>Java动态调试技术原理及实践</h3><h4 id="1-动态调试要解决的问题"><a href="#1-动态调试要解决的问题" class="headerlink" title="1. 动态调试要解决的问题"></a>1. 动态调试要解决的问题</h4><p>断点调试是我们最常使用的调试手段，它可以获取到方法执行过程中的变量信息，并可以观察到方法的执行路径。<br>但断点调试会在断点位置停顿，使得整个应用停止响应。在线上停顿应用是致命的，动态调试技术给了我们创造新的调试模式的想象空间。<br>本文将研究 Java 语言中的动态调试技术，首先概括 Java 动态调试所涉及的技术基础，接着介绍我们在 Java 动态调试领域的思考及实践，<br>通过结合实际业务场景，设计并实现了一种具备动态性的断点调试工具 Java-debug-tool，显著提高了故障排查效率。</p><h4 id="2-Java-Agent-技术"><a href="#2-Java-Agent-技术" class="headerlink" title="2. Java Agent 技术"></a>2. Java Agent 技术</h4><p>JVMTI （JVM Tool Interface）是 Java 虚拟机对外提供的 Native 编程接口，通过 JVMTI，外部进程可以获取到运行时 JVM 的诸多信息，比如线程、GC 等。<br>Agent 是一个运行在目标 JVM 的特定程序，它的职责是负责从目标 JVM 中获取数据，然后将数据传递给外部进程。<br>加载 Agent 的时机可以是目标 JVM 启动之时，也可以是在目标 JVM 运行时进行加载，而在目标 JVM 运行时进行 Agent 加载具备动态性，<br>对于时机未知的 Debug 场景来说非常实用。下面将详细分析 Java Agent 技术的实现细节。</p><h5 id="2-1-Agent-的实现模式"><a href="#2-1-Agent-的实现模式" class="headerlink" title="2.1 Agent 的实现模式"></a>2.1 Agent 的实现模式</h5><p>JVMTI 是一套 Native 接口，在 Java SE 5 之前，要实现一个 Agent 只能通过编写 Native 代码来实现。<br>从 Java SE 5 开始，可以使用 Java 的 Instrumentation 接口（java.lang.instrument）来编写 Agent。<br>无论是通过 Native 的方式还是通过 Java Instrumentation 接口的方式来编写 Agent，它们的工作都是借助 JVMTI 来进行完成，<br>下面介绍通过 Java Instrumentation 接口编写 Agent 的方法。</p><h6 id="2-1-1-通过-Java-Instrumentation-API"><a href="#2-1-1-通过-Java-Instrumentation-API" class="headerlink" title="2.1.1 通过 Java Instrumentation API"></a>2.1.1 通过 Java Instrumentation API</h6><p>实现 Agent 启动方法</p><p>Java Agent 支持目标 JVM 启动时加载，也支持在目标 JVM 运行时加载，这两种不同的加载模式会使用不同的入口函数，<br>如果需要在目标 JVM 启动的同时加载 Agent，那么可以选择实现下面的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] public static void premain(String agentArgs, Instrumentation inst);</span><br><span class="line">[2] public static void premain(String agentArgs);</span><br></pre></td></tr></table></figure><p>JVM 将首先寻找[1]，如果没有发现[1]，再寻找[2]。如果希望在目标 JVM 运行时加载 Agent，则需要实现下面的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] public static void agentmain(String agentArgs, Instrumentation inst);</span><br><span class="line">[2] public static void agentmain(String agentArgs);</span><br></pre></td></tr></table></figure><p>这两组方法的第一个参数 AgentArgs 是随同 “– javaagent”一起传入的程序参数，如果这个字符串代表了多个参数，就需要自己解析这些参数。<br>inst 是 Instrumentation 类型的对象，是 JVM 自动传入的，我们可以拿这个参数进行类增强等操作。</p><p>指定 Main-Class<br>Agent 需要打包成一个 jar 包，在 ManiFest 属性中指定“Premain-Class”或者“Agent-Class”：<br>Premain-Class: class<br>Agent-Class: class<br>挂载到目标 JVM<br>将编写的 Agent 打成 jar 包后，就可以挂载到目标 JVM 上去了。如果选择在目标 JVM 启动时加载 Agent，则可以使用 “-javaagent:<jarpath>[=<option>]”，<br>具体的使用方法可以使用“Java -Help”来查看。如果想要在运行时挂载 Agent 到目标 JVM，就需要做一些额外的开发了。<br>com.sun.tools.attach.VirtualMachine 这个类代表一个 JVM 抽象，可以通过这个类找到目标 JVM，并且将 Agent 挂载到目标 JVM 上。<br>下面是使用 com.sun.tools.attach.VirtualMachine 进行动态挂载 Agent 的一般实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void attachAgentToTargetJVM() throws Exception &#123;</span><br><span class="line">    List&lt;VirtualMachineDescriptor&gt; virtualMachineDescriptors = VirtualMachine.list();</span><br><span class="line">    VirtualMachineDescriptor targetVM = null;</span><br><span class="line">    for (VirtualMachineDescriptor descriptor : virtualMachineDescriptors) &#123;</span><br><span class="line">        if (descriptor.id().equals(configure.getPid())) &#123;</span><br><span class="line">            targetVM = descriptor;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (targetVM == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;could not find the target jvm by process id:&quot; + configure.getPid());</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualMachine virtualMachine = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        virtualMachine = VirtualMachine.attach(targetVM);</span><br><span class="line">        virtualMachine.loadAgent(&quot;&#123;agent&#125;&quot;, &quot;&#123;params&#125;&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (virtualMachine != null) &#123;</span><br><span class="line">            virtualMachine.detach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过指定的进程 ID 找到目标 JVM，然后通过 Attach 挂载到目标 JVM 上，执行加载 Agent 操作。<br>VirtualMachine 的 Attach 方法就是用来将 Agent 挂载到目标 JVM 上去的，而 Detach 则是将 Agent 从目标 JVM 卸载。关<br>于 Agent 是如何挂载到目标 JVM 上的具体技术细节，将在下文中进行分析。</p><h5 id="2-2-启动时加载-Agent"><a href="#2-2-启动时加载-Agent" class="headerlink" title="2.2 启动时加载 Agent"></a>2.2 启动时加载 Agent</h5><h6 id="2-2-1-参数解析"><a href="#2-2-1-参数解析" class="headerlink" title="2.2.1 参数解析"></a>2.2.1 参数解析</h6><p>创建 JVM 时，JVM 会进行参数解析，即解析那些用来配置 JVM 启动的参数，比如堆大小、GC 等；本文主要关注解析的参数为-agentlib、 -agentpath、 -javaagent，这几个参数用来指定 Agent，JVM 会根据这几个参数加载 Agent。下面来分析一下 JVM 是如何解析这几个参数的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// -agentlib and -agentpath</span><br><span class="line">if (match_option(option, &quot;-agentlib:&quot;, &amp;tail) ||</span><br><span class="line">        (is_absolute_path = match_option(option, &quot;-agentpath:&quot;, &amp;tail))) &#123;</span><br><span class="line">    if(tail != NULL) &#123;</span><br><span class="line">      const char* pos = strchr(tail, &#x27;=&#x27;);</span><br><span class="line">      size_t len = (pos == NULL) ? strlen(tail) : pos - tail;</span><br><span class="line">      char* name = strncpy(NEW_C_HEAP_ARRAY(char, len + 1, mtArguments), tail, len);</span><br><span class="line">      name[len] = &#x27;\0&#x27;;</span><br><span class="line">      char *options = NULL;</span><br><span class="line">      if(pos != NULL) &#123;</span><br><span class="line">        options = os::strdup_check_oom(pos + 1, mtArguments);</span><br><span class="line">      &#125;</span><br><span class="line">      #if !INCLUDE_JVMTI</span><br><span class="line">      if (valid_jdwp_agent(name, is_absolute_path)) &#123;</span><br><span class="line">        jio_fprintf(defaultStream::error_stream(),</span><br><span class="line">          &quot;Debugging agents are not supported in this VM\n&quot;);</span><br><span class="line">        return JNI_ERR;</span><br><span class="line">      &#125;</span><br><span class="line">      #endif // !INCLUDE_JVMTI</span><br><span class="line">      add_init_agent(name, options, is_absolute_path);</span><br><span class="line">    &#125;</span><br><span class="line">  // -javaagent</span><br><span class="line">  &#125; else if (match_option(option, &quot;-javaagent:&quot;, &amp;tail)) &#123;</span><br><span class="line">      #if !INCLUDE_JVMTI</span><br><span class="line">    jio_fprintf(defaultStream::error_stream(),</span><br><span class="line">      &quot;Instrumentation agents are not supported in this VM\n&quot;);</span><br><span class="line">    return JNI_ERR;</span><br><span class="line">      #else</span><br><span class="line">    if (tail != NULL) &#123;</span><br><span class="line">      size_t length = strlen(tail) + 1;</span><br><span class="line">      char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);</span><br><span class="line">      jio_snprintf(options, length, &quot;%s&quot;, tail);</span><br><span class="line">      add_init_agent(&quot;instrument&quot;, options, false);</span><br><span class="line">      // java agents need module java.instrument</span><br><span class="line">      if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) &#123;</span><br><span class="line">        return JNI_ENOMEM;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      #endif // !INCLUDE_JVMTI</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的代码片段截取自 hotspot/src/share/vm/runtime/arguments.cpp 中的 Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, Flag::Flags origin) 函数，该函数用来解析一个具体的 JVM 参数。这段代码的主要功能是解析出需要加载的 Agent 路径，然后调用 add_init_agent 函数进行解析结果的存储。下面先看一下 add_init_agent 函数的具体实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// -agentlib and -agentpath arguments</span><br><span class="line">static AgentLibraryList _agentList;</span><br><span class="line">static void add_init_agent(const char* name, char* options, bool absolute_path)</span><br><span class="line">  &#123; _agentList.add(new AgentLibrary(name, options, absolute_path, NULL)); &#125;</span><br></pre></td></tr></table></figure><p>AgentLibraryList 是一个简单的链表结构，add_init_agent 函数将解析好的、需要加载的 Agent 添加到这个链表中，等待后续的处理。</p><p>这里需要注意，解析-javaagent 参数有一些特别之处，这个参数用来指定一个我们通过 Java Instrumentation API 来编写的 Agent，Java Instrumentation API 底层依赖的是 JVMTI，对-JavaAgent 的处理也说明了这一点，在调用 add_init_agent 函数时第一个参数是“instrument”，关于加载 Agent 这个问题在下一小节进行展开。到此，我们知道在启动 JVM 时指定的 Agent 已经被 JVM 解析完存放在了一个链表结构中。下面来分析一下 JVM 是如何加载这些 Agent 的。</p><h6 id="2-2-2-执行加载操作"><a href="#2-2-2-执行加载操作" class="headerlink" title="2.2.2 执行加载操作"></a>2.2.2 执行加载操作</h6><p>在创建 JVM 进程的函数中，解析完 JVM 参数之后，下面的这段代码和加载 Agent 相关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> // Launch -agentlib/-agentpath and converted -Xrun agents</span><br><span class="line">if (Arguments::init_agents_at_startup()) &#123;</span><br><span class="line">  create_vm_init_agents();</span><br><span class="line">&#125;</span><br><span class="line">static bool init_agents_at_startup() &#123;</span><br><span class="line">  return !_agentList.is_empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 JVM 判断出上一小节中解析出来的 Agent 不为空的时候，就要去调用函数 create_vm_init_agents 来加载 Agent，下面来分析一下 create_vm_init_agents 函数是如何加载 Agent 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Threads::create_vm_init_agents() &#123;</span><br><span class="line">  AgentLibrary* agent;</span><br><span class="line">  for (agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) &#123;</span><br><span class="line">    OnLoadEntry_t  on_load_entry = lookup_agent_on_load(agent);</span><br><span class="line">    if (on_load_entry != NULL) &#123;</span><br><span class="line">      // Invoke the Agent_OnLoad function</span><br><span class="line">      jint err = (*on_load_entry)(&amp;main_vm, agent-&gt;options(), NULL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create_vm_init_agents 这个函数通过遍历 Agent 链表来逐个加载 Agent。通过这段代码可以看出，首先通过 lookup_agent_on_load 来加载 Agent 并且找到 Agent_OnLoad 函数，这个函数是 Agent 的入口函数。如果没找到这个函数，则认为是加载了一个不合法的 Agent，则什么也不做，否则调用这个函数，这样 Agent 的代码就开始执行起来了。对于使用 Java Instrumentation API 来编写 Agent 的方式来说，在解析阶段观察到在 add_init_agent 函数里面传递进去的是一个叫做”instrument”的字符串，其实这是一个动态链接库。在 Linux 里面，这个库叫做 libinstrument.so，在 BSD 系统中叫做 libinstrument.dylib，该动态链接库在{JAVA_HOME}/jre/lib/目录下。</p><h6 id="2-2-3-Instrument-动态链接库"><a href="#2-2-3-Instrument-动态链接库" class="headerlink" title="2.2.3 Instrument 动态链接库"></a>2.2.3 Instrument 动态链接库</h6><p>libinstrument 用来支持使用 Java Instrumentation API 来编写 Agent，在 libinstrument 中有一个非常重要的类称为：JPLISAgent（Java Programming Language Instrumentation Services Agent），它的作用是初始化所有通过 Java Instrumentation API 编写的 Agent，并且也承担着通过 JVMTI 实现 Java Instrumentation 中暴露 API 的责任。<br>我们已经知道，在 JVM 启动的时候，JVM 会通过-javaagent 参数加载 Agent。最开始加载的是 libinstrument 动态链接库，然后在动态链接库里面找到 JVMTI 的入口方法：Agent_OnLoad。下面就来分析一下在 libinstrument 动态链接库中，Agent_OnLoad 函数是怎么实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">DEF_Agent_OnLoad(JavaVM *vm, char *tail, void * reserved) &#123;</span><br><span class="line">    initerror = createNewJPLISAgent(vm, &amp;agent);</span><br><span class="line">    if ( initerror == JPLIS_INIT_ERROR_NONE ) &#123;</span><br><span class="line">        if (parseArgumentTail(tail, &amp;jarfile, &amp;options) != 0) &#123;</span><br><span class="line">            fprintf(stderr, &quot;-javaagent: memory allocation failure.\n&quot;);</span><br><span class="line">            return JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        attributes = readAttributes(jarfile);</span><br><span class="line">        premainClass = getAttribute(attributes, &quot;Premain-Class&quot;);</span><br><span class="line">        /* Save the jarfile name */</span><br><span class="line">        agent-&gt;mJarfile = jarfile;</span><br><span class="line">        /*</span><br><span class="line">         * Convert JAR attributes into agent capabilities</span><br><span class="line">         */</span><br><span class="line">        convertCapabilityAttributes(attributes, agent);</span><br><span class="line">        /*</span><br><span class="line">         * Track (record) the agent class name and options data</span><br><span class="line">         */</span><br><span class="line">        initerror = recordCommandLineData(agent, premainClass, options);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片段是经过精简的 libinstrument 中 Agent_OnLoad 实现的，大概的流程就是：先创建一个 JPLISAgent，然后将 ManiFest 中设定的一些参数解析出来， 比如（Premain-Class）等。创建了 JPLISAgent 之后，调用 initializeJPLISAgent 对这个 Agent 进行初始化操作。跟进 initializeJPLISAgent 看一下是如何初始化的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JPLISInitializationError initializeJPLISAgent(JPLISAgent *agent, JavaVM *vm, jvmtiEnv *jvmtienv) &#123;</span><br><span class="line">    /* check what capabilities are available */</span><br><span class="line">    checkCapabilities(agent);</span><br><span class="line">    /* check phase - if live phase then we don&#x27;t need the VMInit event */</span><br><span class="line">    jvmtierror = (*jvmtienv)-&gt;GetPhase(jvmtienv, &amp;phase);</span><br><span class="line">    /* now turn on the VMInit event */</span><br><span class="line">    if ( jvmtierror == JVMTI_ERROR_NONE ) &#123;</span><br><span class="line">        jvmtiEventCallbacks callbacks;</span><br><span class="line">        memset(&amp;callbacks, 0, sizeof(callbacks));</span><br><span class="line">        callbacks.VMInit = &amp;eventHandlerVMInit;</span><br><span class="line">        jvmtierror = (*jvmtienv)-&gt;SetEventCallbacks(jvmtienv,&amp;callbacks,sizeof(callbacks));</span><br><span class="line">    &#125;</span><br><span class="line">    if ( jvmtierror == JVMTI_ERROR_NONE ) &#123;</span><br><span class="line">        jvmtierror = (*jvmtienv)-&gt;SetEventNotificationMode(jvmtienv,JVMTI_ENABLE,JVMTI_EVENT_VM_INIT,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return (jvmtierror == JVMTI_ERROR_NONE)? JPLIS_INIT_ERROR_NONE : JPLIS_INIT_ERROR_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们关注 callbacks.VMInit = &eventHandlerVMInit;这行代码，这里设置了一个 VMInit 事件的回调函数，表示在 JVM 初始化的时候会回调 eventHandlerVMInit 函数。下面来看一下这个函数的实现细节，猜测就是在这里调用了 Premain 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void JNICALL  eventHandlerVMInit( jvmtiEnv *jvmtienv,JNIEnv *jnienv,jthread thread) &#123;</span><br><span class="line">   // ...</span><br><span class="line">   success = processJavaStart( environment-&gt;mAgent, jnienv);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">jboolean  processJavaStart(JPLISAgent *agent,JNIEnv *jnienv) &#123;</span><br><span class="line">    result = createInstrumentationImpl(jnienv, agent);</span><br><span class="line">    /*</span><br><span class="line">     *  Load the Java agent, and call the premain.</span><br><span class="line">     */</span><br><span class="line">    if ( result ) &#123;</span><br><span class="line">        result = startJavaAgent(agent, jnienv, agent-&gt;mAgentClassName, agent-&gt;mOptionsString, agent-&gt;mPremainCaller);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">jboolean startJavaAgent( JPLISAgent *agent,JNIEnv *jnienv,const char *classname,const char *optionsString,jmethodID agentMainMethod) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  invokeJavaAgentMainMethod(jnienv,agent-&gt;mInstrumentationImpl,agentMainMethod, classNameObject,optionsStringObject);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，Instrument 已经实例化，invokeJavaAgentMainMethod 这个方法将我们的 Premain 方法执行起来了。接着，我们就可以根据 Instrument 实例来做我们想要做的事情了。</p><h5 id="2-3-运行时加载-Agent"><a href="#2-3-运行时加载-Agent" class="headerlink" title="2.3 运行时加载 Agent"></a>2.3 运行时加载 Agent</h5><p>比起 JVM 启动时加载 Agent，运行时加载 Agent 就比较有诱惑力了，因为运行时加载 Agent 的能力给我们提供了很强的动态性，我们可以在需要的时候加载 Agent 来进行一些工作。因为是动态的，我们可以按照需求来加载所需要的 Agent，下面来分析一下动态加载 Agent 的相关技术细节。</p><h6 id="2-3-1-AttachListener"><a href="#2-3-1-AttachListener" class="headerlink" title="2.3.1 AttachListener"></a>2.3.1 AttachListener</h6><p>Attach 机制通过 Attach Listener 线程来进行相关事务的处理，下面来看一下 Attach Listener 线程是如何初始化的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Starts the Attach Listener thread</span><br><span class="line">void AttachListener::init() &#123;</span><br><span class="line">  // 创建线程相关部分代码被去掉了</span><br><span class="line">  const char thread_name[] = &quot;Attach Listener&quot;;</span><br><span class="line">  Handle string = java_lang_String::create_from_str(thread_name, THREAD);</span><br><span class="line">  &#123; MutexLocker mu(Threads_lock);</span><br><span class="line">    JavaThread* listener_thread = new JavaThread(&amp;attach_listener_thread_entry);</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，一个线程启动之后都需要指定一个入口来执行代码，Attach Listener 线程的入口是 attach_listener_thread_entry，下面看一下这个函数的具体实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void attach_listener_thread_entry(JavaThread* thread, TRAPS) &#123;</span><br><span class="line">  AttachListener::set_initialized();</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">      AttachOperation* op = AttachListener::dequeue();</span><br><span class="line">      // find the function to dispatch too</span><br><span class="line">      AttachOperationFunctionInfo* info = NULL;</span><br><span class="line">      for (int i=0; funcs[i].name != NULL; i++) &#123;</span><br><span class="line">        const char* name = funcs[i].name;</span><br><span class="line">        if (strcmp(op-&gt;name(), name) == 0) &#123;</span><br><span class="line">          info = &amp;(funcs[i]); break;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">       // dispatch to the function that implements this operation</span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数执行逻辑，大概是这样的：</p><p>拉取一个需要执行的任务：AttachListener::dequeue。</p><p>查询匹配的命令处理函数。</p><p>执行匹配到的命令执行函数。</p><p>其中第二步里面存在一个命令函数表，整个表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; &quot;agentProperties&quot;,  get_agent_properties &#125;,</span><br><span class="line">  &#123; &quot;datadump&quot;,         data_dump &#125;,</span><br><span class="line">  &#123; &quot;dumpheap&quot;,         dump_heap &#125;,</span><br><span class="line">  &#123; &quot;load&quot;,             load_agent &#125;,</span><br><span class="line">  &#123; &quot;properties&quot;,       get_system_properties &#125;,</span><br><span class="line">  &#123; &quot;threaddump&quot;,       thread_dump &#125;,</span><br><span class="line">  &#123; &quot;inspectheap&quot;,      heap_inspection &#125;,</span><br><span class="line">  &#123; &quot;setflag&quot;,          set_flag &#125;,</span><br><span class="line">  &#123; &quot;printflag&quot;,        print_flag &#125;,</span><br><span class="line">  &#123; &quot;jcmd&quot;,             jcmd &#125;,</span><br><span class="line">  &#123; NULL,               NULL &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于加载 Agent 来说，命令就是“load”。现在，我们知道了 Attach Listener 大概的工作模式，但是还是不太清楚任务从哪来，这个秘密就藏在 AttachListener::dequeue 这行代码里面，接下来我们来分析一下 dequeue 这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinuxAttachOperation* LinuxAttachListener::dequeue() &#123;</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    // wait for client to connect</span><br><span class="line">    struct sockaddr addr;</span><br><span class="line">    socklen_t len = sizeof(addr);</span><br><span class="line">    RESTARTABLE(::accept(listener(), &amp;addr, &amp;len), s);</span><br><span class="line">    // get the credentials of the peer and check the effective uid/guid</span><br><span class="line">    // - check with jeff on this.</span><br><span class="line">    struct ucred cred_info;</span><br><span class="line">    socklen_t optlen = sizeof(cred_info);</span><br><span class="line">    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&amp;cred_info, &amp;optlen) == -1) &#123;</span><br><span class="line">      ::close(s);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    // peer credential look okay so we read the request</span><br><span class="line">    LinuxAttachOperation* op = read_request(s);</span><br><span class="line">    return op;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Linux 上的实现，不同的操作系统实现方式不太一样。上面的代码表面，Attach Listener 在某个端口监听着，通过 accept 来接收一个连接，<br>然后从这个连接里面将请求读取出来，然后将请求包装成一个 AttachOperation 类型的对象，之后就会从表里查询对应的处理函数，然后进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Attach Listener使用一种被称为“懒加载”的策略进行初始化，也就是说，JVM启动的时候Attach Listener并不一定会启动起来。下面我们来分析一下这种“懒加载”策略的具体实现方案。</span><br><span class="line">  // Start Attach Listener if +StartAttachListener or it can&#x27;t be started lazily</span><br><span class="line">  if (!DisableAttachMechanism) &#123;</span><br><span class="line">    AttachListener::vm_start();</span><br><span class="line">    if (StartAttachListener || AttachListener::init_at_startup()) &#123;</span><br><span class="line">      AttachListener::init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// Attach Listener is started lazily except in the case when</span><br><span class="line">// +ReduseSignalUsage is used</span><br><span class="line">bool AttachListener::init_at_startup() &#123;</span><br><span class="line">  if (ReduceSignalUsage) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码截取自 create_vm 函数，DisableAttachMechanism、StartAttachListener 和 ReduceSignalUsage 这三个变量默认都是 false，所以 AttachListener::init();这行代码不会在 create_vm 的时候执行，而 vm_start 会执行。下面来看一下这个函数的实现细节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void AttachListener::vm_start() &#123;</span><br><span class="line">  char fn[UNIX_PATH_MAX];</span><br><span class="line">  struct stat64 st;</span><br><span class="line">  int ret;</span><br><span class="line">  int n = snprintf(fn, UNIX_PATH_MAX, &quot;%s/.java_pid%d&quot;,</span><br><span class="line">           os::get_temp_directory(), os::current_process_id());</span><br><span class="line">  assert(n &lt; (int)UNIX_PATH_MAX, &quot;java_pid file name buffer overflow&quot;);</span><br><span class="line">  RESTARTABLE(::stat64(fn, &amp;st), ret);</span><br><span class="line">  if (ret == 0) &#123;</span><br><span class="line">    ret = ::unlink(fn);</span><br><span class="line">    if (ret == -1) &#123;</span><br><span class="line">      log_debug(attach)(&quot;Failed to remove stale attach pid file at %s&quot;, fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在 Linux 上的实现，是将/tmp/目录下的.java_pid{pid}文件删除，后面在创建 Attach Listener 线程的时候会创建出来这个文件。上面说到，AttachListener::init()这行代码不会在 create_vm 的时候执行，这行代码的实现已经在上文中分析了，就是创建 Attach Listener 线程，并监听其他 JVM 的命令请求。现在来分析一下这行代码是什么时候被调用的，也就是“懒加载”到底是怎么加载起来的。</p><p>// Signal Dispatcher needs to be started before VMInit event is posted<br>os::signal_init();<br>这是 create_vm 中的一段代码，看起来跟信号相关，其实 Attach 机制就是使用信号来实现“懒加载“的。下面我们来仔细地分析一下这个过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void os::signal_init() &#123;</span><br><span class="line">  if (!ReduceSignalUsage) &#123;</span><br><span class="line">    // Setup JavaThread for processing signals</span><br><span class="line">    EXCEPTION_MARK;</span><br><span class="line">    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), true, CHECK);</span><br><span class="line">    instanceKlassHandle klass (THREAD, k);</span><br><span class="line">    instanceHandle thread_oop = klass-&gt;allocate_instance_handle(CHECK);</span><br><span class="line">    const char thread_name[] = &quot;Signal Dispatcher&quot;;</span><br><span class="line">    Handle string = java_lang_String::create_from_str(thread_name, CHECK);</span><br><span class="line">    // Initialize thread_oop to put it into the system threadGroup</span><br><span class="line">    Handle thread_group (THREAD, Universe::system_thread_group());</span><br><span class="line">    JavaValue result(T_VOID);</span><br><span class="line">    JavaCalls::call_special(&amp;result, thread_oop,klass,vmSymbols::object_initializer_name(),vmSymbols::threadgroup_string_void_signature(),</span><br><span class="line">                           thread_group,string,CHECK);</span><br><span class="line">    KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());</span><br><span class="line">    JavaCalls::call_special(&amp;result,thread_group,group,vmSymbols::add_method_name(),vmSymbols::thread_void_signature(),thread_oop,CHECK);</span><br><span class="line">    os::signal_init_pd();</span><br><span class="line">    &#123; MutexLocker mu(Threads_lock);</span><br><span class="line">      JavaThread* signal_thread = new JavaThread(&amp;signal_thread_entry);</span><br><span class="line">     // ...</span><br><span class="line">    &#125;</span><br><span class="line">    // Handle ^BREAK</span><br><span class="line">    os::signal(SIGBREAK, os::user_handler());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 创建了一个新的进程来实现信号处理，这个线程叫“Signal Dispatcher”，一个线程创建之后需要有一个入口，“Signal Dispatcher”的入口是 signal_thread_entry：</p><p>这段代码截取自 signal_thread_entry 函数，截取中的内容是和 Attach 机制信号处理相关的代码。这段代码的意思是，当接收到“SIGBREAK”信号，就执行接下来的代码，这个信号是需要 Attach 到 JVM 上的信号发出来，这个后面会再分析。我们先来看一句关键的代码：AttachListener::is_init_trigger()：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool AttachListener::is_init_trigger() &#123;</span><br><span class="line">  if (init_at_startup() || is_initialized()) &#123;</span><br><span class="line">    return false;               // initialized at startup or already initialized</span><br><span class="line">  &#125;</span><br><span class="line">  char fn[PATH_MAX+1];</span><br><span class="line">  sprintf(fn, &quot;.attach_pid%d&quot;, os::current_process_id());</span><br><span class="line">  int ret;</span><br><span class="line">  struct stat64 st;</span><br><span class="line">  RESTARTABLE(::stat64(fn, &amp;st), ret);</span><br><span class="line">  if (ret == -1) &#123;</span><br><span class="line">    log_trace(attach)(&quot;Failed to find attach file: %s, trying alternate&quot;, fn);</span><br><span class="line">    snprintf(fn, sizeof(fn), &quot;%s/.attach_pid%d&quot;, os::get_temp_directory(), os::current_process_id());</span><br><span class="line">    RESTARTABLE(::stat64(fn, &amp;st), ret);</span><br><span class="line">  &#125;</span><br><span class="line">  if (ret == 0) &#123;</span><br><span class="line">    // simple check to avoid starting the attach mechanism when</span><br><span class="line">    // a bogus user creates the file</span><br><span class="line">    if (st.st_uid == geteuid()) &#123;</span><br><span class="line">      init();</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查了一下是否在 JVM 启动时启动了 Attach Listener，或者是否已经启动过。如果没有，才继续执行，在/tmp 目录下创建一个叫做.attach_pid%d 的文件，然后执行 AttachListener 的 init 函数，这个函数就是用来创建 Attach Listener 线程的函数，上面已经提到多次并进行了分析。到此，我们知道 Attach 机制的奥秘所在，也就是 Attach Listener 线程的创建依靠 Signal Dispatcher 线程，Signal Dispatcher 是用来处理信号的线程，当 Signal Dispatcher 线程接收到“SIGBREAK”信号之后，就会执行初始化 Attach Listener 的工作。</p><h6 id="2-3-2-运行时加载-Agent-的实现"><a href="#2-3-2-运行时加载-Agent-的实现" class="headerlink" title="2.3.2 运行时加载 Agent 的实现"></a>2.3.2 运行时加载 Agent 的实现</h6><p>我们继续分析，到底是如何将一个 Agent 挂载到运行着的目标 JVM 上，在上文中提到了一段代码，用来进行运行时挂载 Agent，可以参考上文中展示的关于“attachAgentToTargetJvm”方法的代码。这个方法里面的关键是调用 VirtualMachine 的 attach 方法进行 Agent 挂载的功能。下面我们就来分析一下 VirtualMachine 的 attach 方法具体是怎么实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static VirtualMachine attach(String var0) throws AttachNotSupportedException, IOException &#123;</span><br><span class="line">    if (var0 == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;id cannot be null&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        List var1 = AttachProvider.providers();</span><br><span class="line">        if (var1.size() == 0) &#123;</span><br><span class="line">            throw new AttachNotSupportedException(&quot;no providers installed&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AttachNotSupportedException var2 = null;</span><br><span class="line">            Iterator var3 = var1.iterator();</span><br><span class="line">            while(var3.hasNext()) &#123;</span><br><span class="line">                AttachProvider var4 = (AttachProvider)var3.next();</span><br><span class="line">                try &#123;</span><br><span class="line">                    return var4.attachVirtualMachine(var0);</span><br><span class="line">                &#125; catch (AttachNotSupportedException var6) &#123;</span><br><span class="line">                    var2 = var6;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法通过 attachVirtualMachine 方法进行 attach 操作，在 MacOS 系统中，AttachProvider 的实现类是 BsdAttachProvider。我们来看一下 BsdAttachProvider 的 attachVirtualMachine 方法是如何实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public VirtualMachine attachVirtualMachine(String var1) throws AttachNotSupportedException, IOException &#123;</span><br><span class="line">        this.checkAttachPermission();</span><br><span class="line">        this.testAttachable(var1);</span><br><span class="line">        return new BsdVirtualMachine(this, var1);</span><br><span class="line">    &#125;</span><br><span class="line">BsdVirtualMachine(AttachProvider var1, String var2) throws AttachNotSupportedException, IOException &#123;</span><br><span class="line">        int var3 = Integer.parseInt(var2);</span><br><span class="line">        this.path = this.findSocketFile(var3);</span><br><span class="line">        if (this.path == null) &#123;</span><br><span class="line">            File var4 = new File(tmpdir, &quot;.attach_pid&quot; + var3);</span><br><span class="line">            createAttachFile(var4.getPath());</span><br><span class="line">            try &#123;</span><br><span class="line">                sendQuitTo(var3);</span><br><span class="line">                int var5 = 0;</span><br><span class="line">                long var6 = 200L;</span><br><span class="line">                int var8 = (int)(this.attachTimeout() / var6);</span><br><span class="line">                do &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(var6);</span><br><span class="line">                    &#125; catch (InterruptedException var21) &#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.path = this.findSocketFile(var3);</span><br><span class="line">                    ++var5;</span><br><span class="line">                &#125; while(var5 &lt;= var8 &amp;&amp; this.path == null);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                var4.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int var24 = socket();</span><br><span class="line">        connect(var24, this.path);</span><br><span class="line">    &#125;</span><br><span class="line">    private String findSocketFile(int var1) &#123;</span><br><span class="line">        String var2 = &quot;.java_pid&quot; + var1;</span><br><span class="line">        File var3 = new File(tmpdir, var2);</span><br><span class="line">        return var3.exists() ? var3.getPath() : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>findSocketFile 方法用来查询目标 JVM 上是否已经启动了 Attach Listener，它通过检查”tmp/“目录下是否存在 java_pid{pid}来进行实现。如果已经存在了，则说明 Attach 机制已经准备就绪，可以接受客户端的命令了，这个时候客户端就可以通过 connect 连接到目标 JVM 进行命令的发送，比如可以发送“load”命令来加载 Agent。如果 java_pid{pid}文件还不存在，则需要通过 sendQuitTo 方法向目标 JVM 发送一个“SIGBREAK”信号，让它初始化 Attach Listener 线程并准备接受客户端连接。可以看到，发送了信号之后客户端会循环等待 java_pid{pid}这个文件，之后再通过 connect 连接到目标 JVM 上。</p><h6 id="2-3-3-load-命令的实现"><a href="#2-3-3-load-命令的实现" class="headerlink" title="2.3.3 load 命令的实现"></a>2.3.3 load 命令的实现</h6><p>下面来分析一下，“load”命令在 JVM 层面的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static jint load_agent(AttachOperation* op, outputStream* out) &#123;</span><br><span class="line">  // get agent name and options</span><br><span class="line">  const char* agent = op-&gt;arg(0);</span><br><span class="line">  const char* absParam = op-&gt;arg(1);</span><br><span class="line">  const char* options = op-&gt;arg(2);</span><br><span class="line">  // If loading a java agent then need to ensure that the java.instrument module is loaded</span><br><span class="line">  if (strcmp(agent, &quot;instrument&quot;) == 0) &#123;</span><br><span class="line">    Thread* THREAD = Thread::current();</span><br><span class="line">    ResourceMark rm(THREAD);</span><br><span class="line">    HandleMark hm(THREAD);</span><br><span class="line">    JavaValue result(T_OBJECT);</span><br><span class="line">    Handle h_module_name = java_lang_String::create_from_str(&quot;java.instrument&quot;, THREAD);</span><br><span class="line">    JavaCalls::call_static(&amp;result,SystemDictionary::module_Modules_klass(),vmSymbols::loadModule_name(),</span><br><span class="line">                           vmSymbols::loadModule_signature(),h_module_name,THREAD);</span><br><span class="line">  &#125;</span><br><span class="line">  return JvmtiExport::load_agent_library(agent, absParam, options, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数先确保加载了 java.instrument 模块，之后真正执行 Agent 加载的函数是 load_agent_library ,这个函数的套路就是加载 Agent 动态链接库，如果是通过 Java instrument API 实现的 Agent，则加载的是 libinstrument 动态链接库，然后通过 libinstrument 里面的代码实现运行 agentmain 方法的逻辑，这一部分内容和 libinstrument 实现 premain 方法运行的逻辑其实差不多，这里不再做分析。至此，我们对 Java Agent 技术已经有了一个全面而细致的了解。</p><h4 id="3-动态替换类字节码技术"><a href="#3-动态替换类字节码技术" class="headerlink" title="3. 动态替换类字节码技术"></a>3. 动态替换类字节码技术</h4><h5 id="3-1-动态字节码修改的限制"><a href="#3-1-动态字节码修改的限制" class="headerlink" title="3.1 动态字节码修改的限制"></a>3.1 动态字节码修改的限制</h5><p>上文中已经详细分析了 Agent 技术的实现，我们使用 Java Instrumentation API 来完成动态类修改的功能，在 Instrumentation 接口中，通过 addTransformer 方法来增加一个类转换器，类转换器由类 ClassFileTransformer 接口实现。ClassFileTransformer 接口中唯一的方法 transform 用于实现类转换，当类被加载的时候，就会调用 transform 方法，进行类转换。在运行时，我们可以通过 Instrumentation 的 redefineClasses 方法进行类重定义，在方法上有一段注释需要特别注意：</p><ul><li>The redefinition may change method bodies, the constant pool and attributes.</li><li>The redefinition must not add, remove or rename fields or methods, change the</li><li>signatures of methods, or change inheritance. These restrictions maybe be</li><li>lifted in future versions. The class file bytes are not checked, verified and installed</li><li>until after the transformations have been applied, if the resultant bytes are in</li><li>error this method will throw an exception.<br>这里面提到，我们不可以增加、删除或者重命名字段和方法，改变方法的签名或者类的继承关系。认识到这一点很重要，当我们通过 ASM 获取到增强的字节码之后，如果增强后的字节码没有遵守这些规则，那么调用 redefineClasses 方法来进行类的重定义就会失败。那 redefineClasses 方法具体是怎么实现类的重定义的呢？它对运行时的 JVM 会造成什么样的影响呢？下面来分析 redefineClasses 的实现细节。</li></ul><h5 id="3-2-重定义类字节码的实现细节"><a href="#3-2-重定义类字节码的实现细节" class="headerlink" title="3.2 重定义类字节码的实现细节"></a>3.2 重定义类字节码的实现细节</h5><p>上文中我们提到，libinstrument 动态链接库中，JPLISAgent 不仅实现了 Agent 入口代码执行的路由，而且还是 Java 代码与 JVMTI 之间的一道桥梁。我们在 Java 代码中调用 Java Instrumentation API 的 redefineClasses，其实会调用 libinstrument 中的相关代码，我们来分析一下这条路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void redefineClasses(ClassDefinition... var1) throws ClassNotFoundException &#123;</span><br><span class="line">    if (!this.isRedefineClassesSupported()) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;redefineClasses is not supported in this environment&quot;);</span><br><span class="line">    &#125; else if (var1 == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;null passed as &#x27;definitions&#x27; in redefineClasses&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for(int var2 = 0; var2 &lt; var1.length; ++var2) &#123;</span><br><span class="line">            if (var1[var2] == null) &#123;</span><br><span class="line">                throw new NullPointerException(&quot;element of &#x27;definitions&#x27; is null in redefineClasses&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (var1.length != 0) &#123;</span><br><span class="line">            this.redefineClasses0(this.mNativeAgent, var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private native void redefineClasses0(long var1, ClassDefinition[] var3) throws ClassNotFoundException;</span><br></pre></td></tr></table></figure><p>这是 InstrumentationImpl 中的 redefineClasses 实现，该方法的具体实现依赖一个 Native 方法 redefineClasses()，我们可以在 libinstrument 中找到这个 Native 方法的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_sun_instrument_InstrumentationImpl_redefineClasses0</span><br><span class="line">  (JNIEnv * jnienv, jobject implThis, jlong agent, jobjectArray classDefinitions) &#123;</span><br><span class="line">    redefineClasses(jnienv, (JPLISAgent*)(intptr_t)agent, classDefinitions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redefineClasses 这个函数的实现比较复杂，代码很长。下面是一段关键的代码片段：</p><p>可以看到，其实是调用了 JVMTI 的 RetransformClasses 函数来完成类的重定义细节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// class_count - pre-checked to be greater than or equal to 0</span><br><span class="line">// class_definitions - pre-checked for NULL</span><br><span class="line">jvmtiError JvmtiEnv::RedefineClasses(jint class_count, const jvmtiClassDefinition* class_definitions) &#123;</span><br><span class="line">//TODO: add locking</span><br><span class="line">  VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);</span><br><span class="line">  VMThread::execute(&amp;op);</span><br><span class="line">  return (op.check_error());</span><br><span class="line">&#125; /* end RedefineClasses */</span><br></pre></td></tr></table></figure><p>重定义类的请求会被 JVM 包装成一个 VM_RedefineClasses 类型的 VM_Operation，VM_Operation 是 JVM 内部的一些操作的基类，包括 GC 操作等。VM_Operation 由 VMThread 来执行，新的 VM_Operation 操作会被添加到 VMThread 的运行队列中去，VMThread 会不断从队列里面拉取 VM_Operation 并调用其 doit 等函数执行具体的操作。VM_RedefineClasses 函数的流程较为复杂，下面是 VM_RedefineClasses 的大致流程：</p><p>加载新的字节码，合并常量池，并且对新的字节码进行校验工作<br>// Load the caller’s new class definition(s) into _scratch_classes.<br>// Constant pool merging work is done here as needed. Also calls<br>// compare_and_normalize_class_versions() to verify the class<br>// definition(s).<br>jvmtiError load_new_class_versions(TRAPS);<br>清除方法上的断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  // Remove all breakpoints in methods of this class</span><br><span class="line">  JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();</span><br><span class="line">  jvmti_breakpoints.clearall_in_class_at_safepoint(the_class());</span><br><span class="line">JIT逆优化</span><br><span class="line"></span><br><span class="line">  // Deoptimize all compiled code that depends on this class</span><br><span class="line">  flush_dependent_code(the_class, THREAD);</span><br></pre></td></tr></table></figure><p>进行字节码替换工作，需要进行更新类 itable/vtable 等操作<br>进行类重定义通知</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SystemDictionary::notice_modification();</span><br></pre></td></tr></table></figure><p>VM_RedefineClasses 实现比较复杂的，详细实现可以参考 RedefineClasses 的实现。</p><h4 id="4-Java-debug-tool-设计与实现"><a href="#4-Java-debug-tool-设计与实现" class="headerlink" title="4. Java-debug-tool 设计与实现"></a>4. Java-debug-tool 设计与实现</h4><p>Java-debug-tool 是一个使用 Java Instrument API 来实现的动态调试工具，它通过在目标 JVM 上启动一个 TcpServer 来和调试客户端通信。<br>调试客户端通过命令行来发送调试命令给 TcpServer，TcpServer 中有专门用来处理命令的 handler，handler 处理完命令之后会将结果发送回客户端，<br>客户端通过处理将调试结果展示出来。下面将详细介绍 Java-debug-tool 的整体设计和实现。</p><h5 id="4-1-Java-debug-tool-整体架构"><a href="#4-1-Java-debug-tool-整体架构" class="headerlink" title="4.1 Java-debug-tool 整体架构"></a>4.1 Java-debug-tool 整体架构</h5><p>Java-debug-tool 包括一个 Java Agent 和一个用于处理调试命令的核心 API，核心 API 通过一个自定义的类加载器加载进来，以保证目标 JVM 的类不会被污染。<br>整体上 Java-debug-tool 的设计是一个 Client-Server 的架构，命令客户端需要完整的完成一个命令之后才能继续执行下一个调试命令。<br>Java-debug-tool 支持多人同时进行调试，下面是整体架构图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXwHv2oFu6vZbZ2VriafkoE44pMzDfgj8Oe9fFbU2wHn35PjibaPxvOnFMmwx1Jzv9Tsy1kxn41Q7NQ/640"></p><p>下面对每一层做简单介绍：</p><ul><li><p>交互层：负责将程序员的输入转换成调试交互协议，并且将调试信息呈现出来。</p></li><li><p>连接管理层：负责管理客户端连接，从连接中读调试协议数据并解码，对调试结果编码并将其写到连接中去；同时将那些超时未活动的连接关闭。</p></li><li><p>业务逻辑层：实现调试命令处理，包括命令分发、数据收集、数据处理等过程。</p></li><li><p>基础实现层：Java-debug-tool 实现的底层依赖，通过 Java Instrumentation 提供的 API 进行类查找、类重定义等能力，Java Instrumentation 底层依赖 JVMTI 来完成具体的功能。</p></li></ul><p>在 Agent 被挂载到目标 JVM 上之后，Java-debug-tool 会安排一个 Spy 在目标 JVM 内活动，这个 Spy 负责将目标 JVM 内部的相关调试数据转移到命令处理模块，<br>命令处理模块会处理这些数据，然后给客户端返回调试结果。命令处理模块会增强目标类的字节码来达到数据获取的目的<br>，多个客户端可以共享一份增强过的字节码，无需重复增强。下面从 Java-debug-tool 的字节码增强方案、命令设计与实现等角度详细说明。</p><h5 id="4-2-Java-debug-tool-的字节码增强方案"><a href="#4-2-Java-debug-tool-的字节码增强方案" class="headerlink" title="4.2 Java-debug-tool 的字节码增强方案"></a>4.2 Java-debug-tool 的字节码增强方案</h5><p>Java-debug-tool 使用字节码增强来获取到方法运行时的信息，比如方法入参、出参等，可以在不同的字节码位置进行增强，这种行为可以称为“插桩”，<br>每个“桩”用于获取数据并将他转储出去。Java-debug-tool 具备强大的插桩能力，不同的桩负责获取不同类别的数据，下面是 Java-debug-tool 目前所支持的“桩”：</p><ul><li><p>方法进入点：用于获取方法入参信息。</p></li><li><p>Fields 获取点 1：在方法执行前获取到对象的字段信息。</p></li><li><p>变量存储点：获取局部变量信息。</p></li><li><p>Fields 获取点 2：在方法退出前获取到对象的字段信息。</p></li><li><p>方法退出点：用于获取方法返回值。</p></li><li><p>抛出异常点：用于获取方法抛出的异常信息。</p></li></ul><p>通过上面这些代码桩，Java-debug-tool 可以收集到丰富的方法执行信息，经过处理可以返回更加可视化的调试结果。</p><h6 id="4-2-1-字节码增强"><a href="#4-2-1-字节码增强" class="headerlink" title="4.2.1 字节码增强"></a>4.2.1 字节码增强</h6><p>Java-debug-tool 在实现上使用了 ASM 工具来进行字节码增强，并且每个插桩点都可以进行配置，如果不想要什么信息，则没必要进行对应的插桩操作。这种可配置的设计是非常有必要的，因为有时候我们仅仅是想要知道方法的入参和出参，但 Java-debug-tool 却给我们返回了所有的调试信息，这样我们就得在众多的输出中找到我们所关注的内容。如果可以进行配置，则除了入参点和出参点外其他的桩都不插，那么就可以快速看到我们想要的调试数据，这种设计的本质是为了让调试者更加专注。下面是 Java-debug-tool 的字节码增强工作方式：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXwHv2oFu6vZbZ2VriafkoE4jIYWODnoWDfEAhWyia6LIsKKwIkT5FEMxEzrFKTUV5WGdAEMmlno0hA/640"></p><p>图 4-2-1</p><p>如图 4-2-1 所示，当调试者发出调试命令之后，Java-debug-tool 会识别命令并判断是否需要进行字节码增强，如果命令需要增强字节码，则判断当前类+当前方法是否已经被增强过。上文已经提到，字节码替换是有一定损耗的，这种具有损耗的操作发生的次数越少越好，所以字节码替换操作会被记录起来，后续命令直接使用即可，不需要重复进行字节码增强，字节码增强还涉及多个调试客户端的协同工作问题，当一个客户端增强了一个类的字节码之后，这个客户端就锁定了该字节码，其他客户端变成只读，无法对该类进行字节码增强，只有当持有锁的客户端主动释放锁或者断开连接之后，其他客户端才能继续增强该类的字节码。<br>字节码增强模块收到字节码增强请求之后，会判断每个增强点是否需要插桩，这个判断的根据就是上文提到的插桩配置，之后字节码增强模块会生成新的字节码，Java-debug-tool 将执行字节码替换操作，之后就可以进行调试数据收集了。<br>经过字节码增强之后，原来的方法中会插入收集运行时数据的代码，这些代码在方法被调用的时候执行，获取到诸如方法入参、局部变量等信息，这些信息将传递给数据收集装置进行处理。数据收集的工作通过 Advice 完成，每个客户端同一时间只能注册一个 Advice 到 Java-debug-tool 调试模块上，多个客户端可以同时注册自己的 Advice 到调试模块上。Advice 负责收集数据并进行判断，如果当前数据符合调试命令的要求，Java-debug-tool 就会卸载这个 Advice，Advice 的数据就会被转移到 Java-debug-tool 的命令结果处理模块进行处理，并将结果发送到客户端。</p><h6 id="4-2-2-Advice-的工作方式"><a href="#4-2-2-Advice-的工作方式" class="headerlink" title="4.2.2 Advice 的工作方式"></a>4.2.2 Advice 的工作方式</h6><p>Advice 是调试数据收集器，不同的调试策略会对应不同的 Advice。Advice 是工作在目标 JVM 的线程内部的，它需要轻量级和高效，意味着 Advice 不能做太过于复杂的事情，它的核心接口“match”用来判断本次收集到的调试数据是否满足调试需求。如果满足，那么 Java-debug-tool 就会将其卸载，否则会继续让他收集调试数据，这种“加载 Advice” -&gt; “卸载 Advice”的工作模式具备很好的灵活性。<br>关于 Advice，需要说明的另外一点就是线程安全，因为它加载之后会运行在目标 JVM 的线程中，目标 JVM 的方法极有可能是多线程访问的，这也就是说，Advice 需要有能力处理多个线程同时访问方法的能力，如果 Advice 处理不当，则可能会收集到杂乱无章的调试数据。下面的图片展示了 Advice 和 Java-debug-tool 调试分析模块、目标方法执行以及调试客户端等模块的关系。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXwHv2oFu6vZbZ2VriafkoE4icUzSicIdgKaWyBsIVgmiaOHEPR5mUvyqDOg3e6ELs0aFF1Ub23RjnNsQ/640"><br>图 4-2-2<br>Advice 的首次挂载由 Java-debug-tool 的命令处理器完成，当一次调试数据收集完成之后，调试数据处理模块会自动卸载 Advice，然后进行判断，如果调试数据符合 Advice 的策略，则直接将数据交由数据处理模块进行处理，否则会清空调试数据，并再次将 Advice 挂载到目标方法上去，等待下一次调试数据。非首次挂载由调试数据处理模块进行，它借助 Advice 按需取数据，如果不符合需求，则继续挂载 Advice 来获取数据，否则对调试数据进行处理并返回给客户端。</p><h5 id="4-3-Java-debug-tool-的命令设计与实现"><a href="#4-3-Java-debug-tool-的命令设计与实现" class="headerlink" title="4.3 Java-debug-tool 的命令设计与实现"></a>4.3 Java-debug-tool 的命令设计与实现</h5><h6 id="4-3-1-命令执行"><a href="#4-3-1-命令执行" class="headerlink" title="4.3.1 命令执行"></a>4.3.1 命令执行</h6><p>上文已经完整的描述了 Java-debug-tool 的设计以及核心技术方案，本小节将详细介绍 Java-debug-tool 的命令设计与实现。首先需要将一个调试命令的执行流程描述清楚，下面是一张用来表示命令请求处理流程的图片：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXwHv2oFu6vZbZ2VriafkoE4NAFPL7rkntPMiaicJtbn84MnRNibQkPhUibZ5cuWpZpcibYxx0vR41PHNDw/640"><br>图 4-3-1<br>图 4-3-1 简单的描述了 Java-debug-tool 的命令处理方式，客户端连接到服务端之后，会进行一些协议解析、协议认证、协议填充等工作，之后将进行命令分发。服务端如果发现客户端的命令不合法，则会立即返回错误信息，否则再进行命令处理。命令处理属于典型的三段式处理，前置命令处理、命令处理以及后置命令处理，同时会对命令处理过程中的异常信息进行捕获处理，三段式处理的好处是命令处理被拆成了多个阶段，多个阶段负责不同的职责。前置命令处理用来做一些命令权限控制的工作，并填充一些类似命令处理开始时间戳等信息，命令处理就是通过字节码增强，挂载 Advice 进行数据收集，再经过数据处理来产生命令结果的过程，后置处理则用来处理一些连接关闭、字节码解锁等事项。<br>Java-debug-tool 允许客户端设置一个命令执行超时时间，超过这个时间则认为命令没有结果，如果客户端没有设置自己的超时时间，就使用默认的超时时间进行超时控制。Java-debug-tool 通过设计了两阶段的超时检测机制来实现命令执行超时功能：首先，第一阶段超时触发，则 Java-debug-tool 会友好的警告命令处理模块处理时间已经超时，需要立即停止命令执行，这允许命令自己做一些现场清理工作，当然需要命令执行线程自己感知到这种超时警告；当第二阶段超时触发，则 Java-debug-tool 认为命令必须结束执行，会强行打断命令执行线程。超时机制的目的是为了不让命令执行太长时间，命令如果长时间没有收集到调试数据，则应该停止执行，并思考是否调试了一个错误的方法。当然，超时机制还可以定期清理那些因为未知原因断开连接的客户端持有的调试资源，比如字节码锁。</p><h6 id="4-3-4-获取方法执行视图"><a href="#4-3-4-获取方法执行视图" class="headerlink" title="4.3.4 获取方法执行视图"></a>4.3.4 获取方法执行视图</h6><p>Java-debug-tool 通过下面的信息来向调试者呈现出一次方法执行的视图：<br>正在调试的方法信息。</p><p>方法调用堆栈。</p><p>调试耗时，包括对目标 JVM 造成的 STW 时间。</p><p>方法入参，包括入参的类型及参数值。</p><p>方法的执行路径。</p><p>代码执行耗时。</p><p>局部变量信息。</p><p>方法返回结果。</p><p>方法抛出的异常。</p><p>对象字段值快照。</p><p>图 4-3-2 展示了 Java-debug-tool 获取到正在运行的方法的执行视图的信息。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXwHv2oFu6vZbZ2VriafkoE4TYKGnNuqCgHOSkZiabggzJUESbqSDMWRZM1OtVNGziasnSAiae7ibYicAKw/640?wx_fmt=png"></p><p>图 4-3-2</p><h5 id="4-4-Java-debug-tool-与同类产品对比分析"><a href="#4-4-Java-debug-tool-与同类产品对比分析" class="headerlink" title="4.4 Java-debug-tool 与同类产品对比分析"></a>4.4 Java-debug-tool 与同类产品对比分析</h5><p>Java-debug-tool 的同类产品主要是 greys，其他类似的工具大部分都是基于 greys 进行的二次开发，所以直接选择 greys 来和 Java-debug-tool 进行对比。</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>本文详细剖析了 Java 动态调试关键技术的实现细节，并介绍了我们基于 Java 动态调试技术结合实际故障排查场景进行的一点探索实践；动态调试技术为研发人员进行线上问题排查提供了一种新的思路，我们基于动态调试技术解决了传统断点调试存在的问题，使得可以将断点调试这种技术应用在线上，以线下调试的思维来进行线上调试，提高问题排查效率。</p><h4 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h4><p>ASM 4 guide</p><p>Java Virtual Machine Specification</p><p>JVM Tool Interface</p><p>alibaba arthas</p><p>openjdk</p><h4 id="摘自"><a href="#摘自" class="headerlink" title="摘自"></a>摘自</h4><p><a href="https://mp.weixin.qq.com/s/ZlNcvwJ_swspifWTLHA92Q">https://mp.weixin.qq.com/s/ZlNcvwJ_swspifWTLHA92Q</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Java动态调试技术原理及实践&quot;&gt;&lt;a href=&quot;#Java动态调试技术原理及实践&quot; class=&quot;headerlink&quot; title=&quot;Java动态调试技术原理及实践&quot;&gt;&lt;/a&gt;Java动态调试技术原理及实践&lt;/h3&gt;&lt;h4 id=&quot;1-动态调试要解决的问题&quot;</summary>
      
    
    
    
    <category term="java" scheme="https://wuhaocn.github.io/categories/java/"/>
    
    
    <category term="动态调试技术" scheme="https://wuhaocn.github.io/tags/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/sort/7.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/sort/7.%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-01T13:12:11.456Z</published>
    <updated>2021-10-01T13:12:11.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.coral.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 1.找出待排序的数组中最大和最小的元素；</span></span><br><span class="line"><span class="comment"> 2.统计数组中每个值为i的元素出现的次数,存入数组C的第i项；</span></span><br><span class="line"><span class="comment"> 3.对所有的计数累加(从C中的第一个元素开始,每一项和前一项相加）；</span></span><br><span class="line"><span class="comment"> 4.反向填充目标数组:将每个元素i放在新数组的第C(i)项,每放一个元素就将C(i)减去1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">78</span>&#125;;</span><br><span class="line">        CountSort countSort = <span class="keyword">new</span> CountSort();</span><br><span class="line">        countSort.print(numbers);</span><br><span class="line">        countSort.sort(numbers);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出数组中的最大最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            max = Math.max(max, numbers[i]);</span><br><span class="line">            min = Math.min(min, numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mapPos = numbers[i] - min;</span><br><span class="line">            help[mapPos]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算每个数字应该在排序后数组中应该处于的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">            help[i] = help[i-<span class="number">1</span>] + help[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据help数组进行排序</span></span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[numbers.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> post = --help[numbers[i] - min];</span><br><span class="line">            res[post] = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;计数排序&quot;&gt;&lt;a href=&quot;#计数排序&quot; class=&quot;headerlink&quot; title=&quot;计数排序&quot;&gt;&lt;/a&gt;计数排序&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="algorithm" scheme="https://wuhaocn.github.io/categories/algorithm/"/>
    
    
    <category term="sort" scheme="https://wuhaocn.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>桶排序</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/sort/8-%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/sort/8-%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-01T13:12:11.456Z</published>
    <updated>2021-10-01T13:12:11.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p><a href="https://github.com/coral-learning/algorithm-example/tree/master/base/guide/src/main/java/com.coral.learning.alg/udemo/algorithms/sort">详细参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  桶排序</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> 桶排序的基本思想是： 把数组 arr 划分为 n 个大小相同子区间（桶），每个子区间各自排序，最</span></span><br><span class="line"><span class="comment"> 后合并 。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</span></span><br><span class="line"><span class="comment"> 1.找出待排序数组中的最大值 max、最小值 min</span></span><br><span class="line"><span class="comment"> 2.我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max</span></span><br><span class="line"><span class="comment"> min)/arr.length+1</span></span><br><span class="line"><span class="comment"> 3.遍历数组 arr，计算每个元素 arr[i] 放的桶</span></span><br><span class="line"><span class="comment"> 4.每个桶各自排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">78</span>&#125;;</span><br><span class="line">        BucketSort bucketSort = <span class="keyword">new</span> BucketSort();</span><br><span class="line">        System.out.println(<span class="string">&quot;BucketSort&quot;</span>);</span><br><span class="line">        bucketSort.sort(numbers);</span><br><span class="line">        bucketSort.print(numbers);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建桶</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将每个元素放入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">            bucketArr.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;桶排序&quot;&gt;&lt;a href=&quot;#桶排序&quot; class=&quot;headerlink&quot; title=&quot;桶排序&quot;&gt;&lt;/a&gt;桶排序&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/coral-learning/algorithm-example/tree/</summary>
      
    
    
    
    <category term="algorithm" scheme="https://wuhaocn.github.io/categories/algorithm/"/>
    
    
    <category term="sort" scheme="https://wuhaocn.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/sort/9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/sort/9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-01T13:12:11.456Z</published>
    <updated>2021-10-01T13:12:11.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><a href="https://github.com/coral-learning/algorithm-example/tree/master/base/guide/src/main/java/com.coral.learning.alg/udemo/algorithms/sort">详细参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位</span></span><br><span class="line"><span class="comment"> * 开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序</span></span><br><span class="line"><span class="comment"> * 列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">78</span>&#125;;</span><br><span class="line">        RadixSort radixSort = <span class="keyword">new</span> RadixSort();</span><br><span class="line">        System.out.println(<span class="string">&quot;RadixSort&quot;</span>);</span><br><span class="line">        radixSort.sort(numbers);</span><br><span class="line">        radixSort.print(numbers);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先确定排序的趟数;</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断位数;</span></span><br><span class="line">        <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立 10 个队列;</span></span><br><span class="line">        List&lt;ArrayList&gt; queue = <span class="keyword">new</span> ArrayList&lt;ArrayList&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; queue1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            queue.add(queue1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行 time 次分配和收集;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">            <span class="comment">//分配数组元素;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="comment">//得到数字的第 time+1 位数;</span></span><br><span class="line">                <span class="keyword">int</span> x = array[j] % (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i + <span class="number">1</span>) / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i);</span><br><span class="line">                ArrayList&lt;Integer&gt; queue2 = queue.get(x);</span><br><span class="line">                queue2.add(array[j]);</span><br><span class="line">                queue.set(x, queue2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//元素计数器;</span></span><br><span class="line">            <span class="comment">//收集队列元素;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.get(k).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; queue3 = queue.get(k);</span><br><span class="line">                    array[count] = queue3.get(<span class="number">0</span>);</span><br><span class="line">                    queue3.remove(<span class="number">0</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/coral-learning/algorithm-example/t</summary>
      
    
    
    
    <category term="algorithm" scheme="https://wuhaocn.github.io/categories/algorithm/"/>
    
    
    <category term="sort" scheme="https://wuhaocn.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>归并（Merge）排序</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/sort/4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/sort/4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-01T13:12:11.455Z</published>
    <updated>2021-10-01T13:12:11.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="归并（Merge）排序"><a href="#归并（Merge）排序" class="headerlink" title="归并（Merge）排序"></a>归并（Merge）排序</h3><p><a href="https://github.com/coral-learning/algorithm-example/tree/master/base/guide/src/main/java/com.coral.learning.alg/udemo/algorithms/sort">详细参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并（Merge）排序</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序</span></span><br><span class="line"><span class="comment"> 分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">78</span>&#125;;</span><br><span class="line">        MergeSort mergeSort = <span class="keyword">new</span> MergeSort();</span><br><span class="line">        System.out.println(<span class="string">&quot;MergeSort&quot;</span>);</span><br><span class="line">        mergeSort.sort(numbers);</span><br><span class="line">        mergeSort.print(numbers);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 找出中间索引</span></span><br><span class="line">        <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对左边数组进行递归</span></span><br><span class="line">        sort(data, left, center);</span><br><span class="line">        <span class="comment">// 对右边数组进行递归</span></span><br><span class="line">        sort(data, center + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        merge(data, left, center, right);</span><br><span class="line">        print(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将两个数组进行归并，归并前面 2 个数组已有序，归并后依然有序13/04/2018 Page 239 of 283</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   数组对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   左数组的第一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> center 左数组的最后一个元素的索引， center+1 是右数组第一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  右数组最后一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> center, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] tmpArr = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line">        <span class="comment">// 右数组第一个元素索引</span></span><br><span class="line">        <span class="keyword">int</span> mid = center + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// third 记录临时数组的索引</span></span><br><span class="line">        <span class="keyword">int</span> third = left;</span><br><span class="line">        <span class="comment">// 缓存左数组第一个元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> tmp = left;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= center &amp;&amp; mid &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 从两个数组中取出最小的放入临时数组</span></span><br><span class="line">            <span class="keyword">if</span> (data[left] &lt;= data[mid]) &#123;</span><br><span class="line">                tmpArr[third++] = data[left++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpArr[third++] = data[mid++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余部分依次放入临时数组（实际上两个 while 只会执行其中一个）</span></span><br><span class="line">        <span class="keyword">while</span> (mid &lt;= right) &#123;</span><br><span class="line">            tmpArr[third++] = data[mid++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= center) &#123;</span><br><span class="line">            tmpArr[third++] = data[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将临时数组中的内容拷贝回原数组中</span></span><br><span class="line">        <span class="comment">// （原 left-right 范围的内容被复制回原数组）</span></span><br><span class="line">        <span class="keyword">while</span> (tmp &lt;= right) &#123;</span><br><span class="line">            data[tmp] = tmpArr[tmp++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;归并（Merge）排序&quot;&gt;&lt;a href=&quot;#归并（Merge）排序&quot; class=&quot;headerlink&quot; title=&quot;归并（Merge）排序&quot;&gt;&lt;/a&gt;归并（Merge）排序&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/coral-</summary>
      
    
    
    
    <category term="algorithm" scheme="https://wuhaocn.github.io/categories/algorithm/"/>
    
    
    <category term="sort" scheme="https://wuhaocn.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/sort/5-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/sort/5-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-01T13:12:11.455Z</published>
    <updated>2021-10-01T13:12:11.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><a href="https://github.com/coral-learning/algorithm-example/tree/master/base/guide/src/main/java/com.coral.learning.alg/udemo/algorithms/sort">详细参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列</span></span><br><span class="line"><span class="comment"> * 中的记录“基本有序” 时，再对全体记录进行依次直接插入排序。</span></span><br><span class="line"><span class="comment"> * 1. 操作方法：</span></span><br><span class="line"><span class="comment"> * 选择一个增量序列 t1， t2， …， tk，其中 ti&gt;tj， tk=1；</span></span><br><span class="line"><span class="comment"> * 2. 按增量序列个数 k，对序列进行 k 趟排序；</span></span><br><span class="line"><span class="comment"> * 3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进</span></span><br><span class="line"><span class="comment"> * 行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长</span></span><br><span class="line"><span class="comment"> * 度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">78</span>&#125;;</span><br><span class="line">        ShellSort shellSort = <span class="keyword">new</span> ShellSort();</span><br><span class="line">        System.out.println(<span class="string">&quot;ShellSort&quot;</span>);</span><br><span class="line">        shellSort.sort(numbers);</span><br><span class="line">        shellSort.print(numbers);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dk = arr.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (dk &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ShellInsertSort(arr, dk);</span><br><span class="line">            dk = dk / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShellInsertSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = dk; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i - dk]) &#123;</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">int</span> x = a[i];<span class="comment">//x 为待插入元素</span></span><br><span class="line">                a[i] = a[i - dk];</span><br><span class="line">                <span class="keyword">for</span> (j = i - dk; j &gt;= <span class="number">0</span> &amp;&amp; x &lt; a[j]; j = j - dk) &#123;</span><br><span class="line">                    <span class="comment">//通过循环，逐个后移一位找到要插入的位置。</span></span><br><span class="line">                    a[j + dk] = a[j];</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + dk] = x;<span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/coral-learning/algorithm-example/t</summary>
      
    
    
    
    <category term="algorithm" scheme="https://wuhaocn.github.io/categories/algorithm/"/>
    
    
    <category term="sort" scheme="https://wuhaocn.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/sort/6-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/sort/6-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-01T13:12:11.455Z</published>
    <updated>2021-10-01T13:12:11.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><a href="https://github.com/coral-learning/algorithm-example/tree/master/base/guide/src/main/java/com.coral.learning.alg/udemo/algorithms/sort">详细参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。</span></span><br><span class="line"><span class="comment"> * 可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。</span></span><br><span class="line"><span class="comment"> * 大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。</span></span><br><span class="line"><span class="comment"> * 在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶</span></span><br><span class="line"><span class="comment"> * 定义</span></span><br><span class="line"><span class="comment"> * n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）：</span></span><br><span class="line"><span class="comment"> * (1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号(2)ki&gt;=k(2i）且ki&gt;=k(2i+1)(1≤i≤ n/2）。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点</span></span><br><span class="line"><span class="comment"> * 若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：</span></span><br><span class="line"><span class="comment"> * 树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</span></span><br><span class="line"><span class="comment"> * 【例】关键字序列（10，15，56，25，30，70）和（70，56，30，25，15，10）分别满足堆性质（1）和（2），故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。</span></span><br><span class="line"><span class="comment"> * 大根堆和小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。</span></span><br><span class="line"><span class="comment"> * 根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。</span></span><br><span class="line"><span class="comment"> * 堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。</span></span><br><span class="line"><span class="comment"> * 平均性能</span></span><br><span class="line"><span class="comment"> * O(N*logN)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （2）大根堆排序算法的基本操作：</span></span><br><span class="line"><span class="comment"> ①建堆，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。</span></span><br><span class="line"><span class="comment">    建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。</span></span><br><span class="line"><span class="comment"> ②调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，</span></span><br><span class="line"><span class="comment">    选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。</span></span><br><span class="line"><span class="comment">    调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。</span></span><br><span class="line"><span class="comment"> ③堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。</span></span><br><span class="line"><span class="comment">    然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是O(nlgn)。</span></span><br><span class="line"><span class="comment">    因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是lgn，调用了n-1次，所以堆排序的时间复杂度是O(nlgn) [2]</span></span><br><span class="line"><span class="comment"> * 其他性能</span></span><br><span class="line"><span class="comment"> * 由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。</span></span><br><span class="line"><span class="comment"> * 堆排序是就地排序，辅助空间为O(1).</span></span><br><span class="line"><span class="comment"> * 它是不稳定的排序方法。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * 1.建立最大堆</span></span><br><span class="line"><span class="comment"> * 2.把最大堆元素移动至最后为有序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeapSort bubbleSort = <span class="keyword">new</span> HeapSort();</span><br><span class="line">        System.out.println(<span class="string">&quot;HeapSort&quot;</span>);</span><br><span class="line">        bubbleSort.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//step1.buildMaxHeapify</span></span><br><span class="line">        <span class="comment">//没有子节点的才需要创建最大堆，从最后一个的父节点开始</span></span><br><span class="line">        <span class="keyword">int</span> startIndex = getParentIndex(data.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//从尾端开始创建最大堆，每次都是正确的堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(data, data.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//---此时最大堆创建完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;printTree MaxTree Ok&quot;</span>);</span><br><span class="line">        <span class="comment">//step2.heapSort</span></span><br><span class="line">        <span class="comment">//末尾与头交换，交换后调整最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">            printTree(data);</span><br><span class="line">            swap(data, <span class="number">0</span>, i);</span><br><span class="line">            printTree(data);</span><br><span class="line">            maxHeapify(data, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printTree(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramdata</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramheapSize</span>需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramindex</span>当前需要创建最大堆的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前点与左右子节点比较</span></span><br><span class="line">        <span class="keyword">int</span> left = getChildLeftIndex(index);</span><br><span class="line">        <span class="keyword">int</span> right = getChildRightIndex(index);</span><br><span class="line">        System.out.print(<span class="string">&quot;index=&quot;</span> + index + <span class="string">&quot; left=&quot;</span> + left+<span class="string">&quot; right=&quot;</span> + right);</span><br><span class="line">        printTree(data);</span><br><span class="line">        <span class="keyword">int</span> largest = index;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整</span></span><br><span class="line">        <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line">            swap(data, largest, index);</span><br><span class="line">            maxHeapify(data, heapSize, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父节点位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramcurrent</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左子节点position注意括号，加法优先级更高</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramcurrent</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右子节点position</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramcurrent</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre &lt; (<span class="keyword">int</span>) getLog(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                pre = (<span class="keyword">int</span>) getLog(i + <span class="number">1</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(data[i] + <span class="string">&quot;|&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以2为底的对数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@paramparam</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getLog</span><span class="params">(<span class="keyword">double</span> param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.log(param) / Math.log(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/coral-learning/algorithm-example/tree/</summary>
      
    
    
    
    <category term="algorithm" scheme="https://wuhaocn.github.io/categories/algorithm/"/>
    
    
    <category term="sort" scheme="https://wuhaocn.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>人工智能算法</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/ai/ai/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/ai/ai/</id>
    <published>2021-10-01T13:12:11.454Z</published>
    <updated>2021-10-01T13:12:11.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-人工智能的三大基石"><a href="#1-人工智能的三大基石" class="headerlink" title="1.人工智能的三大基石"></a>1.人工智能的三大基石</h3><pre><code>算法、数据、计算能力</code></pre><h3 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h3><h4 id="2-1-学习算法"><a href="#2-1-学习算法" class="headerlink" title="2.1.学习算法"></a>2.1.学习算法</h4><p>按照模型训练方式可以分为四类：</p><ul><li>监督学习（Supervised Learning）</li><li>无监督学习（Unsupervised Learning）</li><li>半监督学习（Semi-supervised Learning）</li><li>强化学习（Reinforcement Learning）</li><li>深度学习(Deep Learning)</li></ul><h4 id="2-2-监督学习"><a href="#2-2-监督学习" class="headerlink" title="2.2.监督学习"></a>2.2.监督学习</h4><p>常见的监督学习算法包含以下几类：</p><h5 id="2-2-1-人工神经网络（Artificial-NeuralNetwork："><a href="#2-2-1-人工神经网络（Artificial-NeuralNetwork：" class="headerlink" title="2.2.1.人工神经网络（Artificial NeuralNetwork："></a>2.2.1.人工神经网络（Artificial NeuralNetwork：</h5><ul><li>反向传播（Backpropagation）</li><li>波尔兹曼机（Boltzmann Machine）</li><li>卷积神经网络（Convolutional Neural Network）</li><li>Hopfield 网络（hopfield Network）</li><li>多层感知器（Multilyer Perceptron）</li><li>径向基函数网络（Radial Basis Function Network，RBFN）</li><li>受限波尔兹曼机（Restricted Boltzmann Machine）</li><li>回归神经网络（Recurrent NeuralNetwork，RNN）</li><li>自组织映射（Self-organizing Map，SOM）</li><li>尖峰神经网络（Spiking Neural Network）</li></ul><h5 id="2-2-2-贝叶斯类（Bayesin）"><a href="#2-2-2-贝叶斯类（Bayesin）" class="headerlink" title="2.2.2.贝叶斯类（Bayesin）"></a>2.2.2.贝叶斯类（Bayesin）</h5><ul><li>朴素贝叶斯（Naive Bayes）</li><li>高斯贝叶斯（Gaussian Naive Bayes）</li><li>多项朴素贝叶斯（Multinomial Naive Bayes）</li><li>平均-依赖性评估（Averaged One-Dependence Estimators，AODE）</li><li>贝叶斯信念网络（Bayesian Belief Network，BBN）</li><li>贝叶斯网络（Bayesian Network，BN）</li></ul><h5 id="2-2-3-决策树（Decision-Tree）"><a href="#2-2-3-决策树（Decision-Tree）" class="headerlink" title="2.2.3.决策树（Decision Tree）"></a>2.2.3.决策树（Decision Tree）</h5><ul><li>分类和回归树（Classification and Regression Tree，CART）</li><li>迭代 Dichotomiser3（Iterative Dichotomiser 3， ID3）</li><li>C4.5 算法（C4.5 Algorithm）、C5.0 算法（C5.0 Algorithm）</li><li>卡方自动交互检测（Chi-squared Automatic Interaction Detection，CHAID）</li><li>决策残端（Decision Stump）</li><li>ID3 算法（ID3 Algorithm）</li><li>随机森林（Random Forest）</li><li>SLIQ（Supervised Learning in Quest）</li></ul><h5 id="2-2-4-线性分类器（Linear-Classifier）类："><a href="#2-2-4-线性分类器（Linear-Classifier）类：" class="headerlink" title="2.2.4.线性分类器（Linear Classifier）类："></a>2.2.4.线性分类器（Linear Classifier）类：</h5><ul><li>Fisher 的线性判别（Fisher’s Linear Discriminant）</li><li>线性回归（Linear Regression）</li><li>逻辑回归（Logistic Regression）</li><li>多项逻辑回归（Multionmial Logistic Regression）</li><li>朴素贝叶斯分类器（Naive Bayes Classifier）</li><li>感知（Perception）</li><li>支持向量机（Support Vector Machine）</li></ul><h4 id="2-3-无监督学习："><a href="#2-3-无监督学习：" class="headerlink" title="2.3.无监督学习："></a>2.3.无监督学习：</h4><h5 id="2-3-1-人工神经网络（Artificial-Neural-Network）"><a href="#2-3-1-人工神经网络（Artificial-Neural-Network）" class="headerlink" title="2.3.1.人工神经网络（Artificial Neural Network）"></a>2.3.1.人工神经网络（Artificial Neural Network）</h5><ul><li>生成对抗网络（Generative Adversarial Networks，GAN）</li><li>前馈神经网络（Feedforward Neural Network）</li><li>逻辑学习机（Logic Learning Machine）</li><li>自组织映射（Self-organizing Map）</li></ul><h5 id="2-3-2-关联规则学习（Association-Rule-Learning）"><a href="#2-3-2-关联规则学习（Association-Rule-Learning）" class="headerlink" title="2.3.2.关联规则学习（Association Rule Learning）"></a>2.3.2.关联规则学习（Association Rule Learning）</h5><ul><li>先验算法（Apriori Algorithm）</li><li>Eclat 算法（Eclat Algorithm）</li><li>FP-Growth</li></ul><h5 id="2-3-3-分层聚类算法（Hierarchical-Clustering）"><a href="#2-3-3-分层聚类算法（Hierarchical-Clustering）" class="headerlink" title="2.3.3.分层聚类算法（Hierarchical Clustering）"></a>2.3.3.分层聚类算法（Hierarchical Clustering）</h5><ul><li>单连锁聚类（Single-linkage Clustering）</li><li>概念聚类（Conceptual Clustering）</li></ul><h5 id="2-3-4-聚类分析（Cluster-analysis）"><a href="#2-3-4-聚类分析（Cluster-analysis）" class="headerlink" title="2.3.4.聚类分析（Cluster analysis）"></a>2.3.4.聚类分析（Cluster analysis）</h5><ul><li>BIRCH 算法</li><li>DBSCAN 算法</li><li>期望最大化（Expectation-maximization，EM）</li><li>模糊聚类（Fuzzy Clustering）</li><li>K-means 算法</li><li>K 均值聚类（K-means Clustering）</li><li>K-medians 聚类</li><li>均值漂移算法（Mean-shift）</li><li>OPTICS 算法</li></ul><h5 id="2-3-5-异常检测（Anomaly-detection）"><a href="#2-3-5-异常检测（Anomaly-detection）" class="headerlink" title="2.3.5.异常检测（Anomaly detection）"></a>2.3.5.异常检测（Anomaly detection）</h5><ul><li>K 最邻近（K-nearest Neighbor，KNN）算法</li><li>局部异常因子算法（Local Outlier Factor，LOF）</li></ul><h4 id="2-4-半监督学习："><a href="#2-4-半监督学习：" class="headerlink" title="2.4.半监督学习："></a>2.4.半监督学习：</h4><ul><li>生成模型（Generative Models）</li><li>低密度分离（Low-density Separation）</li><li>基于图形的方法（Graph-based Methods）</li><li>联合训练（Co-training）</li></ul><h4 id="2-5-强化学习类算法"><a href="#2-5-强化学习类算法" class="headerlink" title="2.5.强化学习类算法"></a>2.5.强化学习类算法</h4><ul><li>Q 学习（Q-learning）</li><li>状态-行动-奖励-状态-行动（State-Action-Reward-State-Action，SARSA）</li><li>DQN（Deep Q Network）</li><li>策略梯度算法（Policy Gradients）</li><li>基于模型强化学习（Model Based RL）</li><li>时序差分学习（Temporal Different Learning）</li></ul><h4 id="2-6-深度学习类算法："><a href="#2-6-深度学习类算法：" class="headerlink" title="2.6.深度学习类算法："></a>2.6.深度学习类算法：</h4><ul><li>深度信念网络（Deep Belief Machines）</li><li>深度卷积神经网络（Deep Convolutional Neural Networks）</li><li>深度递归神经网络（Deep Recurrent Neural Network）</li><li>分层时间记忆（Hierarchical Temporal Memory，HTM）</li><li>深度波尔兹曼机（Deep Boltzmann Machine，DBM）</li><li>栈式自动编码器（Stacked Autoencoder）</li><li>生成对抗网络（Generative Adversarial Networks）</li></ul><h3 id="3-解决任务算法"><a href="#3-解决任务算法" class="headerlink" title="3.解决任务算法"></a>3.解决任务算法</h3><p>按照解决任务的不同来分类，粗略可以分为五种：</p><ul><li>二分类算法（Two-class Classification）</li><li>多分类算法（Multi-class Classification）</li><li>回归算法（Regression）</li><li>聚类算法（Clustering）</li><li>异常检测（Anomaly Detection）</li></ul><h4 id="3-1-二分类（Two-class-Classification）"><a href="#3-1-二分类（Two-class-Classification）" class="headerlink" title="3.1.二分类（Two-class Classification）"></a>3.1.二分类（Two-class Classification）</h4><ul><li>（1）二分类支持向量机（Two-class SVM）：适用于数据特征较多、线性模型的场景。</li><li>（2）二分类平均感知器（Two-class Average Perceptron）：适用于训练时间短、线性模型的场景。</li><li>（3）二分类逻辑回归（Two-class Logistic Regression）：适用于训练时间短、线性模型的场景。</li><li>（4）二分类贝叶斯点机（Two-class Bayes Point Machine）：适用于训练时间短、线性模型的场景。（5）二分类决策森林（Two-class Decision Forest）：适用于训练时间短、精准的场景。</li><li>（6）二分类提升决策树（Two-class Boosted Decision Tree）：适用于训练时间短、精准度高、内存占用量大的场景</li><li>（7）二分类决策丛林（Two-class Decision Jungle）：适用于训练时间短、精确度高、内存占用量小的场景。</li><li>（8）二分类局部深度支持向量机（Two-class Locally Deep SVM）：适用于数据特征较多的场景。</li><li>（9）二分类神经网络（Two-class Neural Network）：适用于精准度高、训练时间较长的场景。</li></ul><h4 id="3-2-多分类（Multi-class-Classification）"><a href="#3-2-多分类（Multi-class-Classification）" class="headerlink" title="3.2.多分类（Multi-class Classification）"></a>3.2.多分类（Multi-class Classification）</h4><p>多分类问题通常适用三种解决方案：<br>第一种，从数据集和适用方法入手，利用二分类器解决多分类问题；<br>第二种，直接使用具备多分类能力的多分类器；<br>第三种，将二分类器改进成为多分类器今儿解决多分类问题。<br>常用的算法：<br>（1）多分类逻辑回归（Multiclass Logistic Regression）：适用训练时间短、线性模型的场景。<br>（2）多分类神经网络（Multiclass Neural Network）：适用于精准度高、训练时间较长的场景。<br>（3）多分类决策森林（Multiclass Decision Forest）：适用于精准度高，训练时间短的场景。<br>（4）多分类决策丛林（Multiclass Decision Jungle）：适用于精准度高，内存占用较小的场景。<br>（5）“一对多”多分类（One-vs-all Multiclass）：取决于二分类器效果。</p><h4 id="3-3-回归"><a href="#3-3-回归" class="headerlink" title="3.3.回归"></a>3.3.回归</h4><p>回归问题通常被用来预测具体的数值而非分类。除了返回的结果不同，其他方法与分类问题类似。<br>我们将定量输出，或者连续变量预测称为回归；将定性输出，或者离散变量预测称为分类。<br>常见的算法有：</p><ul><li>（1）排序回归（Ordinal Regression）：适用于对数据进行分类排序的场景。</li><li>（2）泊松回归（Poission Regression）：适用于预测事件次数的场景。</li><li>（3）快速森林分位数回归（Fast Forest Quantile Regression）：适用于预测分布的场景。</li><li>（4）线性回归（Linear Regression）：适用于训练时间短、线性模型的场景。</li><li>（5）贝叶斯线性回归（Bayesian Linear Regression）：适用于线性模型，训练数据量较少的场景。</li><li>（6）神经网络回归（Neural Network Regression）：适用于精准度高、训练时间较长的场景。</li><li>（7）决策森林回归（Decision Forest Regression）：适用于精准度高、训练时间短的场景。</li><li>（8）提升决策树回归（Boosted Decision Tree Regression）：适用于精确度高、训练时间短、内存占用较大的场景。</li></ul><h4 id="3-4-聚类"><a href="#3-4-聚类" class="headerlink" title="3.4.聚类"></a>3.4.聚类</h4><p>聚类的目标是发现数据的潜在规律和结构。聚类通常被用做描述和衡量不同数据源间的相似性，并把数据源分类到不同的簇中。<br>（1）层次聚类（Hierarchical Clustering）：适用于训练时间短、大数据量的场景。<br>（2）K-means 算法：适用于精准度高、训练时间短的场景。<br>（3）模糊聚类 FCM 算法（Fuzzy C-means，FCM）：适用于精确度高、训练时间短的场景。<br>（4）SOM 神经网络（Self-organizing Feature Map，SOM）：适用于运行时间较长的场景。</p><h4 id="3-5-异常检测"><a href="#3-5-异常检测" class="headerlink" title="3.5.异常检测"></a>3.5.异常检测</h4><p>异常检测是指对数据中存在的不正常或非典型的分体进行检测和标志，有时也称为偏差检测。<br>异常检测看起来和监督学习问题非常相似，都是分类问题。都是对样本的标签进行预测和判断，但是实际上两者的区别非常大，因为异常检测中的正样本（异常点）非常小。常用的算法有：<br>（1）一分类支持向量机（One-class SVM）：适用于数据特征较多的场景。<br>（2）基于 PCA 的异常检测（PCA-based Anomaly Detection）：适用于训练时间短的场景。</p><h3 id="4-迁移学习类算法"><a href="#4-迁移学习类算法" class="headerlink" title="4.迁移学习类算法"></a>4.迁移学习类算法</h3><ul><li>归纳式迁移学习（Inductive Transfer Learning）</li><li>直推式迁移学习（Transductive Transfer Learning）</li><li>无监督式迁移学习（Unsupervised Transfer Learning）</li><li>传递式迁移学习（Transitive Transfer Learning）</li></ul><p>算法的适用场景，需要考虑的因素有：</p><ul><li>（1）数据量的大小、数据质量和数据本身的特点</li><li>（2）机器学习要解决的具体业务场景中问题的本质是什么？</li><li>（3）可以接受的计算时间是什么？</li><li>（4）算法精度要求有多高？</li></ul><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h3><p>有了算法，有了被训练的数据（经过预处理过的数据），那么多次训练（考验计算能力的时候到了）后，经过模型评估和算法人员调参后，会获得训练模型。当新的数据输入后，那么我们的训练模型就会给出结果。业务要求的最基础的功能就算实现了。</p><p>互联网产品自动化运维是趋势，因为互联网需要快速响应的特性，决定了我们对问题要快速响应、快速修复。人工智能产品也不例外。AI + 自动化运维是如何工作的呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-人工智能的三大基石&quot;&gt;&lt;a href=&quot;#1-人工智能的三大基石&quot; class=&quot;headerlink&quot; title=&quot;1.人工智能的三大基石&quot;&gt;&lt;/a&gt;1.人工智能的三大基石&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;算法、数据、计算能力
&lt;/code&gt;&lt;/pre&gt;
&lt;</summary>
      
    
    
    
    <category term="algorithm" scheme="https://wuhaocn.github.io/categories/algorithm/"/>
    
    
    <category term="ai" scheme="https://wuhaocn.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="https://wuhaocn.github.io/2021/10/01/algorithm/sort/0.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://wuhaocn.github.io/2021/10/01/algorithm/sort/0.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-01T13:12:11.454Z</published>
    <updated>2021-10-01T13:12:11.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 算法步骤:</span></span><br><span class="line"><span class="comment"> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</span></span><br><span class="line"><span class="comment"> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span></span><br><span class="line"><span class="comment"> 重复第二步，直到所有元素均排序完毕。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> <span class="keyword">implements</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">78</span>&#125;;</span><br><span class="line">        SelectionSort selectionSort = <span class="keyword">new</span> SelectionSort();</span><br><span class="line">        selectionSort.sort(numbers);</span><br><span class="line">        selectionSort.print(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总共要经过 N-1 轮比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每轮需要比较的次数 N-i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[j] &lt; numbers[min]) &#123;</span><br><span class="line">                    <span class="comment">// 记录目前能找到的最小值元素的下标</span></span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将找到的最小值和i位置所在的值进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (i != min) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = numbers[i];</span><br><span class="line">                numbers[i] = numbers[min];</span><br><span class="line">                numbers[min] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="algorithm" scheme="https://wuhaocn.github.io/categories/algorithm/"/>
    
    
    <category term="sort" scheme="https://wuhaocn.github.io/tags/sort/"/>
    
  </entry>
  
</feed>
