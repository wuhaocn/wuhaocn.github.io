<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wuhaocn</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-24T07:10:16.376Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>wuhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ftp服务器搭建</title>
    <link href="http://example.com/2021/08/24/devops/docker/ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/08/24/devops/docker/ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</id>
    <published>2021-08-24T07:05:26.767Z</published>
    <updated>2021-08-24T07:10:16.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-拉取-镜像"><a href="#1-拉取-镜像" class="headerlink" title="1.拉取 镜像"></a>1.拉取 镜像</h3><p>docker pull fauria/vsftpd</p><h3 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2.启动容器"></a>2.启动容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker pull fauria/vsftpd</span><br><span class="line"></span><br><span class="line">mkdir /data/ftp</span><br><span class="line"></span><br><span class="line">docker stop vsftpd</span><br><span class="line"></span><br><span class="line">docker rm vsftpd</span><br><span class="line"></span><br><span class="line">docker run -d -v /data/ftp:/home/vsftpd -p 2120:20 -p 2121:21 -p 21100-21110:21100-21110 -e FTP_USER=urcs -e FTP_PASS=urcs@2018 -e PASV_ADDRESS=10.10.208.194 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 --name vsftpd --restart=always fauria/vsftpd</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3. 进入容器"></a>3. 进入容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec -i -t vsftpd bash 进去docker</span><br><span class="line"></span><br><span class="line">vi /etc/vsftpd/virtual_users.txt 编辑配置文件写入用户跟密码</span><br><span class="line"></span><br><span class="line">mkdir /home/vsftpd/user 建立新用户文件夹</span><br><span class="line"></span><br><span class="line">/usr/bin/db_load -T -t hash -f /etc/vsftpd/virtual_users.txt /etc/vsftpd/virtual_users.db 写入数据库</span><br><span class="line"></span><br><span class="line">docker restart +(虚拟机运行的 imageId) 重启服务</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-拉取-镜像&quot;&gt;&lt;a href=&quot;#1-拉取-镜像&quot; class=&quot;headerlink&quot; title=&quot;1.拉取 镜像&quot;&gt;&lt;/a&gt;1.拉取 镜像&lt;/h3&gt;&lt;p&gt;docker pull fauria/vsftpd&lt;/p&gt;
&lt;h3 id=&quot;2-启动容器&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="devops" scheme="http://example.com/categories/devops/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="ftp" scheme="http://example.com/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>nexus服务搭建</title>
    <link href="http://example.com/2021/08/24/devops/docker/nexus%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/08/24/devops/docker/nexus%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</id>
    <published>2021-08-24T07:05:26.756Z</published>
    <updated>2021-08-24T07:10:16.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nexus"><a href="#nexus" class="headerlink" title="nexus"></a>nexus</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /home/wuhao/nexus</span><br><span class="line">mkdir /home/wuhao/nexus</span><br><span class="line">docker stop nexus</span><br><span class="line">docker rm nexus</span><br><span class="line">docker run -d --name nexus -p 5260:8081 -p 5261:8082 -p 5262:8083 -p 5263:8084  -p 5264:5000 -v /home/wuhao/nexus:/var/nexus-data sonatype/nexus3</span><br><span class="line">docker logs -f nexus</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://10.10.208.193:5260/</span><br><span class="line"></span><br><span class="line">bash-4.0$ cd /nexus-data/</span><br><span class="line"></span><br><span class="line">bash-4.0$ ls</span><br><span class="line">admin.passwordblobs  cache  db  elasticsearch  etc  generated-bundles  instances  javaprefs  kar  keystores  lock  log  orient  portrestore-from-backup  tmp</span><br><span class="line"></span><br><span class="line">bash-4.0$ cat admin.password</span><br><span class="line">51a030af-f7ab-43d5-875e-3c2775dbae2c</span><br><span class="line"></span><br><span class="line">登录进去修改密码~~</span><br><span class="line">注意修改密码之后，提示是否开启anonymous模式，这个要勾选，否则public需要密码访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;nexus&quot;&gt;&lt;a href=&quot;#nexus&quot; class=&quot;headerlink&quot; title=&quot;nexus&quot;&gt;&lt;/a&gt;nexus&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安</summary>
      
    
    
    
    <category term="devops" scheme="http://example.com/categories/devops/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="nexus" scheme="http://example.com/tags/nexus/"/>
    
  </entry>
  
  <entry>
    <title>数据环境</title>
    <link href="http://example.com/2021/08/24/devops/docker/%E6%95%B0%E6%8D%AE%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2021/08/24/devops/docker/%E6%95%B0%E6%8D%AE%E7%8E%AF%E5%A2%83/</id>
    <published>2021-08-24T07:00:25.063Z</published>
    <updated>2021-08-24T07:10:16.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker部署数据中间件"><a href="#docker部署数据中间件" class="headerlink" title="docker部署数据中间件"></a>docker部署数据中间件</h2><ul><li>docker部署开发环境数据中间件</li></ul><h3 id="常见工具命令"><a href="#常见工具命令" class="headerlink" title="常见工具命令"></a>常见工具命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm `docker ps -a -q`</span><br><span class="line">docker start $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line">docker stop $(docker ps -a  | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># mysql5.6.40</span><br><span class="line">docker stop mysql.5.6.40</span><br><span class="line">docker rm mysql.5.6.40</span><br><span class="line">docker run --privileged=true --name mysql.5.6.40 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=coral@2018 -d mysql:5.6.40</span><br><span class="line">docker update mysql.5.6.40 --restart=always</span><br><span class="line"></span><br><span class="line"># mysql3336</span><br><span class="line">docker stop mysql3336</span><br><span class="line">docker rm mysql3336</span><br><span class="line">docker run --privileged=true --name mysql3336 -p 3336:3306 -e MYSQL_ROOT_PASSWORD=coral@2018 -d mysql:5.6.40</span><br><span class="line">docker update mysql3336 --restart=always</span><br><span class="line"></span><br><span class="line"># mysql3337</span><br><span class="line">docker stop mysql3337</span><br><span class="line">docker rm mysql3337</span><br><span class="line">docker run --privileged=true --name mysql3337 -p 3337:3306 -e MYSQL_ROOT_PASSWORD=coral@2018 -d mysql:5.6.40</span><br><span class="line">docker update mysql3337 --restart=always</span><br><span class="line"></span><br><span class="line"># mysql5.7.19</span><br><span class="line">docker stop mysql5.7.19</span><br><span class="line">docker rm mysql5.7.19</span><br><span class="line">docker run --name mysql5.7.19 --privileged=true -p 3337:3306 -e MYSQL_ROOT_PASSWORD=coral@2018 -d mysql:5.7.19</span><br></pre></td></tr></table></figure><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># redis 单机</span><br><span class="line">docker stop redis-6379</span><br><span class="line">docker rm redis-6379</span><br><span class="line">docker run -d -p 6379:6379  --name redis-6379  --privileged=true redis:3.2 redis-server --port 6379 --requirepass &quot;urcs@2021&quot;</span><br><span class="line">docker update redis-6379 --restart=always</span><br><span class="line"></span><br><span class="line">docker stop redis-6380</span><br><span class="line">docker rm redis-6380</span><br><span class="line">docker run -d -p 6380:6380  --name redis-6380  --privileged=true redis:3.2 redis-server --port 6380</span><br><span class="line"></span><br><span class="line">docker stop redis-6379</span><br><span class="line">docker rm redis-6379</span><br><span class="line">docker run -d -p 6379:6379  --name redis-6379  --privileged=true redis:3.2 redis-server --port 6379</span><br><span class="line">docker update redis-6379 --restart=always</span><br><span class="line"></span><br><span class="line"># sentinel</span><br><span class="line">在当前目录配置文件</span><br><span class="line">vim sentinel.conf</span><br><span class="line">sentinel monitor mymaster 10.10.220.120 6379 1</span><br><span class="line"></span><br><span class="line">启动sentinel</span><br><span class="line">docker stop redis-sentinel-26379</span><br><span class="line">docker rm redis-sentinel-26379</span><br><span class="line">docker run -d -p 26379:26379 -v /Users/wuhao/data/soft/redis/sentinel.conf:/usr/local/bin/redis-conf/sentinel.conf --name redis-sentinel-26379  redis:3.2 redis-sentinel /usr/local/bin/redis-conf/sentinel.conf --port 26379</span><br><span class="line"></span><br><span class="line">docker logs -f redis-sentinel-26379</span><br></pre></td></tr></table></figure><h3 id="hbase"><a href="#hbase" class="headerlink" title="hbase"></a>hbase</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">拉取镜像</span><br><span class="line">docker pull harisekhon/hbase:1.2</span><br><span class="line">运行镜像</span><br><span class="line">docker stop hbase1.2</span><br><span class="line">docker rm hbase1.2</span><br><span class="line">docker run -d -h hbase --privileged=true -p 2181:2181 -p 18080:8080 -p 18085:8085 -p 19090:9090 -p 19095:9095 -p 16000:16000 -p 16020:16020 -p 16010:16010 -p 16201:16201 -p 16301:16301 --name hbase1.2 harisekhon/hbase:1.2</span><br><span class="line">docker update hbase1.2 --restart=always</span><br><span class="line">docker exec -it hbase bash</span><br><span class="line"></span><br><span class="line">docker run -d -h hbase --privileged=true -p 2181:2181 -p 18080:8080 -p 18085:8085 -p 19090:9090 -p 19095:9095 -p 16000:16000 -p 16010:16010 -p 16201:16201 -p 16301:16301 --name hbase1.2 harisekhon/hbase:1.2</span><br></pre></td></tr></table></figure><h3 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull zookeeper:3.5</span><br><span class="line">docker run --name zookeeper3.5 -p 7998:2181 -d zookeeper:3.5</span><br><span class="line"></span><br><span class="line">docker stop zookeeper</span><br><span class="line">docker rm zookeeper</span><br><span class="line">docker run --privileged=true -d --name zookeeper --publish 7998:2181  -d zookeeper:3.5</span><br><span class="line">docker update zookeeper --restart=always</span><br></pre></td></tr></table></figure><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker pull wurstmeister/kafka:2.11-1.1.1</span><br><span class="line"></span><br><span class="line">docker stop kafka2.11</span><br><span class="line">docker rm kafka2.11</span><br><span class="line">docker run \</span><br><span class="line">--env KAFKA_BROKER_ID=0 \</span><br><span class="line">--env KAFKA_ZOOKEEPER_CONNECT=172.16.106.78:7998 \</span><br><span class="line">--env KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://172.16.106.78:9092 \</span><br><span class="line">--env KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \</span><br><span class="line"> --privileged=true -d --name kafka2.11 -p 9092:9092 \</span><br><span class="line">wurstmeister/kafka:2.11-1.1.1</span><br></pre></td></tr></table></figure><h3 id="fastdfs"><a href="#fastdfs" class="headerlink" title="fastdfs"></a>fastdfs</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stop trakcer</span><br><span class="line">sudo docker rm trakcer</span><br><span class="line">sudo docker run -d --privileged=true -p 22122:22122 --name trakcer --net=host 10.10.208.193:5000/urcs/fastdfs_tracker:4.08 tracker</span><br><span class="line">sudo docker update trakcer --restart=always</span><br><span class="line"></span><br><span class="line">sudo docker stop storage</span><br><span class="line">sudo docker rm storage</span><br><span class="line">sudo docker run -d --privileged=true -p 23000:23000 -p 8888:8888 --name storage --net=host --env TRACKER_SERVER=172.16.106.78:22122 10.10.208.193:5000/urcs/fastdfs_storage:4.08 storage</span><br><span class="line">sudo docker update storage --restart=always</span><br></pre></td></tr></table></figure><h3 id="es"><a href="#es" class="headerlink" title="es"></a>es</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:6.0.0</span><br><span class="line">docker stop elasticsearch</span><br><span class="line">docker rm elasticsearch</span><br><span class="line">docker run -d --name elasticsearch \</span><br><span class="line">-p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:6.0.0</span><br></pre></td></tr></table></figure><h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull elastic/kibana:6.0.0</span><br><span class="line"></span><br><span class="line">//做了定制化设置</span><br><span class="line">docker stop kibana6.0.0</span><br><span class="line">docker rm kibana6.0.0</span><br><span class="line">docker run -d --name kibana6.0.0  -e ELASTICSEARCH_URL=http://10.10.208.194:9200 -p 5601:5601  10.10.208.193:5000/urcs/kibana:6.0.0</span><br></pre></td></tr></table></figure><h3 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull sequenceiq/spark:1.6.0</span><br><span class="line"> docker run -it -p 8088:8088 -p 8042:8042 -h sandbox sequenceiq/spark:1.6.0 bash</span><br></pre></td></tr></table></figure><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">获取镜像</span><br><span class="line">docker pull beginor/gitlab-ce:11.3.0-ce.0</span><br><span class="line"></span><br><span class="line">运行</span><br><span class="line">通常会将 GitLab 的配置 (etc) 、 日志 (log) 、数据 (data) 放到容器之外， 便于日后升级， 因此请先准备这三个目录。</span><br><span class="line">sudo mkdir -p /mnt/sda1/gitlab/etc</span><br><span class="line">sudo mkdir -p /mnt/sda1/gitlab/log</span><br><span class="line">sudo mkdir -p /mnt/sda1/gitlab/data</span><br><span class="line"></span><br><span class="line">准备好这三个目录之后， 就可以开始运行 Docker 镜像了。 我的建议是使用unless-stopped 作为重启策略， 因为这样可以手工停止容器， 方便维护。</span><br><span class="line">完整的运行命令如下：</span><br><span class="line">docker run \</span><br><span class="line">    --detach \</span><br><span class="line">    --publish 8443:443 \</span><br><span class="line">    --publish 8080:80 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    --volume /mnt/sda1/gitlab/etc:/etc/gitlab \</span><br><span class="line">    --volume /mnt/sda1/gitlab/log:/var/log/gitlab \</span><br><span class="line">    --volume /mnt/sda1/gitlab/data:/var/opt/gitlab \</span><br><span class="line">    beginor/gitlab-ce:11.3.0-ce.0</span><br></pre></td></tr></table></figure><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull 124.42.103.163:5000/urcs/openresty-tcp:1.13.6.2-centos-rpm</span><br><span class="line"></span><br><span class="line">docker run -d --privileged=true -p 80:80 -p 443:443 -p 8020:8020 -p 8030:8030 -p 8040:8040 -p 8080:8080 -p 5260:5260 -p 7260:7260  --name openresty 124.42.103.163:5000/urcs/openresty-tcp:1.13.6.2-centos-rpm</span><br><span class="line"></span><br><span class="line">docker exec -it xxxx bash</span><br></pre></td></tr></table></figure><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull fauria/vsftpd</span><br><span class="line">mkdir /home/ultra/ftp</span><br><span class="line">docker stop vsftpd</span><br><span class="line">docker rm vsftpd</span><br><span class="line">docker run -d -v /home/ultra/ftp:/home/vsftpd -p 2120:20 -p 2121:21 -p 21100-21110:21100-21110 -e FTP_USER=urcs -e FTP_PASS=urcs@2018 -e PASV_ADDRESS=10.10.208.194 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 --name vsftpd --restart=always fauria/vsftpd</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="speed"><a href="#speed" class="headerlink" title="speed"></a>speed</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop speedtest</span><br><span class="line">docker rm speedtest</span><br><span class="line">docker run -d --name  speedtest -p 8888:80 adolfintel/speedtest:latest</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker部署数据中间件&quot;&gt;&lt;a href=&quot;#docker部署数据中间件&quot; class=&quot;headerlink&quot; title=&quot;docker部署数据中间件&quot;&gt;&lt;/a&gt;docker部署数据中间件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker部署开发环境数据中间件&lt;/l</summary>
      
    
    
    
    <category term="devops" scheme="http://example.com/categories/devops/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SCTP概要</title>
    <link href="http://example.com/2021/08/04/network/protocol/SCTP%E6%A6%82%E8%A6%81/"/>
    <id>http://example.com/2021/08/04/network/protocol/SCTP%E6%A6%82%E8%A6%81/</id>
    <published>2021-08-04T06:25:13.672Z</published>
    <updated>2021-08-04T06:25:13.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>SCTP(Stream Control Transmission Protocol),流控制传输协议,和UDP，TCP类似<br>TCP是一种面向连接的协议，提供可靠传输，确保数据有序发送；<br>UDP是一种面向消息的协议，不能确保数据有序发送<br>SCTP是后来引入的一种新的协议，提供了和TCP一样的可靠、有序的数据传输功能，同时却能和UDP一样面对消息的方式来进行操作，保护消息边界，有下面一些特性</p><h2 id="2-SCTP特性"><a href="#2-SCTP特性" class="headerlink" title="2.SCTP特性"></a>2.SCTP特性</h2><ul><li>多宿主（Multi-Homing）</li><li>多流（Multi-streaming）</li><li>初始化保护（Initiation protection）</li><li>消息分帧（Message framing）</li><li>可配置的无序发送（Configurable unordered delivery）</li><li>平滑关闭（Graceful shutdown）</li></ul><p>​</p><h3 id="2-1-多宿主"><a href="#2-1-多宿主" class="headerlink" title="2.1 多宿主"></a>2.1 多宿主</h3><p>SCTP里面引入了联合（Association）的概念TCP连接是在两个主机的单个接口之间建立的SCTP可以把多条路径合并到一个联合中，数据可以在任意一个连接路径上进行传输<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627480915523-b1986537-7174-48d4-a148-fba170b4d657.png#clientId=u48df284e-bf72-4&from=paste&id=u8942af97&margin=%5Bobject%20Object%5D&originHeight=325&originWidth=485&originalType=url&ratio=1&status=done&style=none&taskId=uafde6a16-0d86-4649-9d84-0dcd105a004"></p><h3 id="2-2-多流"><a href="#2-2-多流" class="headerlink" title="2.2 多流"></a>2.2 多流</h3><pre><code>   SCTP可以在一个联合中支持多流机制，每个流（stream）都是独立的。每个流都有各自的编号，编码在SCTP报文中阻塞的流不会影响同一联合中的其他流，可以并行进行传输</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627480914764-6dbae28f-4e8d-4bf3-9bf9-a53f4d86d378.png#clientId=u48df284e-bf72-4&from=paste&id=u08bbe321&margin=%5Bobject%20Object%5D&originHeight=164&originWidth=463&originalType=url&ratio=1&status=done&style=none&taskId=u612f73a4-99ec-4c4d-85c8-ff80dcdc695"></p><h3 id="2-3-初始化保护"><a href="#2-3-初始化保护" class="headerlink" title="2.3 初始化保护"></a>2.3 初始化保护</h3><pre><code>  TCP中的三次握手机制会被利用来进行DoS（Denial of Service）攻击，通过发送大量的SYN报文最终耗尽服务器的资源SCTP通过引入4次握手机制来避免这种场景：服务器的INIT-ACK中会包含cookie（标识这个连接的唯一上下文）；</code></pre><p>客户端使用这个cookie来进行响应。服务器收到这个响应后，才为这个连接分配资源；为了解决4次握手机制带来的时延，SCTP协议还允许在COOKIE-ECHO和COOKIE-ACK报文中传输数据包<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627480917379-b7cb7c2b-b1cb-4a80-8573-ebe1d246c7c7.png#clientId=u48df284e-bf72-4&from=paste&id=u3a4682d7&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=546&originalType=url&ratio=1&status=done&style=none&taskId=u554b496a-477c-49ba-bcc3-a16bad0a456"><br>消息分帧<br>TCP协议是按照字节流的方式进行数据传输的，并不存在消息边界，比如说音频视频都可以通过流的方式进行传递；UDP使用的是消息分帧，发端多大的数据包，收端收到的数据包也是这么大；<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627480915216-fecb3fa7-5a65-419b-9101-aff14c310912.png#clientId=u48df284e-bf72-4&from=paste&id=u3c6a317d&margin=%5Bobject%20Object%5D&originHeight=202&originWidth=426&originalType=url&ratio=1&status=done&style=none&taskId=u68997ce0-2001-421a-9e05-de4aaad582a"><br>可配置的无序发送<br>TCP能确保数据按照次序发送；UDP无法保证消息有序；SCTP中也可以配置成接受无序的消息；<br>这样的通信方式对于面向消息的传输非常有用，因为每个消息都是各自独立的，次序并不重要。<br>平滑关闭<br>TCP和SCTP都是基于连接的协议，完成传输后都需要有一个拆除连接的过程。TCP中连接的删除是半关闭的，服务的某一端可以关闭自己这端的socket，但是可以继续接受数据。SCTP协议设计的时候考虑这种半关闭的状态实际上很少使用，所以简化了关闭的过程，一旦某一端发起了连接拆除，对等的两端都关闭。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627480914813-f11dbcb5-74ba-46f1-a04d-c7e5538f7a5d.png#clientId=u48df284e-bf72-4&from=paste&id=u04833e5f&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=546&originalType=url&ratio=1&status=done&style=none&taskId=u43fedf9d-ba51-4d9a-992d-96bed9ef960"></p><p>版权声明：本文为博主原创文章，遵循<a href="https://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a>版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/qq_34709713/article/details/106511096">https://blog.csdn.net/qq_34709713/article/details/106511096</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;SCTP(Stream Control Transmission Protocol),流控制传输协议,和UDP，TCP类似&lt;</summary>
      
    
    
    
    <category term="5G" scheme="http://example.com/categories/5G/"/>
    
    
    <category term="5G" scheme="http://example.com/tags/5G/"/>
    
    <category term="NGAP" scheme="http://example.com/tags/NGAP/"/>
    
  </entry>
  
  <entry>
    <title>DPDK-架构解析</title>
    <link href="http://example.com/2021/08/04/network/dpdk/DPDK-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/08/04/network/dpdk/DPDK-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</id>
    <published>2021-08-04T06:25:13.670Z</published>
    <updated>2021-08-04T06:25:13.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h3 id="DPDK-架构解析"><a href="#DPDK-架构解析" class="headerlink" title="DPDK-架构解析"></a>DPDK-架构解析</h3><ul><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#_0">目录</a></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#_3">前文列表</a></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#DPDK__7">DPDK 架构</a></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#_32">内核态模块</a><ul><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#IGB_UIO_33">IGB_UIO</a></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#KNI_35">KNI</a></li></ul></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#PMD_44">PMD</a></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#DPDK_Lib_47">DPDK Lib（核心部件库）</a><ul><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#_75">组件代码</a></li></ul></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#_98">平台相关模块</a></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#Classify__109">Classify 库</a></li><li><a href="http://t.zoukankan.com/hzcya1995-p-13309271.html#QoS__112">QoS 库</a><h1 id="前文列表"><a href="#前文列表" class="headerlink" title="前文列表"></a>前文列表</h1>《<a href="https://is-cloud.blog.csdn.net/article/details/105980054">DPDK — 安装部署</a>》<br>《<a href="https://is-cloud.blog.csdn.net/article/details/98944634">DPDK — 数据平面开发技术</a>》<h1 id="DPDK-架构"><a href="#DPDK-架构" class="headerlink" title="DPDK 架构"></a>DPDK 架构</h1><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481768904-b3db99fb-9713-449c-8322-139b150da09f.png#clientId=u0928072c-4fbe-4&from=paste&id=ud4958617&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=942&originalType=url&ratio=1&size=130624&status=done&style=none&taskId=ue7338f12-4782-4375-b298-d165d19cfce" alt="image.png"></li></ul><p><strong>内核态模块</strong>：</p><ul><li>IGB_UIO：</li><li>KNI</li></ul><p><strong>用户态函数库以及网卡驱动程序</strong>：</p><ul><li>用户态轮询模式的网卡驱动程序（PMD Driver）</li><li>核心部件库（Core Libraries）</li><li>操作系统平台相关模块（Platform）</li><li>QoS 库</li><li>报文转发分类算法库（Classify）</li></ul><p>用户应用程序可以应用以上函数库以及驱动支持，来实现完全内核旁路的数据面转发应用程序，例如：OVS-DPDK。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481769146-6c669857-20c2-4539-8a45-342d8064df02.png#clientId=u0928072c-4fbe-4&from=paste&id=u61914ee9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=496&originWidth=389&originalType=url&ratio=1&size=244431&status=done&style=none&taskId=u498a303d-b2c5-4b95-9d2b-b86ccccf82b" alt="image.png"></p><ul><li><p><strong>EAL（Environment Abstraction Layer，环境抽象层）</strong>：为应用提供了一个通用接口，隐藏了与底层库与设备打交道的相关细节。EAL 实现了 DPDK 运行的初始化工作，基于大页表的内存分配，多核亲缘性设置，原子和锁操作，并将 PCI 设备地址映射到用户空间，方便应用程序访问。</p></li><li><p><strong>Buffer Manager API</strong>：通过预先从 EAL 上分配固定大小的多个内存对象，避免了在运行过程中动态进行内存分配和回收，以此来提高效率，用于数据包 Buffer 的管理。</p></li><li><p><strong>Queue/Ring Manager API</strong>：以高效的方式实现了无锁的 FIFO 环形队列，适用于一个生产者多个消费者、一个消费者多个生产者模型。支持批量无锁操作，可避免锁冲突导致的等待。</p></li><li><p><strong>Packet Flow Classification API</strong>：通过 Intel SSE 基于多元组的方式实现了高效的 HASH 算法，以便快速对数据包进行分类处理。该 API 一般用于路由查找过程中的最长前缀匹配。此外，安全产品场景中，可以根据 DataFlow 五元组来标记不同的用户。</p></li><li><p><strong>PMD（Poll Mode Library）</strong>：则实现了 Intel 1GbE、10GbE 和 40GbE 网卡下基于轮询收发包的工作模式，大大加速网卡收发包性能。</p><h1 id="内核态模块"><a href="#内核态模块" class="headerlink" title="内核态模块"></a>内核态模块</h1><h2 id="IGB-UIO"><a href="#IGB-UIO" class="headerlink" title="IGB_UIO"></a>IGB_UIO</h2><p>《<a href="https://is-cloud.blog.csdn.net/article/details/106007926">DPDK — IGB_UIO，与 UIO Framework 进行交互的内核模块</a>》</p><h2 id="KNI"><a href="#KNI" class="headerlink" title="KNI"></a>KNI</h2><p>KNI（Kernel NIC Interface，内核网卡接口），是 DPDK 允许用户态和内核态交换报文的解决方案，模拟了一个虚拟的网口，提供 DPDK 应用程序和 Linux 内核之间通讯没接。<strong>即 KNI 接口允许报文从用户态接收后转发到 Linux 内核协议栈中去</strong>。<br>虽然 DPDK 的高速转发性能很出色，但是也有自己的一些缺点，比如没有标准协议栈就是其中之一，当然也可能当时设计时就将没有将协议栈考虑进去，毕竟协议栈需要将报文转发处理，可能会使处理报文的能力大大降低。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481769261-be65ada1-ff35-4880-a322-d18f4e381979.png#clientId=u0928072c-4fbe-4&from=paste&id=uba9293cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=345&originWidth=558&originalType=url&ratio=1&size=82294&status=done&style=none&taskId=ucad680f6-11df-4deb-8c57-78c6b3ef9ff" alt="image.png"><br>上图是 KNI 的 mbuf 的使用流程，也可以看出报文的流向，因为报文在代码中其实就是一个个内存指针。其中 rx_q 右边是用户态，左边是内核态。最后通过调用 netif_rx 将报文送入 Linux 内核协议栈，这其中需要将 DPDK 的 mbuf 转换成标准的 skb_buf 结构体。当 Linux 内核向 KNI 端口发送报文时，调用回调函数 kni_net_tx，然后报文经过转换之后发送到端口上。</p><h1 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a>PMD</h1><p>《<a href="https://blog.csdn.net/Jmilk/article/details/103025477">DPDK — PMD，DPDK 的核心优化</a>》</p><h1 id="DPDK-Lib（核心部件库）"><a href="#DPDK-Lib（核心部件库）" class="headerlink" title="DPDK Lib（核心部件库）"></a>DPDK Lib（核心部件库）</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481773020-678f8177-7108-49a0-864e-ddf4523e41ba.png#clientId=u0928072c-4fbe-4&from=paste&id=uf52df5e3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=797&originalType=url&ratio=1&size=72204&status=done&style=none&taskId=ud2675454-3c19-45ba-93aa-e142cbd7379" alt="image.png"><br>核心部件库（Core Libraries）是 DPDK 面向用户态协议栈应用程序员开发的模块。</p></li><li><p><strong>EAL（Environment Abstraction Layer，环境抽象层）</strong>：对 DPDK 的运行环境（e.g. Linux 操作系统）进行初始化，包括：HugePage 内存分配、内存/缓冲区/队列分配、原子性无锁操作、NUMA 亲和性、CPU 绑定等，并通过 UIO 或 VFIO 技术将 PCI/PCIe 设备地址映射到用户态，方便了用户态的 DPDK 应用程序调用。同时为应用程序提供了一个通用接口，隐藏了其与底层库以及设备打交道的相关细节。</p></li><li><p><strong>MALLOC（堆内存管理组件）</strong>：为 DPDK 应用程序提供从 HugePage 内分配堆内存的接口。当需要为 SKB（Socket Buffer，本质是若干个数据包的缓存区）分配大量的小块内存时（如：分配用于存储 Buffer descriptor table 中每个表项指针的内存）可以调用该接口。由于堆内存是从 HugePage 内存分配的，所以可以减少 TLB 缺页。</p></li></ul><p>注：堆，是由开发人员主动分配和释放的存储空间， 若开发人员不释放，则程序结束时由 OS 回收，分配方式类似于链表；与堆不同，栈，是由操作系统自动分配和释放的存储空间 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。</p><ul><li><strong>MBUF（网络报文缓存块管理组件）</strong>：为 DPDK 应用程序提供创建和释放用于存储数据报文信息的缓存块的接口。提供了两种类型的 MBUF，一种用于存储一般信息，一种用于存储实际的报文数据。这些 MBUF 存储在一个内存池中。</li><li><strong>MEMPOOL（内存池管理组件）</strong>：为 DPDK 应用程序和其它组件提供分配内存池的接口，内存池是一个由固定大小的多个内存块组成的内存容器，可用于存储不同的对像实体，如：数据报文缓存块等。内存池由内存池的名称（一个字符串）进行唯一标识，它由一个 Ring 缓冲区和一组本地缓存队列组成，每个 CPU Core 优先从自身的缓存队列中分配内存块，当本地缓存队列减少到一定程度时，开始从内存环缓冲区中申请内存块来进行补充。</li><li><strong>RING（环缓冲区管理组件）</strong>：为 DPDK 应用程序和其它组件提供一个无锁的多生产者多消费者 FIFO 队列。</li></ul><p><strong>NOTE</strong>：DPDK 基于 Linux 内核的无锁环形缓冲 kfifo 实现了一套自己的无锁机制。支持单生产者入列/单消费者出列和多生产者入列/多消费者出列操作，在数据传输的时候，降低性能的同时还能保证数据的同步。</p><ul><li><strong>TIMER（定时器组件）</strong>：提供一些异步周期执行的接口（也可以只执行一次），可以指定某个函数在规定时间内的异步执行，就像 LIBC 中的 timer 定时器。但是这里的定时器需要 DPDK 应用程序在主循环中周期内调用 rte_timer_manage 来使能定时器，使用起来不那么方便。TIMER 的时间参考来自 EAL 层提供的时间接口。</li></ul><p>注：除了以上六个核心组件外，DPDK 还提供以下功能：</p><ol><li>以太网轮询模式驱动（PMD）架构：把以太网驱动从内核移到应用层，采用同步轮询机制而不是内核态的异步中断机制来提高报文的接收和发送效率。</li><li>报文转发算法支持：Hash 库和 LPM 库为报文转发算法提供支持。</li><li>网络协议定义和相关宏定义：基于 FreeBSD IP 协议栈的相关定义，如：TCP、UDP、SCTP 等协议头定义。</li><li>报文 QoS 调度库：支持随机早检测、流量整形、严格优先级和加权随机循环优先级调度等相关 QoS 功能。</li><li>内核网络接口库（KNI）：提供一种 DPDK 应用程序与内核协议栈的通信的方法，类似 Linux 的 TUN/TAP 接口，但比 TUN/TAP 接口效率高。每个物理网口可以虚拟出多个 KNI 接口。<h2 id="组件代码"><a href="#组件代码" class="headerlink" title="组件代码"></a>组件代码</h2><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481769193-9dfea3cf-22c5-4457-a519-93ed7c367c80.png#clientId=u0928072c-4fbe-4&from=paste&id=u0bdac4d1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=567&originWidth=754&originalType=url&ratio=1&size=235286&status=done&style=none&taskId=u50cc4576-6bc3-4c17-9ca9-16f78f2a3f9" alt="image.png"></li></ol><p><strong>注</strong>：</p><ul><li>RTE：Run-Time Environment</li><li>EAL：Environment Abstraction Layer</li><li>PMD：Poll-Mode Driver</li></ul><p>核心部件库对应的 DPDK 核心组件实现：</p><ul><li><strong>Memory Manager（librte_malloc，堆内存管理器）</strong>：提供一组 API，用于从 HugePages 内存创建的 memzones 中分配内存，而不是在堆中分配。这有助于改善 Linux 用户空间环境下典型的从堆中大量分配 4KB 页面而容易引起 TLB 不命中。</li><li><strong>Memory Pool Manager（librte_mempool，内存池管理器）</strong>：内存池管理器负责分配的内存中的 Pool 对象。Pool 由名称唯一标识，并使用一个 Ring 来存储空闲对象。它提供了其他一些可选的服务，例如：每个 CPU Core 的对象缓存和对齐方式帮助，以确保将填充的对象在所有内存通道上得到均匀分布。</li><li><strong>Ring Manager（librte_ring，环形队列管理器）</strong>：在一个大小有限的页表中，Ring 数据结构提供了一个无锁的多生产者-多消费者 FIFO API。相较于无锁队列，它有一些的优势，如：更容易实现，适应于大容量操作，而且速度更快。 一个 Ring 可以在 Memory Pool Manager 中被使用，也可以用于不同 CPU Core 或 Processor 之间作为通用的通信机制。</li><li><strong>Network Packet Buffer Management（librte_mbuf，网络报文缓冲区管理）</strong>：提供一组 API，用于分配、释放和操作 MBUFs（数据报文缓冲区），DPDK 应用程序中可以使用这些缓存区来存储消息以及报文数据。</li><li><strong>Timer Manager（librte_timer，定时器管理）</strong>：为 DPDK 应用程序的执行单元提供了定时服务，支持以异步的方式执行函数。定时器可以设置周期调用，也可以设置为只调用一次。DPDK 应用程序可以使用 EAL 提供的 HPET 接口来获取高精度时钟的引用，并且能在每个 Core 上根据需要进行初始化。</li></ul><p>代码目录：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481772817-48082ec2-383b-4210-ba40-a1222f0bc792.png#clientId=u0928072c-4fbe-4&from=paste&id=u3da3a1cd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1242&originWidth=850&originalType=url&ratio=1&size=875251&status=done&style=none&taskId=uf4da37b8-7885-437e-85b9-45254cdde0a" alt="image.png"></p><h1 id="平台相关模块"><a href="#平台相关模块" class="headerlink" title="平台相关模块"></a>平台相关模块</h1><p>平台相关模块（Platform）包括 KNI、POWER（能耗管理）以及 IVSHMEM 接口。</p><ul><li><strong>KNI</strong>：主要通过 Linux 内核中的 kni.ko 模块将数据报文从用户态传递给内核态协议栈处理，以便常规的用户进程（e.g. Container）可以使用 Linux 内核协议栈传统的 Socket 接口对相关报文进行处理。</li><li><strong>POWER</strong>：提供了一些 API，让 DPDK 应用程序可以根据收包速率动态调整 CPU 频率或让 CPU 进入不同的休眠状态。</li><li><strong>IVSHMEM</strong>：模块提供了虚拟机与虚拟机之间，或者虚拟机与主机之间的零拷贝共享内存机制。当 DPDK 应用程序运行时，IVSHMEM 模块会调用 Core Libraries 的 API，把几个 HugePage 内存映射为一个 IVSHMEM 设备池，并通过参数传递给 QEMU，这样，就实现了虚拟机之间的零拷贝内存共享。<h1 id="Classify-库"><a href="#Classify-库" class="headerlink" title="Classify 库"></a>Classify 库</h1>支持精确匹配（Exact Match）、最长匹配（LPM）和通配符匹配（ACL）数据报文，并提供常用的包处理的查表操作。<h1 id="QoS-库"><a href="#QoS-库" class="headerlink" title="QoS 库"></a>QoS 库</h1>提供网络服务质量相关的组件，如：限速（Meter）和调度（Scheduler）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h3 id=&quot;DPDK-架构解析&quot;&gt;&lt;a href=&quot;#DPDK-架构解析&quot; class=&quot;headerlink&quot; title=&quot;DPDK-架构</summary>
      
    
    
    
    <category term="5G" scheme="http://example.com/categories/5G/"/>
    
    
    <category term="5G" scheme="http://example.com/tags/5G/"/>
    
    <category term="DPDK" scheme="http://example.com/tags/DPDK/"/>
    
  </entry>
  
  <entry>
    <title>一文看懂DPDK</title>
    <link href="http://example.com/2021/08/04/network/dpdk/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82DPDK/"/>
    <id>http://example.com/2021/08/04/network/dpdk/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82DPDK/</id>
    <published>2021-08-04T06:25:13.670Z</published>
    <updated>2021-08-04T06:25:13.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大纲："><a href="#大纲：" class="headerlink" title="大纲："></a>大纲：</h1><ul><li>一、 网络IO的处境和趋势</li><li>二、 Linux + x86网络IO瓶颈</li><li>三、 DPDK的基本原理</li><li>四、 DPDK的基石UIO</li><li>五、 DPDK核心优化：PMD</li><li>六、 DPDK的高性能代码实现</li><li>七、 DPDK生态</li></ul><h2 id="一、网络IO的处境和趋势"><a href="#一、网络IO的处境和趋势" class="headerlink" title="一、网络IO的处境和趋势"></a>一、网络IO的处境和趋势</h2><p>从我们用户的使用就可以感受到网速一直在提升，而网络技术的发展也从1GE/10GE/25GE/40GE/100GE的演变，从中可以得出单机的网络IO能力必须跟上时代的发展。<br><strong>1.传统的电信领域</strong><br>IP层及以下，例如路由器、交换机、防火墙、基站等设备都是采用硬件解决方案。基于专用网络处理器（NP），有基于FPGA，更有基于ASIC的。但是基于硬件的劣势非常明显，发生Bug不易修复，不易调试维护，并且网络技术一直在发展，例如2G/3G/4G/5G等移动技术的革新，这些属于业务的逻辑基于硬件实现太痛苦，不能快速迭代。传统领域面临的挑战是急需一套软件架构的高性能网络IO开发框架。<br><strong>2.云的发展</strong><br>私有云的出现通过网络功能虚拟化（NFV）共享硬件成为趋势，NFV的定义是通过标准的服务器、标准交换机实现各种传统的或新的网络功能。急需一套基于常用系统和标准服务器的高性能网络IO开发框架。<br><strong>3.单机性能的飙升</strong><br>网卡从1G到100G的发展，CPU从单核到多核到多CPU的发展，服务器的单机能力通过横行扩展达到新的高点。但是软件开发却无法跟上节奏，单机处理能力没能和硬件门当户对，如何开发出与时并进高吞吐量的服务，单机百万千万并发能力。即使有业务对QPS要求不高，主要是CPU密集型，但是现在大数据分析、人工智能等应用都需要在分布式服务器之间传输大量数据完成作业。这点应该是我们互联网后台开发最应关注，也最关联的。</p><h2 id="二、Linux-x86网络IO瓶颈"><a href="#二、Linux-x86网络IO瓶颈" class="headerlink" title="二、Linux + x86网络IO瓶颈"></a>二、Linux + x86网络IO瓶颈</h2><p>在数年前曾经写过《网卡工作原理及高并发下的调优》一文，描述了Linux的收发报文流程。根据经验，在C1（8核）上跑应用每1W包处理需要消耗1%软中断CPU，这意味着单机的上限是100万PPS（Packet Per Second）。从TGW（Netfilter版）的性能100万PPS，AliLVS优化了也只到150万PPS，并且他们使用的服务器的配置还是比较好的。假设，我们要跑满10GE网卡，每个包64字节，这就需要2000万PPS（注：以太网万兆网卡速度上限是1488万PPS，因为最小帧大小为84B《<a href="https://www.cisco.com/c/en/us/about/security-center/network-performance-metrics.html">Bandwidth, Packets Per Second, and Other Network Performance Metrics</a>》），100G是2亿PPS，即每个包的处理耗时不能超过50纳秒。而一次Cache Miss，不管是TLB、数据Cache、指令Cache发生Miss，回内存读取大约65纳秒，NUMA体系下跨Node通讯大约40纳秒。所以，即使不加上业务逻辑，即使纯收发包都如此艰难。我们要控制Cache的命中率，我们要了解计算机体系结构，不能发生跨Node通讯。<br>从这些数据，我希望可以直接感受一下这里的挑战有多大，理想和现实，我们需要从中平衡。问题都有这些<br>1.传统的收发报文方式都必须采用硬中断来做通讯，每次硬中断大约消耗100微秒，这还不算因为终止上下文所带来的Cache Miss。<br>2.数据必须从内核态用户态之间切换拷贝带来大量CPU消耗，全局锁竞争。<br>3.收发包都有系统调用的开销。<br>4.内核工作在多核上，为可全局一致，即使采用Lock Free，也避免不了锁总线、内存屏障带来的性能损耗。<br>5.从网卡到业务进程，经过的路径太长，有些其实未必要的，例如netfilter框架，这些都带来一定的消耗，而且容易Cache Miss。</p><h2 id="三、DPDK的基本原理"><a href="#三、DPDK的基本原理" class="headerlink" title="三、DPDK的基本原理"></a>三、DPDK的基本原理</h2><p>从前面的分析可以得知IO实现的方式、内核的瓶颈，以及数据流过内核存在不可控因素，这些都是在内核中实现，内核是导致瓶颈的原因所在，要解决问题需要绕过内核。所以主流解决方案都是旁路网卡IO，绕过内核直接在用户态收发包来解决内核的瓶颈。<br>Linux社区也提供了旁路机制<a href="http://info.iet.unipi.it/~luigi/netmap/">Netmap</a>，官方数据10G网卡1400万PPS，但是Netmap没广泛使用。其原因有几个：<br>1.Netmap需要驱动的支持，即需要网卡厂商认可这个方案。<br>2.Netmap仍然依赖中断通知机制，没完全解决瓶颈。<br>3.Netmap更像是几个系统调用，实现用户态直接收发包，功能太过原始，没形成依赖的网络开发框架，社区不完善。<br>那么，我们来看看发展了十几年的DPDK，从Intel主导开发，到华为、思科、AWS等大厂商的加入，核心玩家都在该圈子里，拥有完善的社区，生态形成闭环。早期，主要是传统电信领域3层以下的应用，如华为、中国电信、中国移动都是其早期使用者，交换机、路由器、网关是主要应用场景。但是，随着上层业务的需求以及DPDK的完善，在更高的应用也在逐步出现。<br>DPDK旁路原理：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481909477-2b323099-10ad-4130-9304-45ec7a49f78b.png#clientId=uaf56e294-6f0f-4&from=paste&height=509&id=ub579f8c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1017&originWidth=1620&originalType=binary&ratio=1&size=250499&status=done&style=none&taskId=u2563a9e7-9bfd-435c-be58-c4bf5090890&width=810" alt="image.png"><br>图片引自Jingjing Wu的文档《Flow Bifurcation on Intel® Ethernet Controller X710/XL710》<br>左边是原来的方式数据从 网卡 -&gt; 驱动 -&gt; 协议栈 -&gt; Socket接口 -&gt; 业务<br>右边是DPDK的方式，基于UIO（Userspace I/O）旁路数据。数据从 网卡 -&gt; DPDK轮询模式-&gt; DPDK基础库 -&gt; 业务<br>用户态的好处是易用开发和维护，灵活性好。并且Crash也不影响内核运行，鲁棒性强。<br>DPDK支持的CPU体系架构：x86、ARM、PowerPC（PPC）<br>DPDK支持的网卡列表：<a href="https://core.dpdk.org/supported/">https://core.dpdk.org/supported/</a>，我们主流使用Intel 82599（光口）、Intel x540（电口）</p><h2 id="四、DPDK的基石UIO"><a href="#四、DPDK的基石UIO" class="headerlink" title="四、DPDK的基石UIO"></a>四、DPDK的基石UIO</h2><p>为了让驱动运行在用户态，Linux提供<a href="https://lwn.net/Articles/232575/">UIO</a>机制。使用UIO可以通过read感知中断，通过mmap实现和网卡的通讯。<br><strong>UIO原理：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481922795-fca2bf04-8423-4259-8388-048077db52f2.png#clientId=uaf56e294-6f0f-4&from=paste&height=335&id=u6daa38c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=669&originWidth=1024&originalType=binary&ratio=1&size=209374&status=done&style=none&taskId=u86af8dc3-fe1b-4d36-aa01-2a17725dd02&width=512" alt="image.png"><br>要开发用户态驱动有几个步骤：<br>1.开发运行在内核的UIO模块，因为硬中断只能在内核处理<br>2.通过/dev/uioX读取中断<br>3.通过mmap和外设共享内存</p><h2 id="五、DPDK核心优化：PMD"><a href="#五、DPDK核心优化：PMD" class="headerlink" title="五、DPDK核心优化：PMD"></a>五、DPDK核心优化：PMD</h2><p>DPDK的UIO驱动屏蔽了硬件发出中断，然后在用户态采用主动轮询的方式，这种模式被称为<a href="http://doc.dpdk.org/guides/prog_guide/poll_mode_drv.html">PMD</a>（Poll Mode Driver）。<br>UIO旁路了内核，主动轮询去掉硬中断，DPDK从而可以在用户态做收发包处理。带来Zero Copy、无系统调用的好处，同步处理减少上下文切换带来的Cache Miss。<br>运行在PMD的Core会处于用户态CPU100%的状态<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481936558-321d0b43-f5b2-40a3-91f1-f22d15f099f8.png#clientId=uaf56e294-6f0f-4&from=paste&height=387&id=ucbfe9a24&margin=%5Bobject%20Object%5D&name=image.png&originHeight=308&originWidth=561&originalType=binary&ratio=1&size=36195&status=done&style=none&taskId=uf66018ea-7769-486d-a44c-9d21dcd084d&width=704.5" alt="image.png"><br>网络空闲时CPU长期空转，会带来能耗问题。所以，DPDK推出Interrupt DPDK模式。<br><strong>Interrupt DPDK：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627481948671-5b96cbd8-dc36-4d24-a127-7fd62105a10d.png#clientId=uaf56e294-6f0f-4&from=paste&height=176&id=u704c6d00&margin=%5Bobject%20Object%5D&name=image.png&originHeight=183&originWidth=729&originalType=binary&ratio=1&size=26634&status=done&style=none&taskId=udeeea4f7-6473-4504-8186-2bf2e0adda5&width=699.5" alt="image.png"><br>图片引自David Su/Yunhong Jiang/Wei Wang的文档《Towards Low Latency Interrupt Mode DPDK》<br>它的原理和<a href="https://www.ibm.com/developerworks/cn/linux/l-napi/index.html">NAPI</a>很像，就是没包可处理时进入睡眠，改为中断通知。并且可以和其他进程共享同个CPU Core，但是DPDK进程会有更高调度优先级。</p><h2 id="六、DPDK的高性能代码实现"><a href="#六、DPDK的高性能代码实现" class="headerlink" title="六、DPDK的高性能代码实现"></a>六、DPDK的高性能代码实现</h2><p><strong>1.采用</strong><a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">HugePage</a><strong>减少TLB Miss</strong><br>默认下Linux采用4KB为一页，页越小内存越大，页表的开销越大，页表的内存占用也越大。CPU有<a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>（Translation Lookaside Buffer）成本高所以一般就只能存放几百到上千个页表项。如果进程要使用64G内存，则64G/4KB=16000000（一千六百万）页，每页在页表项中占用16000000 * 4B=62MB。如果用HugePage采用2MB作为一页，只需64G/2MB=2000，数量不在同个级别。<br>而DPDK采用HugePage，在x86-64下支持2MB、1GB的页大小，几何级的降低了页表项的大小，从而减少TLB-Miss。并提供了内存池（Mempool）、MBuf、无锁环（Ring）、Bitmap等基础库。根据我们的实践，在数据平面（Data Plane）频繁的内存分配释放，必须使用内存池，不能直接使用rte_malloc，DPDK的内存分配实现非常简陋，不如ptmalloc。<br><strong>2.SNA（Shared-nothing Architecture）</strong><br>软件架构去中心化，尽量避免全局共享，带来全局竞争，失去横向扩展的能力。NUMA体系下不跨Node远程使用内存。<br><strong>3.SIMD（Single Instruction Multiple Data）</strong><br>从最早的mmx/sse到最新的avx2，SIMD的能力一直在增强。DPDK采用批量同时处理多个包，再用向量编程，一个周期内对所有包进行处理。比如，memcpy就使用SIMD来提高速度。<br>SIMD在游戏后台比较常见，但是其他业务如果有类似批量处理的场景，要提高性能，也可看看能否满足。<br><strong>4.不使用慢速API</strong><br>这里需要重新定义一下慢速API，比如说gettimeofday，虽然在64位下通过<a href="http://man7.org/linux/man-pages/man7/vdso.7.html">vDSO</a>已经不需要陷入内核态，只是一个纯内存访问，每秒也能达到几千万的级别。但是，不要忘记了我们在10GE下，每秒的处理能力就要达到几千万。所以即使是gettimeofday也属于慢速API。DPDK提供<a href="https://doc.dpdk.org/api/rte__cycles_8h.html">Cycles</a>接口，例如rte_get_tsc_cycles接口，基于HPET或TSC实现。<br>在x86-64下使用RDTSC指令，直接从寄存器读取，需要输入2个参数，比较常见的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline uint64_t</span><br><span class="line">rte_rdtsc(void)</span><br><span class="line">&#123;</span><br><span class="line">      uint32_t lo, hi;</span><br><span class="line"></span><br><span class="line">      __asm__ __volatile__ (</span><br><span class="line">                 &quot;rdtsc&quot; : &quot;=a&quot;(lo), &quot;=d&quot;(hi)</span><br><span class="line">                 );</span><br><span class="line"></span><br><span class="line">      return ((unsigned long long)lo) | (((unsigned long long)hi) &lt;&lt; 32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写逻辑没错，但是还不够极致，还涉及到2次位运算才能得到结果，我们看看DPDK是怎么实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static inline uint64_t</span><br><span class="line">rte_rdtsc(void)</span><br><span class="line">&#123;</span><br><span class="line">union &#123;</span><br><span class="line">uint64_t tsc_64;</span><br><span class="line">struct &#123;</span><br><span class="line">uint32_t lo_32;</span><br><span class="line">uint32_t hi_32;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; tsc;</span><br><span class="line"></span><br><span class="line">asm volatile(&quot;rdtsc&quot; :</span><br><span class="line">     &quot;=a&quot; (tsc.lo_32),</span><br><span class="line">     &quot;=d&quot; (tsc.hi_32));</span><br><span class="line">return tsc.tsc_64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>巧妙的利用C的union共享内存，直接赋值，减少了不必要的运算。但是使用tsc有些问题需要面对和解决</p><ol><li>CPU亲和性，解决多核跳动不精确的问题</li><li>内存屏障，解决乱序执行不精确的问题</li><li>禁止降频和禁止Intel Turbo Boost，固定CPU频率，解决频率变化带来的失准问题</li></ol><p><strong>5.编译执行优化</strong></p><ol><li>分支预测<br>现代CPU通过<a href="https://en.wikipedia.org/wiki/Instruction_pipelining">pipeline</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E7%B4%94%E9%87%8F">superscalar</a>提高并行处理能力，为了进一步发挥并行能力会做<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%94%AF%E9%A0%90%E6%B8%AC%E5%99%A8">分支预测</a>，提升CPU的并行能力。遇到分支时判断可能进入哪个分支，提前处理该分支的代码，预先做指令读取编码读取寄存器等，预测失败则预处理全部丢弃。我们开发业务有时候会非常清楚这个分支是true还是false，那就可以通过人工干预生成更紧凑的代码提示CPU分支预测成功率。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#if !__GLIBC_PREREQ(2, 3)</span><br><span class="line">#    if !define __builtin_expect</span><br><span class="line">#        define __builtin_expect(x, expected_value) (x)</span><br><span class="line">#    endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if !defined(likely)</span><br><span class="line">#define likely(x) (__builtin_expect(!!(x), 1))</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if !defined(unlikely)</span><br><span class="line">#define unlikely(x) (__builtin_expect(!!(x), 0))</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li>CPU Cache预取<br>Cache Miss的代价非常高，回内存读需要65纳秒，可以将即将访问的数据主动推送的CPU Cache进行优化。比较典型的场景是链表的遍历，链表的下一节点都是随机内存地址，所以CPU肯定是无法自动预加载的。但是我们在处理本节点时，可以通过CPU指令将下一个节点推送到Cache里。<br>API文档：<a href="https://doc.dpdk.org/api/rte__prefetch_8h.html">https://doc.dpdk.org/api/rte__prefetch_8h.html</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline void rte_prefetch0(const volatile void *p)</span><br><span class="line">&#123;</span><br><span class="line">asm volatile (&quot;prefetcht0 %[p]&quot; : : [p] &quot;m&quot; (*(const volatile char *)p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if !defined(prefetch)</span><br><span class="line">#define prefetch(x) __builtin_prefetch(x)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>…等等<br>3) 内存对齐<br>内存对齐有2个好处：<br>l 避免结构体成员跨Cache Line，需2次读取才能合并到寄存器中，降低性能。结构体成员需从大到小排序和以及强制对齐。参考《<a href="https://www.ibm.com/developerworks/library/pa-dalign/">Data alignment: Straighten up and fly right</a>》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __rte_packed __attribute__((__packed__))</span><br></pre></td></tr></table></figure><p>l 多线程场景下写产生<a href="https://en.wikipedia.org/wiki/False_sharing">False sharing</a>，造成Cache Miss，结构体按Cache Line对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifndef CACHE_LINE_SIZE</span><br><span class="line">#define CACHE_LINE_SIZE 64</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef aligined</span><br><span class="line">#define aligined(a) __attribute__((__aligned__(a)))</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ol start="4"><li>常量优化<br>常量相关的运算的编译阶段完成。比如C++11引入了constexp，比如可以使用GCC的__builtin_constant_p来判断值是否常量，然后对常量进行编译时得出结果。举例网络序主机序转换<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define rte_bswap32(x) ((uint32_t)(__builtin_constant_p(x) ?\</span><br><span class="line">   rte_constant_bswap32(x) :\</span><br><span class="line">   rte_arch_bswap32(x)))</span><br></pre></td></tr></table></figure>其中rte_constant_bswap32的实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define RTE_STATIC_BSWAP32(v) \</span><br><span class="line">((((uint32_t)(v) &amp; UINT32_C(0x000000ff)) &lt;&lt; 24) | \</span><br><span class="line"> (((uint32_t)(v) &amp; UINT32_C(0x0000ff00)) &lt;&lt;  8) | \</span><br><span class="line"> (((uint32_t)(v) &amp; UINT32_C(0x00ff0000)) &gt;&gt;  8) | \</span><br><span class="line"> (((uint32_t)(v) &amp; UINT32_C(0xff000000)) &gt;&gt; 24))</span><br></pre></td></tr></table></figure>5）使用CPU指令<br>现代CPU提供很多指令可直接完成常见功能，比如大小端转换，x86有bswap指令直接支持了。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline uint64_t rte_arch_bswap64(uint64_t _x)</span><br><span class="line">&#123;</span><br><span class="line">register uint64_t x = _x;</span><br><span class="line">asm volatile (&quot;bswap %[x]&quot;</span><br><span class="line">      : [x] &quot;+r&quot; (x)</span><br><span class="line">      );</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这个实现，也是GLIBC的实现，先常量优化、CPU指令优化、最后才用裸代码实现。毕竟都是顶端程序员，对语言、编译器，对实现的追求不一样，所以造轮子前一定要先了解好轮子。<br>Google开源的<a href="https://github.com/google/cpu_features">cpu_features</a>可以获取当前CPU支持什么特性，从而对特定CPU进行执行优化。高性能编程永无止境，对硬件、内核、编译器、开发语言的理解要深入且与时俱进。<h2 id="七、DPDK生态"><a href="#七、DPDK生态" class="headerlink" title="七、DPDK生态"></a>七、DPDK生态</h2>对我们互联网后台开发来说DPDK框架本身提供的能力还是比较裸的，比如要使用DPDK就必须实现ARP、IP层这些基础功能，有一定上手难度。如果要更高层的业务使用，还需要用户态的传输协议支持。不建议直接使用DPDK。<br>目前生态完善，社区强大（一线大厂支持）的应用层开发项目是<a href="https://fd.io/">FD.io</a>（The Fast Data Project），有思科开源支持的<a href="https://wiki.fd.io/view/VPP">VPP</a>，比较完善的协议支持，ARP、VLAN、Multipath、IPv4/v6、MPLS等。用户态传输协议UDP/TCP有<a href="https://wiki.fd.io/view/TLDK">TLDK</a>。从项目定位到社区支持力度算比较靠谱的框架。<br>腾讯云开源的<a href="https://github.com/f-stack/f-stack">F-Stack</a>也值得关注一下，开发更简单，直接提供了POSIX接口。<br><a href="https://github.com/scylladb/seastar">Seastar</a>也很强大和灵活，内核态和DPDK都随意切换，也有自己的传输协议<a href="https://github.com/scylladb/seastar/blob/master/doc/native-stack.md">Seastar Native TCP/IP Stack</a>支持，但是目前还未看到有大型项目在使用Seastar，可能需要填的坑比较多。<br>我们GBN Gateway项目需要支持L3/IP层接入做Wan网关，单机20GE，基于DPDK开发。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大纲：&quot;&gt;&lt;a href=&quot;#大纲：&quot; class=&quot;headerlink&quot; title=&quot;大纲：&quot;&gt;&lt;/a&gt;大纲：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一、 网络IO的处境和趋势&lt;/li&gt;
&lt;li&gt;二、 Linux + x86网络IO瓶颈&lt;/li&gt;
&lt;li&gt;三、 DPDK</summary>
      
    
    
    
    <category term="5G" scheme="http://example.com/categories/5G/"/>
    
    
    <category term="5G" scheme="http://example.com/tags/5G/"/>
    
    <category term="DPDK" scheme="http://example.com/tags/DPDK/"/>
    
  </entry>
  
  <entry>
    <title>5G网络</title>
    <link href="http://example.com/2021/08/04/network/5G%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2021/08/04/network/5G%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/</id>
    <published>2021-08-04T06:25:13.668Z</published>
    <updated>2021-08-24T07:20:36.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5G网络概述"><a href="#5G网络概述" class="headerlink" title="5G网络概述"></a>5G网络概述</h1><h2 id="1-网络架构"><a href="#1-网络架构" class="headerlink" title="1.网络架构"></a>1.网络架构</h2><p>   5G网络的主要涵盖基站(gNB)、承载网、5G核心网(5GC)、IMS核心网(IMS)、5G消息(RCS)、边缘计算(MEC)等网络功能模块,借助上述网路功能模块，提供无线射频信号的收发、网路流量的转发、短信、音视频电话、富媒体消息、MAAP消息业务(类似微信公众号+小程序)等。下图为5G网络架构图。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627354681299-fa0eab41-6e38-49d7-8e5a-46acacb57d8d.png#clientId=u0c2dc641-5b75-4&from=paste&height=724&id=u4bbac9fc&margin=%5Bobject%20Object%5D&name=%E4%B8%8B%E8%BD%BD.png&originHeight=942&originWidth=730&originalType=binary&ratio=1&size=137523&status=done&style=none&taskId=ud767b281-b748-4825-bd3d-1f64cf57f47&width=561" alt="下载.png"><br>下文分别针对设备接入层、接入网、5G核心网、IMS网络、5G消息等模块进行介绍。</p><ul><li>设备接入（5G手机）：</li></ul><p>设备网络通信模块主要是基于芯片，市面上分为高通、海思、天玑等几大类。主流手机小米10、华为P40、华为Mate、荣耀30等之后型号基本都支持。</p><ul><li>接入网（gNB）：</li></ul><p> gNB主要分为宏基站与微基站（室内站），国内宏基站以华为、中兴、大唐为主，以华为基站为例包含AAU 、BBU，AAU负责无线信号收发，BBU与核心网联通，微基站以京信、共进、佰才邦，以共进为例，主要是以一体化基站为主。其中宏基站用于增加网路覆盖，微基站用于增强信号质量。</p><ul><li><p>5G核心网(5GC)：</p><p>   核心网络建设主要用于提供 5G 终端设备（如手机，车载终端，摄像头等设备）的身份鉴权、流量分发、边缘计算、网络切片等业务能力，核心网网元较多，这针对重点网元进行介绍，AMF用于提供用户接入控制，对外主要网络协议为NAS、NGAP，UDM用于提供用户信息存储，即用户开卡信息，网络认证秘钥等， SMF用于提供网络流量控制，UPF用于提供网络流量转发。</p></li><li><p>IMS核心网(IMS)：</p></li></ul><p>主要提供短信、音视频通话、电话会议等能力，主要通信协议为SIP、RTP，音频编解码为AMR，视频编解码4G为H264,5G为H265。其中SBC/P-CSCF提供终端接入功能, CSCF提供信令路由功能，IP Centex提供会议接入等功能。</p><ul><li><p>5G消息(RCS)：</p><pre><code>5G消息主要提供富媒体通信能力，借助手机原生能力能力实现富媒体通信，主要提供单聊、群聊、MAAP等业务，对手机侧通信协议主要包含SIP、MSRP等协议，对企业接入主要提供HTTP协议。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627314165117-add1c2c7-04e6-4ccb-be5d-e7d68f14d600.png#clientId=ua70594ae-1f25-4&from=paste&height=385&id=cwOqf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=385&originWidth=420&originalType=binary&ratio=1&size=152601&status=done&style=none&taskId=uaebd138d-d72f-4dd4-952c-f86ea6c17dd&width=420" alt="image.png"><br> 通过上述业务分析，相比原有通信能力，5G网络整体趋势为网络精细化、网络开放化、通信多样化、网络智能化演进。<br>   下文对主要业务流程进行接入. 5G核心网文档可参考(TS 23.501, TS 23.502)</p><h2 id="2-5G主要网络协议栈"><a href="#2-5G主要网络协议栈" class="headerlink" title="2.5G主要网络协议栈"></a>2.5G主要网络协议栈</h2><h3 id="2-1-4-5G协议栈对比"><a href="#2-1-4-5G协议栈对比" class="headerlink" title="2.1 4/5G协议栈对比"></a>2.1 4/5G协议栈对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1626931898798-9421984d-e966-42a1-9e79-7e3ec35b492d.png#clientId=u154c83d4-6762-4&from=paste&height=866&id=eEVVz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=866&originWidth=1311&originalType=binary&ratio=1&size=915401&status=done&style=none&taskId=uff0338a0-360d-4d57-ac82-bfe3b0f8c1f&width=1311" alt="image.png"><br>相比4G核心网来说主要是架构及内部协议层面：</p></li><li><p>5G核心网架构发生比较大的变化，引入NRF设备用于网络设备的注册与发现</p></li><li><p>网元间协议由原来的diamter换为http2</p></li><li><p>用户面与控制面解耦，为UPF下沉提供支持</p></li><li><p>控制面协议有s1-ap改为ngap</p></li><li><p>用户面协议增加扩展头</p><h3 id="2-2-5G数据面传输协议"><a href="#2-2-5G数据面传输协议" class="headerlink" title="2.2 5G数据面传输协议"></a>2.2 5G数据面传输协议</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627264248595-2f3b2b36-3484-4192-8db4-4e7f92f22244.png#clientId=uc9b4fbe8-9b07-4&from=paste&height=442&id=JzhxG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=884&originWidth=1616&originalType=binary&ratio=1&size=356332&status=done&style=none&taskId=u8a1ff3c9-934e-401d-b210-104bcf61da3&width=808" alt="image.png"><br> 5G网络中UPF设备主要用于用户面数据的转发，主要功能是流量控制以及GTP包的拆解包。<br> <a href="https://github.com/5GOpenUPF/openupf">https://github.com/5GOpenUPF/openupf</a></p><h2 id="3-5G网络重要特性"><a href="#3-5G网络重要特性" class="headerlink" title="3.5G网络重要特性"></a>3.5G网络重要特性</h2></li></ul><h3 id="3-1-网络切片"><a href="#3-1-网络切片" class="headerlink" title="3.1 网络切片"></a>3.1 网络切片</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627314856942-e617a4e3-30d1-4266-80aa-4d934b76c028.png#clientId=ua70594ae-1f25-4&from=paste&height=463&id=u5f84f5cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=463&originWidth=823&originalType=binary&ratio=1&size=139413&status=done&style=none&taskId=ud0943c7d-036a-458b-abb2-57a8b2a6be8&width=823" alt="image.png"><br>5G网络基于三大业务场景的网络切片，使切片场景更加多样化。</p><ul><li>eMBB，提供大带宽流量通道，主要是借助无线侧提升带宽上限。</li><li>uRLLC，提供低时延网络，主要借助边缘网络进行边缘计算降低端到端网络距离。</li><li>mMTC，提供大规模机器通信，及4G中NB-IOT规范在制定中预计R16版本制定。现在采用4G核心网eLTE增强实现。</li></ul><p>切片实现基于核心网信令侧提供切片标识传输，用户面实现切片能力提供。切片承载标识以NSSAI，SST，SD等作为切片标识。<br>详细可参考：<a href="https://www.yuque.com/wuhao-bo7rr/rb9zmq/epd319">https://www.yuque.com/wuhao-bo7rr/rb9zmq/epd319</a></p><h3 id="3-2-边缘计算"><a href="#3-2-边缘计算" class="headerlink" title="3.2 边缘计算"></a>3.2 边缘计算</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627314921136-6ca8027e-9ccb-4106-907a-7a849ed2feea.png#clientId=ua70594ae-1f25-4&from=paste&height=466&id=u9cccc87f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=466&originWidth=807&originalType=binary&ratio=1&size=108543&status=done&style=none&taskId=u5071bf83-230e-480a-8be6-78d87f3a5d7&width=807" alt="image.png"></p><ul><li><p>概述</p><p>   边缘计算在靠近数据源或用户的地方提供计算、存储等基础设施，并为边缘应用提供云服务和 IT 环境服务。相比于集中部署的云计算服务，边缘计算解决了时延过长、汇聚流量过大等问题，为实时性和带宽密集型业务提供更好的支持。随着 5G 和工业互联网的快速发展，新兴业务对边缘计算的需求十分迫切。在众多垂直行业新兴业务中，对边缘计算的需求主要体现在时延、带宽和安全三个方面。</p></li><li><p>实现</p><ul><li>UPF 地址下发可采用 NRF(5G 网络注册设备)获取或 OAM(系统配置)配置</li><li>通过 5G 核心网配置及 SMF 下发 UPF 地址实现 UPF 地址的下沉</li></ul></li><li><p>示例</p><pre><code> 以移动边缘计算平台为例主要涵盖</code></pre><ul><li>边缘设备管理</li></ul></li></ul><p>支持纳管不同算力、不同平台的边缘节点，实现对边缘节点和终端设备进行管理，如：状态监控、资源调度、日志查询等</p><ul><li>边缘协议适配</li></ul><p>边缘计算通过驱动方式灵活支持多种工业协议设备接入，原生支持MQTT、OPC-UA、Modbus协议设备接入</p><ul><li>边缘应用管理</li></ul><p>边缘应用市场提供预置边缘容器应用，也可进行自定义应用开发，并支持下发至边缘节点运行，云端可对应用进行全生命周期管理</p><ul><li>边缘数据路由</li></ul><p>支持将边缘节点数据通过灵活的方式路由到OneNET云端。并可以通过云端再分发到其他PaaS服务或客户自有应用</p><ul><li>边缘规则计算</li></ul><p>支持在边缘节点进行规则引擎计算，按照既定规则进行匹配，若匹配成功后则按照相关预定动作执行</p><ul><li>边缘数据存储</li></ul><p>支持在边缘节点进行多并发的海量时序列数据库存储，并在断网的情况自动实现离线存储</p><ul><li>边缘数据分析</li></ul><p>基于flink计算引擎，实现在云端通过可视化的方式配置计算任务，再下发到边缘节点执行</p><ul><li>边缘智能推理</li></ul><p>通过预置应用方式，将针对特定行业和场景的AI模型下发至边缘节点进行推理</p><ul><li>参考<ul><li>移动边缘计算平台：<a href="https://open.iot.10086.cn/productservice/edge/">https://open.iot.10086.cn/productservice/edge/</a></li><li>5G开源边缘计算平台<a href="https://gitee.com/edgegallery">https://gitee.com/edgegallery</a><h2 id="4-关键技术点解析"><a href="#4-关键技术点解析" class="headerlink" title="4.关键技术点解析"></a>4.关键技术点解析</h2></li></ul></li></ul><h3 id="4-1-无线侧增强"><a href="#4-1-无线侧增强" class="headerlink" title="4.1 无线侧增强"></a>4.1 无线侧增强</h3><p>各网络速率对比</p><table><thead><tr><th><strong>网络制式</strong></th><th><strong>2G</strong></th><th><strong>3G</strong></th><th><strong>4G</strong></th><th><strong>5G</strong></th></tr></thead><tbody><tr><td>下行速率</td><td>150K</td><td>2.8Mbps</td><td>100Mbps</td><td>1.54Gbps</td></tr><tr><td>上行速率</td><td>40K</td><td>384Kbps</td><td>50Mbps</td><td>308Mbps</td></tr></tbody></table><p></p><ul><li>5G网速计算公式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627436031283-5e53d4dd-39d5-4740-82f8-cdf52a84acd9.png#clientId=u79b8274a-e51d-4&from=paste&id=ue0563563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=218&originWidth=1080&originalType=url&ratio=1&size=81090&status=done&style=none&taskId=u3b85cb7d-8ed8-4535-b791-18ba1cf2a1f" alt="image.png"><br>△ 5G载波的峰值计算公式</p><ul><li><strong>MIMO层数</strong>：下行4层，上行2层。</li><li><strong>调制阶数</strong>：下行8阶（256QAM），上行6阶（64QAM）。</li><li><strong>编码码率</strong>：948/1024≈0.926。</li><li><strong>PRB个数</strong>：273，公式里面的12代表每个PRB包含12个子载波。</li><li><strong>资源开销占比</strong>意为无线资源中用作控制，不能用来发送数据的比例，协议给出了典型的数据：下行14%，上行8%。</li><li><strong>符号数</strong>意为每秒可实际传送数据的符号个数，因不同的TDD帧结构而异，具体可参考前面第二部分的表格。现取2.5毫秒双周期帧结构的值：下行18400，上行9200。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627436031455-2bed1bb5-ee54-4d95-9ebf-3013930858fb.png#clientId=u79b8274a-e51d-4&from=paste&id=ufe3b5631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=640&originalType=url&ratio=1&size=124474&status=done&style=none&taskId=uc5a75f46-1a74-4f37-8c4b-4ead672b9ec" alt="image.png"><br>△ 5G载波的峰值计算因素图示<br>把上述数据代入前面的公式，可得：</p><ul><li><strong>下行峰值速率为：1.54Gbps</strong></li><li><strong>上行峰值速率为：308Mbps</strong></li></ul><p>现在电信和联通正在共享3.5GHz频段上的100MHz的带宽，单个手机能达到的理论速率就是上述的两个值。如果这两家后续开通200MHz的话，因为带宽翻倍，速率也将翻倍，下行速率可以高达3.08Gbps！<br>详细可参考：<a href="https://zhuanlan.zhihu.com/p/108553808">https://zhuanlan.zhihu.com/p/108553808</a><br>​</p><ul><li>4G理论网速</li></ul><p>**     LTE-Advanced（长期演进技术升级版）：**<br>     LTE的升级演进，由3GPP所主导制定，完全向后兼容LTE，通常通过在LTE上通过软件升级即可，升级过程类似于从W-CDMA升级到HSPA。峰值速率：下行1Gbps，上行500Mbps。是第一批被国际电信联盟承认的4G标准，也是事实上的唯一主流4G标准。另有TD-LTE的升级演进TD-LTE-Advanced（TD-LTE-A）。<br>**     LTE FDD（频分双工长期演进技术）：**<br>     最早提出的LTE制式，目前该技术最成熟，全球应用最广泛，终端种类最多[5]。峰值速率：下行150Mbps，上行40Mbps。<br>**     LTE TDD（时分双工长期演进技术）：**<br>     又称TD-LTE，是LTE的另一个分支。峰值速率：下行100Mbps，上行50Mbps。由上海贝尔、诺基亚西门子通信、大唐电信、华为技术、中兴通信、中国移动、高通、ST-Ericsson等业者共同开发。<br>**     WirelessMAN-Advanced（无线城域网升级版）：**<br>     又称WiMAX-Advanced、WiMAX 2，即IEEE 802.16m是WiMAX的升级演进，由IEEE所主导制定，接收下行与上行最高速率可达到100Mbps，在静止定点接收可高达1Gbps。也是国际电信联盟承认的4G标准，不过随着Intel于2010年退出，WiMAX技术也已经被运营商放弃，并开始将设备升级为TD-LTE。</p><table><thead><tr><th>运营商</th><th>上行(MHz)</th><th>下行(MHz)</th><th>上行速率(bps)</th><th>下行速率(bps)</th></tr></thead><tbody><tr><td>中国电信</td><td>2370～2390</td><td><em>2635～2655</em></td><td>50M</td><td>100M</td></tr><tr><td>中国移动</td><td>2300～2320</td><td>2555～2575</td><td>50M</td><td>100M</td></tr><tr><td>中国联通</td><td><em>1880～1900、2320～2370</em></td><td><em>2575～2635</em></td><td>50M</td><td>100M</td></tr></tbody></table><p>详细可参考：<a href="https://zh.wikipedia.org/wiki/4G">https://zh.wikipedia.org/wiki/4G</a></p><ul><li><p>3G理论网速</p><p>  3G理论网速为1-6Mbps，折合下载速度120K/s-600K/s；是指支持高速数据传输的蜂窝移动通讯技    术。3G服务能够同时传送声音及数据信息，速率一般在几百kbps以上；</p></li></ul><table><thead><tr><th>运营商</th><th>上行(MHz)</th><th>下行(MHz)</th><th>上行速率(bps)</th><th>下行速率(bps)</th><th>调制方式</th></tr></thead><tbody><tr><td>CDMA2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>(中国电信)</td><td>825～835</td><td><em>870～880</em></td><td>1.8M</td><td>3.1M</td><td>FDD</td></tr><tr><td>TD-SCDMA</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>(中国移动)</td><td>1880～1920</td><td>2010～2025</td><td>384K</td><td>2.8M</td><td>TDD</td></tr><tr><td>WCDMA</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>(中国联通)</td><td><em>1920-1980</em></td><td><em>2110～2170</em></td><td>5.76M</td><td>7.2M</td><td>FDD</td></tr></tbody></table><p>详细可参考：<a href="https://zh.wikipedia.org/wiki/3G">https://zh.wikipedia.org/wiki/3G</a></p><ul><li><p>2G理论网速</p><p>   2G理论网速是150Kbps，折合下载速度15-20K/s；2G是第二代手机通信技术规格，以数字语音传输技术为核心。一般定义为无法直接传送如电子邮件、软件等信息；只具有通话和一些如时间日期等传送的手机通信技术规格；</p></li></ul><table><thead><tr><th>运营商</th><th>制式</th><th>上行速率(bps)</th><th>下载速率(bps)</th><th>理论峰值(bps)</th><th>带宽</th></tr></thead><tbody><tr><td>移动</td><td>GPRS</td><td><em>21.4K</em></td><td>85.6K</td><td>171.2K</td><td>150K</td></tr><tr><td></td><td>EDGE</td><td>45K</td><td>90K</td><td>384K</td><td>200K</td></tr><tr><td>联通</td><td><em>GPRS</em></td><td><em>21.4K</em></td><td>85.6K</td><td>171.2K</td><td>150K</td></tr><tr><td></td><td>EDGE</td><td>45K</td><td>90K</td><td>384K</td><td>200K</td></tr></tbody></table><pre><code>详细可参考：[https://jingyan.baidu.com/article/9158e0009e4708e2541228b4.html](https://jingyan.baidu.com/article/9158e0009e4708e2541228b4.html)其他参考：[https://blog.csdn.net/mao834099514/article/details/79456881](https://blog.csdn.net/mao834099514/article/details/79456881)</code></pre><h3 id="4-2-控制面SCTP协议"><a href="#4-2-控制面SCTP协议" class="headerlink" title="4.2 控制面SCTP协议"></a>4.2 控制面SCTP协议</h3><ul><li>UDP</li></ul><p>用户数据报协议（_UDP_，User Datagram Protocol）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User Datagram Protocol, Src Port: 5060, Dst Port: 5060</span><br><span class="line">    Source Port: 5060</span><br><span class="line">    Destination Port: 5060</span><br><span class="line">    Length: 356</span><br><span class="line">    Checksum: 0xf8a5 [unverified]</span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    [Stream index: 0]</span><br><span class="line">    [Timestamps]</span><br><span class="line">        [Time since first frame: 0.007303000 seconds]</span><br><span class="line">        [Time since previous frame: 0.007303000 seconds]</span><br><span class="line">    UDP payload (348 bytes)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>TCP</li></ul><p>传输控制协议（_TCP_，Transmission Control Protocol）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Transmission Control Protocol, Src Port: 54872, Dst Port: 6070, Seq: 1, Ack: 1, Len: 3294</span><br><span class="line">    Source Port: 54872</span><br><span class="line">    Destination Port: 6070</span><br><span class="line">    [Stream index: 84]</span><br><span class="line">    [TCP Segment Len: 3294]</span><br><span class="line">    Sequence Number: 1    (relative sequence number)</span><br><span class="line">    Sequence Number (raw): 1324026701</span><br><span class="line">    [Next Sequence Number: 3295    (relative sequence number)]</span><br><span class="line">    Acknowledgment Number: 1    (relative ack number)</span><br><span class="line">    Acknowledgment number (raw): 3153941596</span><br><span class="line">    1000 .... = Header Length: 32 bytes (8)</span><br><span class="line">    Flags: 0x018 (PSH, ACK)</span><br><span class="line">        000. .... .... = Reserved: Not set</span><br><span class="line">        ...0 .... .... = Nonce: Not set</span><br><span class="line">        .... 0... .... = Congestion Window Reduced (CWR): Not set</span><br><span class="line">        .... .0.. .... = ECN-Echo: Not set</span><br><span class="line">        .... ..0. .... = Urgent: Not set</span><br><span class="line">        .... ...1 .... = Acknowledgment: Set</span><br><span class="line">        .... .... 1... = Push: Set</span><br><span class="line">        .... .... .0.. = Reset: Not set</span><br><span class="line">        .... .... ..0. = Syn: Not set</span><br><span class="line">        .... .... ...0 = Fin: Not set</span><br><span class="line">        [TCP Flags: ·······AP···]</span><br><span class="line">    Window: 32748</span><br><span class="line">    [Calculated window size: 32748]</span><br><span class="line">    [Window size scaling factor: -1 (unknown)]</span><br><span class="line">    Checksum: 0x3972 [unverified]</span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    Urgent Pointer: 0</span><br><span class="line">    Options: (12 bytes), No-Operation (NOP), No-Operation (NOP), Timestamps</span><br><span class="line">        TCP Option - No-Operation (NOP)</span><br><span class="line">            Kind: No-Operation (1)</span><br><span class="line">        TCP Option - No-Operation (NOP)</span><br><span class="line">            Kind: No-Operation (1)</span><br><span class="line">        TCP Option - Timestamps: TSval 919902009, TSecr 919895231</span><br><span class="line">            Kind: Time Stamp Option (8)</span><br><span class="line">            Length: 10</span><br><span class="line">            Timestamp value: 919902009</span><br><span class="line">            Timestamp echo reply: 919895231</span><br><span class="line">    [SEQ/ACK analysis]</span><br><span class="line">        [Bytes in flight: 3294]</span><br><span class="line">        [Bytes sent since last PSH flag: 3294]</span><br><span class="line">    [Timestamps]</span><br><span class="line">        [Time since first frame in this TCP stream: 0.000000000 seconds]</span><br><span class="line">        [Time since previous frame in this TCP stream: 0.000000000 seconds]</span><br><span class="line">    TCP payload (3294 bytes)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细参考：<a href="https://segmentfault.com/a/1190000022410446">https://segmentfault.com/a/1190000022410446</a><br>​</p><ul><li>SCTP</li></ul><p>流控制传输协议SCTP(Stream Control Transmission Protocol)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Stream Control Transmission Protocol, Src Port: 38412 (38412), Dst Port: 38412 (38412)</span><br><span class="line">    Source port: 38412</span><br><span class="line">    Destination port: 38412</span><br><span class="line">    Verification tag: 0x0491fd24</span><br><span class="line">    [Association index: 65535]</span><br><span class="line">    Checksum: 0xc759d633 [unverified]</span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    DATA chunk(ordered, complete segment, TSN: 39, SID: 1, SSN: 33, PPID: 60, payload length: 67 bytes)</span><br><span class="line">        Chunk type: DATA (0)</span><br><span class="line">        Chunk flags: 0x03</span><br><span class="line">            .... 0... = I-Bit: Possibly delay SACK</span><br><span class="line">            .... .0.. = U-Bit: Ordered delivery</span><br><span class="line">            .... ..1. = B-Bit: First segment</span><br><span class="line">            .... ...1 = E-Bit: Last segment</span><br><span class="line">        Chunk length: 83</span><br><span class="line">        Transmission sequence number: 39</span><br><span class="line">        Stream identifier: 0x0001</span><br><span class="line">        Stream sequence number: 33</span><br><span class="line">        Payload protocol identifier: NGAP (60)</span><br><span class="line">        Chunk padding: 00</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细参考：<br><a href="https://zhuanlan.zhihu.com/p/67819220">https://zhuanlan.zhihu.com/p/67819220</a></p><table><thead><tr><th>协议</th><th>安全可靠</th><th>小包传输</th><th>大包传输</th><th>生态健全</th><th>成熟度</th></tr></thead><tbody><tr><td>UDP</td><td>*</td><td>***</td><td>***</td><td>***</td><td>***</td></tr><tr><td>TCP</td><td>**</td><td>**</td><td>*</td><td>***</td><td>***</td></tr><tr><td>SCTP</td><td>***</td><td>*</td><td>**</td><td>*</td><td>**</td></tr></tbody></table><h3 id="4-3-网络转发"><a href="#4-3-网络转发" class="headerlink" title="4.3 网络转发"></a>4.3 网络转发</h3><p>常见的网路转发技术分为用户态转发技术、内核态转发技术、UIO旁路转发技术，之外还有交换芯片之类的这里不做过多介绍，下面主要介绍用户态、内核态、UIO旁路转发。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627486246857-f858f9dc-8420-4b98-ac89-c121eb17d689.png#clientId=u591ad28a-e8ae-4&from=paste&height=490&id=u00a5d948&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=781&originalType=binary&ratio=1&size=157286&status=done&style=none&taskId=u0140e34b-eeb4-411b-be4f-ae0fb9980d5&width=719.5" alt="image.png"><br>在转发速率，难度及趋势上做了相关对比</p><table><thead><tr><th>类型</th><th>用户态</th><th>内核态</th><th>DPDK</th></tr></thead><tbody><tr><td>速度</td><td>*</td><td>**</td><td>***</td></tr><tr><td>开发难度</td><td>*</td><td>***(不小心把内核态搞崩)</td><td>**</td></tr><tr><td>周边工具</td><td>***</td><td>***</td><td><em>(借助VPP可以达到</em>**)</td></tr><tr><td>社区趋势</td><td>*</td><td>*</td><td>***</td></tr></tbody></table><p>综上所述DPDK基本是网络转发技术主流。<br><a href="https://www.yuque.com/wuhao-bo7rr/rb9zmq/ak1moi">https://www.yuque.com/wuhao-bo7rr/rb9zmq/ak1moi</a></p><h2 id="5-主要业务流程"><a href="#5-主要业务流程" class="headerlink" title="5.主要业务流程"></a>5.主要业务流程</h2><pre><code> 商用手机终端入网，基站握手、核心网注册、IMS注册为必须项，只完成核心网注册，未完成IMS注册手机会自动掉线。</code></pre><h3 id="5-1-基站建联"><a href="#5-1-基站建联" class="headerlink" title="5.1 基站建联"></a>5.1 基站建联</h3><p>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627391179070-5ef19fd6-cdfe-4031-916b-eb11aeb0b808.png#clientId=ue276c832-69f5-4&from=paste&height=717&id=HCRzI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=829&originWidth=554&originalType=binary&ratio=1&size=123452&status=done&style=none&taskId=u63efdef9-43bd-4448-bd6f-f594e8d09ea&width=479" alt="image.png"><br>手机与基站建联主要流程可以归结为：</p><ul><li>小区搜索与选择</li></ul><p>UE开机选网，小区搜索并完成下行同步。</p><ul><li>系统消息广播</li></ul><p>UE读取广播信息，选择合适小区进行驻留。</p><ul><li>随机接入</li></ul><p>UE与gNB建立上行同步。</p><ul><li>RRC连接建立</li></ul><p>UE与gNB建立RRC连接。</p><ul><li>注册过程</li></ul><p>UE注册到5G网络，网络侧开始维护该UE的上下文。<br>​</p><h3 id="5-2-核心网注册"><a href="#5-2-核心网注册" class="headerlink" title="5.2 核心网注册"></a>5.2 核心网注册</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627391130276-8e26e31c-b637-4803-befc-bd2fe46fce80.png#clientId=ue276c832-69f5-4&from=paste&height=826&id=iKwsM&margin=%5Bobject%20Object%5D&name=image.png&originHeight=826&originWidth=841&originalType=binary&ratio=1&size=228847&status=done&style=none&taskId=u7a19b13a-9c93-4ad6-a382-02ccff8827c&width=841" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627297426188-9d936938-2425-472e-a3d4-bc9f7db313fc.png#clientId=u3fb41919-abb0-4&from=paste&height=220&id=BnpTo&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=1605&originalType=binary&ratio=1&size=184759&status=done&style=none&taskId=u6367eeed-a982-4404-92c4-aa9d3f1fd39&width=1605" alt="image.png"></p><p>整体可归纳为：</p><ul><li>注册请求</li></ul><p>终端携带SIM信息进行注册，核心网通过用户信息在UDM查询数据，以此判断是否需要identity request</p><ul><li><p>鉴权处理</p><pre><code>核心网查询到用户信息后，发起Authentication request，终端收到请求后进行校验，回复Authentication response此时双方共同进行双向鉴权。</code></pre></li><li><p>加密协商</p><pre><code>终端与网络双方为选择加密算法，可选类型为4种，其中第一种为不加密，其余三种为加密算法，加密算法包含完整性保护算法和报文加密算法，分别是为了保护报文的安全性与正确性</code></pre></li><li><p>注册完成</p><pre><code>网络侧返回注册完成，网络侧会携带网络能力告知终端。比如4G回落，IP短信能力。</code></pre></li><li><p>无线能力上报</p><pre><code>终端上报无线能力，终端上报无线能力至服务端，此信令为非必须应答信令</code></pre></li><li><p>会话创建</p><pre><code>终端创建流量传输通道，核心网在网络侧分配网络资源，此处一般会创建两个会话通道一个是IMS用来发短信打电话，一个是internet用来上网。由于IMS网络与Internet网络隔离这就是为什么在人多的地方有的时候网速慢打电话确没有影响。</code></pre></li><li><p>IMS注册</p><pre><code>终端完成会话通道创建后，会发起sip注册，商用终端必须完成sip注册后才可进行上网，这个原因大概是上网功能与ims功能为运营商基础能力，都需要完成后才算入网完成，手机层面表现为，出现HD为IMS网络注册完成。</code></pre><p>详细可参考：<a href="https://www.yuque.com/wuhao-bo7rr/rb9zmq/gv4tpd">https://www.yuque.com/wuhao-bo7rr/rb9zmq/gv4tpd</a></p><h3 id="5-3-IMS注册"><a href="#5-3-IMS注册" class="headerlink" title="5.3 IMS注册"></a>5.3 IMS注册</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627393550010-ab490608-c0aa-415c-8aa2-35749258d676.png#clientId=ue276c832-69f5-4&from=paste&height=614&id=iOBZl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=691&originWidth=704&originalType=binary&ratio=1&size=72864&status=done&style=none&taskId=ucd354c72-30eb-4676-b873-8e303c3f0cd&width=626" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627487171816-e2da3602-ee5c-4e68-b644-12bb3e575d29.png#clientId=u591ad28a-e8ae-4&from=paste&height=103&id=u801e3236&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=2832&originalType=binary&ratio=1&size=179904&status=done&style=none&taskId=u4579b25f-b3f9-4e2b-b287-cee9c146a5e&width=1416" alt="image.png"></p><h3 id="5-4-短信发送"><a href="#5-4-短信发送" class="headerlink" title="5.4 短信发送"></a>5.4 短信发送</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627393585310-6f9ba81e-d9fb-4245-80cf-c83aa7588bc3.png#clientId=ue276c832-69f5-4&from=paste&height=698&id=R2dku&margin=%5Bobject%20Object%5D&name=image.png&originHeight=698&originWidth=1145&originalType=binary&ratio=1&size=97410&status=done&style=none&taskId=ua3fd77d1-9e57-466e-a4f7-f3d3286a9ab&width=1145" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627487350302-314d17cd-fd39-4330-ba7e-eced2c55f0db.png#clientId=u591ad28a-e8ae-4&from=paste&height=79&id=u9eea8836&margin=%5Bobject%20Object%5D&name=image.png&originHeight=158&originWidth=2706&originalType=binary&ratio=1&size=91621&status=done&style=none&taskId=ua89d6db6-03e6-400f-9f25-a6f88a2d590&width=1353" alt="image.png"></p><h3 id="5-5-语音呼叫"><a href="#5-5-语音呼叫" class="headerlink" title="5.5 语音呼叫"></a>5.5 语音呼叫</h3></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627470940752-974ccafb-9a9f-4493-b685-fc011492c598.png#clientId=u483e4c72-e2ee-4&from=drop&id=uae785ddf&margin=%5Bobject%20Object%5D&name=%E4%B8%8B%E8%BD%BD%20%283%29.png&originHeight=1215&originWidth=1277&originalType=binary&ratio=1&size=133973&status=done&style=none&taskId=ua18dae18-1f40-42d0-8acd-04779ad4c05" alt="下载 (3).png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627471023385-85c0acc3-4b59-45fc-bca4-abf99963f673.png#clientId=u483e4c72-e2ee-4&from=paste&height=250&id=u01d42343&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=1286&originalType=binary&ratio=1&size=234005&status=done&style=none&taskId=ue1c25eb8-003d-44f7-ac45-24f1c730440&width=1286" alt="image.png"><br>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;5G网络概述&quot;&gt;&lt;a href=&quot;#5G网络概述&quot; class=&quot;headerlink&quot; title=&quot;5G网络概述&quot;&gt;&lt;/a&gt;5G网络概述&lt;/h1&gt;&lt;h2 id=&quot;1-网络架构&quot;&gt;&lt;a href=&quot;#1-网络架构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="5G" scheme="http://example.com/categories/5G/"/>
    
    
    <category term="5G" scheme="http://example.com/tags/5G/"/>
    
    <category term="MEC" scheme="http://example.com/tags/MEC/"/>
    
    <category term="网络切片" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%88%87%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>java字节码增强</title>
    <link href="http://example.com/2021/08/04/language/java/bytecode/java%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/"/>
    <id>http://example.com/2021/08/04/language/java/bytecode/java%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/</id>
    <published>2021-08-04T06:25:13.668Z</published>
    <updated>2021-08-04T06:25:13.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-字节码增强探秘"><a href="#Java-字节码增强探秘" class="headerlink" title="Java 字节码增强探秘"></a>Java 字节码增强探秘</h2><h3 id="1-字节码"><a href="#1-字节码" class="headerlink" title="1.字节码"></a>1.字节码</h3><h4 id="1-1-什么是字节码？"><a href="#1-1-什么是字节码？" class="headerlink" title="1.1 什么是字节码？"></a>1.1 什么是字节码？</h4><p>Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，<br>都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。因此，也可以看出字节码对于 Java 生态的重要性。<br>之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取。<br>在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个.java 文件从编译到运行的示例如图 1 所示。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXqfPalgmiaaEZfk4KZOLicKFDrLKCYe5sPz3eKut7ryeKrerKgBPLaFQamge0TibUBpIjicibpucrO5Lg/640"></p><p>对于开发人员，了解字节码可以更准确、直观地理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观地看到 Volatile 关键字如何在字节码上生效。<br>另外，字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于 JVM 规范的存在，<br>只要最终可以生成符合规范的字节码就可以在 JVM 上运行，因此这就给了各种运行在 JVM 上的语言（如 Scala、Groovy、Kotlin）一种契机，<br>可以扩展 Java 所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。<br>本文重点着眼于字节码增强技术，从字节码开始逐层向上，由 JVM 字节码操作集合到 Java 中操作字节码的框架，再到我们熟悉的各类框架原理及应用，也都会一一进行介绍。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java-字节码增强探秘&quot;&gt;&lt;a href=&quot;#Java-字节码增强探秘&quot; class=&quot;headerlink&quot; title=&quot;Java 字节码增强探秘&quot;&gt;&lt;/a&gt;Java 字节码增强探秘&lt;/h2&gt;&lt;h3 id=&quot;1-字节码&quot;&gt;&lt;a href=&quot;#1-字节码&quot; c</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="字节码" scheme="http://example.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>bytebuddy介绍</title>
    <link href="http://example.com/2021/08/04/language/java/bytecode/bytebuddy-code/"/>
    <id>http://example.com/2021/08/04/language/java/bytecode/bytebuddy-code/</id>
    <published>2021-08-04T06:25:13.667Z</published>
    <updated>2021-08-04T06:25:13.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节码增强技术-Byte-Buddy"><a href="#字节码增强技术-Byte-Buddy" class="headerlink" title="字节码增强技术-Byte Buddy"></a>字节码增强技术-Byte Buddy</h1><h2 id="1-为什么需要在运行时生成代码？"><a href="#1-为什么需要在运行时生成代码？" class="headerlink" title="1.为什么需要在运行时生成代码？"></a>1.为什么需要在运行时生成代码？</h2><p>Java 是一个强类型语言系统，要求变量和对象都有一个确定的类型，不兼容类型赋值都会造成转换异常，通常情况下这种错误都会被编译器检查出来，<br>如此严格的类型在大多数情况下是比较令人满意的，这对构建具有非常强可读性和稳定性的应用有很大的帮助，这也是 Java 能在企业编程中的普及的一个原因之一。<br>然而，因为起强类型的检查，限制了其他领域语言应用范围。比如在编写一个框架是，通常我们并不知道应用程序定义的类型，因为当这个库被编译时， 我们还不知道这些类型，为了能在这种情况下能调用或者访问应用程序的方法或者变量，Java<br>类库提供了一套反射 API。使用这套反射 API， 我们就可以反省为知类型，进而调用方法或者访问属性。但是，Java 反射有如下缺点：</p><ul><li>需要执行一个相当昂贵的方法查找来获取描述特定方法的对象，因此，相比硬编码的方法调用，使用 反射 API 非常慢。</li><li>反射 API 能绕过类型安全检查，可能会因为使用不当照成意想不到的问题，这样就错失了 Java 编程语言的一大特性。</li></ul><h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h2><p>正如官网说的：Byte Buddy 是一个代码生成和操作库，用于在Java应用程序运行时创建和修改Java类，而无需编译器的帮助。 除了Java类库附带的代码生成实用程序外，Byte<br>Buddy还允许创建任意类，并且不限于实现用于创建运行时代理的接口。 此外，Byte Buddy提供了一种方便的API，可以使用Java代理或在构建过程中手动更改类。Byte Buddy 相比其他字节码操作库有如下优势：</p><ul><li>无需理解字节码格式，即可操作，简单易行的 API 能很容易操作字节码。</li><li>支持 Java 任何版本，库轻量，仅取决于Java字节代码解析器库ASM的访问者API，它本身不需要任何其他依赖项。</li><li>比起JDK动态代理、cglib、Javassist，Byte Buddy在性能上具有优势。</li></ul><h3 id="3-性能"><a href="#3-性能" class="headerlink" title="3.性能"></a>3.性能</h3><p>在选择字节码操作库时，往往需要考虑库本身的性能。对于许多应用程序，生成代码的运行时特性更有可能确定最佳选择。而 在生成的代码本身的运行时间之外，用于创建动态类的运行时也是一个问题。官网对库进行了性能测试，给出以下结果图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/13/16dc4ade119d5610?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>图中的每一行分别为，类的创建、接口实现、方法调用、类型扩展、父类方法调用的性能结果。 从性能报告中可以看出，Byte Buddy 的主要侧重点在于以最少的运行时生成代码，需要注意的是，我们这些衡量 Java 代码性能的测试， 都由 Java<br>虚拟机即时编译器优化过，如果你的代码只是偶尔运行，没有得到虚拟机的优化，可能性能会有所偏差。 所以我们在使用 Byte Buddy 开发时，我们希望监控这些指标，以避免在添加新功能时造成性能损失。</p><h2 id="4-Hello-world代码"><a href="#4-Hello-world代码" class="headerlink" title="4.Hello world代码"></a>4.Hello world代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class="line">                .subclass(Object.class)</span><br><span class="line">                .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class="line">                .intercept(FixedValue.value(&quot;Hello World&quot;))</span><br><span class="line">                .make()</span><br><span class="line">                .load(HelloWorldBuddy.class.getClassLoader())</span><br><span class="line">                .getLoaded();</span><br><span class="line"></span><br><span class="line">        Object instance = dynamicType.newInstance();</span><br><span class="line">        String toString = instance.toString();</span><br><span class="line">        System.out.println(toString);</span><br><span class="line">        System.out.println(instance.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure><p>从例子中看到，操作创建一个类如此的简单。正如 ByteBuddy 说明的，ByteBuddy 提供了一个领域特定语言，这样就可以尽可能地提高人类可读性简单易行的 API， 可能能让你在初次使用的过程中就能不需要查阅 API<br>的前提下完成编码。这也真是 ByteBuddy 能完爆其他同类型库的一个原因。 上面的示例中使用的默认ByteBuddy配置会以最新版本的类文件格式创建Java类，该类文件格式可以被正在处理的Java虚拟机理解。 subclass<br>指定了新创建的类的父类，同时 method 指定了 Object 的 toString 方法，intercept 拦截了 toString 方法并返回固定的 value ， 最后 make 方法生产字节码，有类加载器加载到虚拟机中。<br>此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理， 该代理允许在任何 Java<br>应用程序的运行期间进行代码转换，代理会在下篇单独写一篇文章讲解。</p><h2 id="5-创建一个类"><a href="#5-创建一个类" class="headerlink" title="5.创建一个类"></a>5.创建一个类</h2><p>任何一个由 ByteBuddy 创建的类型都是通过 ByteBuddy 类的实例来完成的。通过简单地调用 new ByteBuddy() 就可以创建一个新实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class="line">    .subclass(Object.class)</span><br><span class="line">    .make();</span><br></pre></td></tr></table></figure><p>上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的 。该列子没有命名动态生成的类型，但是在定义 Java<br>类时却是必须的，所以很容易的你会想到，ByteBuddy 会有默认的策略给我们生成。 当然，你也可以很容易地明确地命名这个类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class="line">.subclass(Object.class)</span><br><span class="line">.name(&quot;example.Type&quot;)</span><br><span class="line">.make();</span><br></pre></td></tr></table></figure><p>那么默认的策略是如何做的呢？这个将与 ByteBuddy 与 约定大于配置息息相关，它提供了我们认为比较全面的默认配置。 至于类型命名，ByteBuddy 的默认配置提供了<br>NamingStrategy，它基于动态类型的超类名称来随机生成类名。 此外，名称定义在与父类相同的包下，这样父类的包级访问权限的方法对动态类型也可见。如果你将示例子类命名为 example.Foo， 那么生成的名称将会类似于<br>example.FooByteBuddy1376491271，这里的数字序列是随机的。</p><p>此外，在一些需要指定类型的场景中，可以通过重写 NamingStrategy 的方法来实现，或者使用 ByteBuddy 内置的NamingStrategy.SuffixingRandom 来实现。</p><p>同时需要注意的是，我们编码时需要遵守所谓的领域特定语言和不变性原则，这是说明意思呢？就是说在 ByteBuddy 中， 几乎所有的类都被构建成不可变的；极少数情况，我们不可能把对象构建成不可变的。请看下面一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuddy byteBuddy = new ByteBuddy();</span><br><span class="line">byteBuddy.with(new NamingStrategy.SuffixingRandom(&quot;suffix&quot;));</span><br><span class="line">DynamicType.Unloaded&lt;?&gt; dynamicType1 = byteBuddy.subclass(Object.class).make();</span><br></pre></td></tr></table></figure><p>上述例子你会发现类的命名策略还是默认的，其根本原因就是没有遵守上述原则导致的。所以在编码过程中要基于此原则进行。</p><h2 id="6-加载类"><a href="#6-加载类" class="headerlink" title="6.加载类"></a>6.加载类</h2><p>上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码， 通过 DynamicType.Unloaded 中的 getBytes<br>方法你可以获取到该字节码，在你的应用程序中， 你可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法， 可以将类存储在给定的文件夹中； inject(File)<br>方法将类注入到现有的 Jar 文件中， 另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。</p><p>如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中</p><p>WRAPPER：创建一个新的Wrapping类加载器 CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类 INJECTION：利用反射机制注入动态类型 示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; type = new ByteBuddy()</span><br><span class="line">.subclass(Object.class)</span><br><span class="line">.make()</span><br><span class="line">.load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)</span><br><span class="line">.getLoaded()</span><br></pre></td></tr></table></figure><p>这样我们创建并加载了一个类。我们使用 WRAPPER 策略来加载适合大多数情况的类。getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类。</p><p>重新加载类 得益于JVM的HostSwap特性，已加载的类可以被重新定义：</p><p>// 安装Byte Buddy的Agent，除了通过-javaagent静态安装，还可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuddyAgent.install();</span><br><span class="line">Foo foo = new Foo();</span><br><span class="line">    new ByteBuddy()</span><br><span class="line">    .redefine(Bar.class)</span><br><span class="line">    .name(Foo.class.getName())</span><br><span class="line">    .make()</span><br><span class="line">    .load(Foo.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());</span><br><span class="line">    assertThat(foo.m(), is(&quot;bar&quot;));</span><br></pre></td></tr></table></figure><p>可以看到，即使时已经存在的对象，也会受到类Reloading的影响。但是需要注意的是HostSwap具有限制：</p><p>类再重新载入前后，必须具有相同的Schema，也就是方法、字段不能减少（可以增加） 不支持具有静态初始化块的类 修改类 redefine 重定义一个类时，Byte Buddy<br>可以对一个已有的类添加属性和方法，或者删除已经存在的方法实现。新添加的方法，如果签名和原有方法一致，则原有方法会消失。</p><p>rebase 类似于redefine，但是原有的方法不会消失，而是被重命名，添加后缀 $original，这样，就没有实现会被丢失。重定义的方法可以继续通过它们重命名过的名称调用原来的方法，例如类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    String bar() &#123; return &quot;bar&quot;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rebase 之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    String bar() &#123; return &quot;foo&quot; + bar$original(); &#125;</span><br><span class="line">    private String bar$original() &#123; return &quot;bar&quot;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-方法拦截"><a href="#7-方法拦截" class="headerlink" title="7.方法拦截"></a>7.方法拦截</h2><p>通过匹配模式拦截 ByteBuddy 提供了很多用于匹配方法的 DSL，如下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Foo dynamicFoo = new ByteBuddy()</span><br><span class="line">    .subclass(Foo.class)</span><br><span class="line">    // 匹配由Foo.class声明的方法</span><br><span class="line">    .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(&quot;One!&quot;))</span><br><span class="line">    // 匹配名为foo的方法</span><br><span class="line">    .method(named(&quot;foo&quot;)).intercept(FixedValue.value(&quot;Two!&quot;))</span><br><span class="line">    // 匹配名为foo，入参数量为1的方法</span><br><span class="line">    .method(named(&quot;foo&quot;).and(takesArguments(1))).intercept(FixedValue.value(&quot;Three!&quot;))</span><br><span class="line">    .make()</span><br><span class="line">    .load(getClass().getClassLoader())</span><br><span class="line">    .getLoaded()</span><br><span class="line">    .newInstance();</span><br></pre></td></tr></table></figure><p>ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略。库本身提供的 Matcher 非常多。Uploading file…</p><h2 id="8-方法委托"><a href="#8-方法委托" class="headerlink" title="8.方法委托"></a>8.方法委托</h2><p>使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Source &#123;</span><br><span class="line">    public String hello(String name) &#123; return null; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Target &#123;</span><br><span class="line">    public static String hello(String name) &#123;</span><br><span class="line">        return &quot;Hello &quot; + name + &quot;!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String helloWorld = new ByteBuddy()</span><br><span class="line">    .subclass(Source.class)</span><br><span class="line">    .method(named(&quot;hello&quot;)).intercept(MethodDelegation.to(Target.class))</span><br><span class="line">    .make()</span><br><span class="line">    .load(getClass().getClassLoader())</span><br><span class="line">    .getLoaded()</span><br><span class="line">    .newInstance()</span><br><span class="line">    .hello(&quot;World&quot;);</span><br></pre></td></tr></table></figure><p>其中 Target 还可以如下实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Target &#123;</span><br><span class="line">    public static String intercept(String name) &#123; return &quot;Hello &quot; + name + &quot;!&quot;; &#125;</span><br><span class="line">    public static String intercept(int i) &#123; return Integer.toString(i); &#125;</span><br><span class="line">    public static String intercept(Object o) &#123; return o.toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：</p><p>intercept(int)因为参数类型不匹配，直接Pass 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它 同时需要注意的是被拦截的方法需要声明为<br>public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RuntimeType</span><br><span class="line">public static Object intercept(@RuntimeType Object value) &#123;</span><br><span class="line">    System.out.println(&quot;Invoked method with: &quot; + value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-参数绑定"><a href="#9-参数绑定" class="headerlink" title="9.参数绑定"></a>9.参数绑定</h2><p>可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void intercept(Object o1, Object o2)</span><br><span class="line">// 等同于</span><br><span class="line">void intercept(@Argument(0) Object o1, @Argument(1) Object o2)复制代码</span><br><span class="line">常用的注解如下表：</span><br></pre></td></tr></table></figure><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Argument</td><td>绑定单个参数</td></tr><tr><td>@AllArguments</td><td>绑定所有参数的数组</td></tr><tr><td>@This</td><td>当前被拦截的、动态生成的那个对象</td></tr><tr><td>@DefaultCall</td><td>调用默认方法而非super的方法</td></tr><tr><td>@SuperCall</td><td>用于调用父类版本的方法</td></tr><tr><td>@RuntimeType</td><td>可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</td></tr><tr><td>@Super</td><td>当前被拦截的、动态生成的那个对象的父类对象</td></tr><tr><td>@FieldValue</td><td>注入被拦截对象的一个字段的值</td></tr></tbody></table><h2 id="10-字段属性"><a href="#10-字段属性" class="headerlink" title="10.字段属性"></a>10.字段属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class UserType &#123;</span><br><span class="line">  public String doSomething() &#123; return null; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Interceptor &#123;</span><br><span class="line">  String doSomethingElse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface InterceptionAccessor &#123;</span><br><span class="line">  Interceptor getInterceptor();</span><br><span class="line">  void setInterceptor(Interceptor interceptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface InstanceCreator &#123;</span><br><span class="line">  Object makeInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloWorldInterceptor implements Interceptor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public String doSomethingElse() &#123;</span><br><span class="line">    return &quot;Hello World!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends UserType&gt; dynamicUserType = new ByteBuddy()</span><br><span class="line">  .subclass(UserType.class)</span><br><span class="line">    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法</span><br><span class="line">    .intercept(MethodDelegation.toField(&quot;interceptor&quot;)) // 拦截委托给属性字段 interceptor</span><br><span class="line">  .defineField(&quot;interceptor&quot;, Interceptor.class, Visibility.PRIVATE) // 定义一个属性字段</span><br><span class="line">  .implement(InterceptionAccessor.class).intercept(FieldAccessor.ofBeanProperty()) // 实现 InterceptionAccessor 接口</span><br><span class="line">  .make()</span><br><span class="line">  .load(getClass().getClassLoader())</span><br><span class="line">  .getLoaded();</span><br><span class="line">    </span><br><span class="line">InstanceCreator factory = new ByteBuddy()</span><br><span class="line">  .subclass(InstanceCreator.class)</span><br><span class="line">    .method(not(isDeclaredBy(Object.class))) // 非父类 Object 声明的方法</span><br><span class="line">    .intercept(MethodDelegation.toConstructor(dynamicUserType)) // 委托拦截的方法来调用提供的类型的构造函数</span><br><span class="line">  .make()</span><br><span class="line">  .load(dynamicUserType.getClassLoader())</span><br><span class="line">  .getLoaded().newInstance();</span><br><span class="line"></span><br><span class="line">UserType userType = (UserType) factory.makeInstance();</span><br><span class="line">((InterceptionAccessor) userType).setInterceptor(new HelloWorldInterceptor());</span><br><span class="line">String s = userType.doSomething();</span><br><span class="line">System.out.println(s); // Hello World!</span><br></pre></td></tr></table></figure><p>上述例子将 UserType 类实现了 InterceptionAccessor 接口，同时使用 MethodDelegation.toField 可以使拦截的方法可以委托给新增的字段。</p><ul><li>代码参考:<br><a href="https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li></ul><h2 id="11-参考"><a href="#11-参考" class="headerlink" title="11.参考"></a>11.参考</h2><p><a href="https://juejin.cn/post/6844903965553852423">https://juejin.cn/post/6844903965553852423</a><br><a href="https://www.cnblogs.com/yungyu16/p/13167240.html">https://www.cnblogs.com/yungyu16/p/13167240.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节码增强技术-Byte-Buddy&quot;&gt;&lt;a href=&quot;#字节码增强技术-Byte-Buddy&quot; class=&quot;headerlink&quot; title=&quot;字节码增强技术-Byte Buddy&quot;&gt;&lt;/a&gt;字节码增强技术-Byte Buddy&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="字节码" scheme="http://example.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>bytebuddy替换类实现</title>
    <link href="http://example.com/2021/08/04/language/java/bytecode/bytebuddy-%E6%9B%BF%E6%8D%A2%E7%B1%BB%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/08/04/language/java/bytecode/bytebuddy-%E6%9B%BF%E6%8D%A2%E7%B1%BB%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-08-04T06:25:13.667Z</published>
    <updated>2021-08-04T06:25:13.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bytebuddy-替换类实现"><a href="#bytebuddy-替换类实现" class="headerlink" title="bytebuddy-替换类实现"></a>bytebuddy-替换类实现</h2><h2 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class="line">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy-agent&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-测试类被替换类"><a href="#2-测试类被替换类" class="headerlink" title="2.测试类被替换类"></a>2.测试类被替换类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class="line"></span><br><span class="line">public class Log &#123;</span><br><span class="line"></span><br><span class="line">    public static void log(String a) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Log: &quot; + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试类替换目的类"><a href="#3-测试类替换目的类" class="headerlink" title="3.测试类替换目的类"></a>3.测试类替换目的类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class="line"></span><br><span class="line">public class Log4j &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注意代理类要和原实现类的方法声明保持一致</span><br><span class="line">     * @param a</span><br><span class="line">     */</span><br><span class="line">    public static void log(String a) &#123;</span><br><span class="line">        System.err.println(&quot;Log4j: &quot; + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-测试验证类"><a href="#4-测试验证类" class="headerlink" title="4.测试验证类"></a>4.测试验证类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.coral.jcode.simple.bytebuddy.reload;</span><br><span class="line"></span><br><span class="line">import net.bytebuddy.ByteBuddy;</span><br><span class="line">import net.bytebuddy.agent.ByteBuddyAgent;</span><br><span class="line">import net.bytebuddy.dynamic.loading.ClassReloadingStrategy;</span><br><span class="line">import net.bytebuddy.implementation.MethodDelegation;</span><br><span class="line">import net.bytebuddy.matcher.ElementMatchers;</span><br><span class="line"></span><br><span class="line">public class LogMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 替换</span><br><span class="line">        ByteBuddyAgent.install();</span><br><span class="line">        new ByteBuddy().redefine(Log.class)</span><br><span class="line">                .method(ElementMatchers.named(&quot;log&quot;))</span><br><span class="line">                .intercept(MethodDelegation.to(Log4j.class))</span><br><span class="line">                .make()</span><br><span class="line">                .load(Thread.currentThread().getContextClassLoader(), ClassReloadingStrategy.fromInstalledAgent());</span><br><span class="line"></span><br><span class="line">        // 调用</span><br><span class="line">        Log.log(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log4j: hello</span><br></pre></td></tr></table></figure><ul><li>代码参考:<br><a href="https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li></ul><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><p><a href="https://houbb.github.io/2019/10/30/bytecode-byte-buddy-02-replace">https://houbb.github.io/2019/10/30/bytecode-byte-buddy-02-replace</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bytebuddy-替换类实现&quot;&gt;&lt;a href=&quot;#bytebuddy-替换类实现&quot; class=&quot;headerlink&quot; title=&quot;bytebuddy-替换类实现&quot;&gt;&lt;/a&gt;bytebuddy-替换类实现&lt;/h2&gt;&lt;h2 id=&quot;1-依赖&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="字节码" scheme="http://example.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>AspectJ使用介绍</title>
    <link href="http://example.com/2021/08/04/language/java/bytecode/aspectj%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/08/04/language/java/bytecode/aspectj%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-08-04T06:25:13.666Z</published>
    <updated>2021-08-04T06:25:13.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-AspectJ-使用介绍"><a href="#1-AspectJ-使用介绍" class="headerlink" title="1.AspectJ 使用介绍"></a>1.AspectJ 使用介绍</h2><p>AspectJ 作为 AOP 编程的完全解决方案，提供了三种织入时机，分别为</p><ul><li>compile-time：编译期织入，在编译的时候一步到位，直接编译出包含织入代码的 .class 文件</li><li>post-compile：编译后织入，增强已经编译出来的类，如我们要增强依赖的 jar 包中的某个类的某个方法</li><li>load-time：在 JVM 进行类加载的时候进行织入</li></ul><h3 id="1-1-编译插桩分类"><a href="#1-1-编译插桩分类" class="headerlink" title="1.1 编译插桩分类"></a>1.1 编译插桩分类</h3><p>编译插桩技术具体可以分为两类，如下所示：</p><ul><li>1）、APT（Annotation Process Tools） ：用于生成 Java 代码。</li><li>2）、AOP（Aspect Oriented Programming）：用于操作字节码。</li></ul><p>我们分别来详细介绍下它们的作用。</p><ul><li><p>1、APT（Annotation Process Tools）<br>总所周知，ButterKnife、Dagger、GreenDao、Protocol Buffers 这些常用的注解生成框架都会在编译过程中生成代码。<br>而 使用 AndroidAnnotation 结合 APT 技术 来生成代码的时机，是在编译最开始的时候介入的。<br>但是 AOP 是在编译完成后生成 dex 文件之前的时候，直接通过修改 .class 文件的方式，来直接添加或者修改代码逻辑的。<br>使用 APT 技术生成 Java 代码的方式具有如下 两方面 的优势：</p><p>1）、隔离了框架复杂的内部实现，使得开发更加地简单高效。<br>2）、大大减少了手工重复的工作量，降低了开发时出错的机率。</p></li><li><p>2、AOP（Aspect Oriented Programming）<br> 而对于操作字节码的方式来说，一般都在 代码监控、代码修改、代码分析 这三个场景有着很广泛的应用。<br> 相对于 Java 代码生成的方式，操作字节码的方式有如下 特点：</p><p>  1）、应用场景更广。<br>  2）、功能更加强大。<br>  3）、使用复杂度较高。</p></li></ul><h2 id="2-依赖引入"><a href="#2-依赖引入" class="headerlink" title="2.依赖引入"></a>2.依赖引入</h2><p>以gradle依赖为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    maven &#123; url &#x27;https://plugins.gradle.org/m2/&#x27; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath group: &#x27;io.freefair.gradle&#x27;, name: &#x27;aspectj-plugin&#x27;, version: &#x27;5.3.3.3&#x27;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: &quot;io.freefair.aspectj&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjweaver&#x27;, version: &#x27;1.9.5&#x27;</span><br><span class="line">  compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjrt&#x27;, version: &#x27;1.9.5&#x27;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>aspectj底层依赖库<ul><li>net.bytebuddy:byte-buddy</li></ul></li></ul><h2 id="3-代码编写"><a href="#3-代码编写" class="headerlink" title="3.代码编写"></a>3.代码编写</h2><ul><li><p>代码地址请参考：<a href="https://github.com/wuhaocn/jcode-simple.git">https://github.com/wuhaocn/jcode-simple.git</a></p></li><li><p>注意下面操作类应放在”src/main/aspectj”包下面</p></li></ul><h3 id="3-1-定义业务类"><a href="#3-1-定义业务类" class="headerlink" title="3.1.定义业务类"></a>3.1.定义业务类</h3><ul><li>Account.java<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line"></span><br><span class="line">    public int balance = 20;</span><br><span class="line"></span><br><span class="line">    public boolean pay(int amount) &#123;</span><br><span class="line">        if (balance &lt; amount) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-定义注解类"><a href="#3-2-定义注解类" class="headerlink" title="3.2.定义注解类"></a>3.2.定义注解类</h3></li><li>AccountAspect.aj<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public aspect AccountAspect &#123;</span><br><span class="line"></span><br><span class="line">    pointcut callPay(int amount, Account account):</span><br><span class="line">            call(boolean com.rcloud.Account.pay(int)) &amp;&amp; args(amount) &amp;&amp; target(account);</span><br><span class="line"></span><br><span class="line">    before(int amount, Account account): callPay(amount, account) &#123;</span><br><span class="line">        System.out.println(&quot;[AccountAspect]付款前总金额: &quot; + account.balance);</span><br><span class="line">        System.out.println(&quot;[AccountAspect]需要付款: &quot; + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean around(int amount, Account account): callPay(amount, account) &#123;</span><br><span class="line">        if (account.balance &lt; amount) &#123;</span><br><span class="line">            System.out.println(&quot;[AccountAspect]拒绝付款!&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return proceed(amount, account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    after(int amount, Account balance): callPay(amount, balance) &#123;</span><br><span class="line">        System.out.println(&quot;[AccountAspect]付款后，剩余：&quot; + balance.balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-使用类"><a href="#3-3-使用类" class="headerlink" title="3.3.使用类"></a>3.3.使用类</h3></li><li>AccountDoWork.java<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AccountDoWork &#123;</span><br><span class="line">    public static void pay() &#123;</span><br><span class="line">        Account account = new Account();</span><br><span class="line">        account.pay(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-AspectJ-的优势与局限性"><a href="#4-AspectJ-的优势与局限性" class="headerlink" title="4.AspectJ 的优势与局限性"></a>4.AspectJ 的优势与局限性</h2>最常用的字节码处理框架有 AspectJ、ASM 等等，它们的相同之处在于输入输出都是 Class 文件。<br>并且，它们都是 在 Java 文件编译成 .class 文件之后，生成 Dalvik 字节码之前执行。<br>而 AspectJ 作为 Java 中流行的 AOP（aspect-oriented programming） 编程扩展框架，<br>其内部使用的是 BCEL框架 来完成其功能。下面，我们就来了解下 AspectJ 具备哪些优势。<h3 id="4-1-AspectJ-的优势"><a href="#4-1-AspectJ-的优势" class="headerlink" title="4.1.AspectJ 的优势"></a>4.1.AspectJ 的优势</h3> 它的优势有两点：成熟稳定、使用非常简单。</li><li>1、成熟稳定<br>字节码的处理并不简单，特别是 针对于字节码的格式和各种指令规则，如果处理出错，<br>就会导致程序编译或者运行过程中出现问题。而 AspectJ 作为从 2001 年发展至今的框架，<br>它已经发展地非常成熟，通常不用考虑插入的字节码发生正确性相关的问题。</li><li>2、使用非常简单<br>AspectJ 的使用非常简单，并且它的功能非常强大，我们完全不需要理解任何 Java 字节码相关的知识，<br>就可以在很多情况下对字节码进行操控。例如，它可以在如下五个位置插入自定义的代码：<br>1）、在方法（包括构造方法）被调用的位置。<br>2）、在方法体（包括构造方法）的内部。<br>3）、在读写变量的位置。<br>4）、在静态代码块内部。<br>5）、在异常处理的位置的前后。<br>此外，它也可以 直接将原位置的代码替换为自定义的代码。</li></ul><h3 id="4-2-AspectJ-的缺陷"><a href="#4-2-AspectJ-的缺陷" class="headerlink" title="4.2.AspectJ 的缺陷"></a>4.2.AspectJ 的缺陷</h3><p>而 AspectJ 的缺点可以归结为如下 三点：</p><ul><li>1、切入点固定<br>AspectJ 只能在一些固定的切入点来进行操作，如果想要进行更细致的操作则很难实现，它<br>无法针对一些特定规则的字节码序列做操作。</li><li>2、正则表达式的局限性<br>AspectJ 的匹配规则采用了类似正则表达式的规则，比如 匹配 Activity 生命周期的 onXXX 方法，如果有自定义的其他以 on 开头的方法也会匹配到，这样匹配的正确性就无法满足。</li><li>3、性能较低<br>AspectJ 在实现时会包装自己一些特定的类，它并不会直接把 Trace 函数直接插入到代码中，而是经过一系列自己的封装。这样不仅生成的字节码比较大，而且对原函数的性能会有不小的影响。如果想对 App 中所有的函数都进行插桩，性能影响肯定会比较大。如果你只插桩一小部分函数，那么 AspectJ 带来的性能损耗几乎可以忽略不计。<h2 id="5-AspectJ-核心语法简介"><a href="#5-AspectJ-核心语法简介" class="headerlink" title="5.AspectJ 核心语法简介"></a>5.AspectJ 核心语法简介</h2>AspectJ 其实就是一种 AOP 框架，AOP 是实现程序功能统一维护的一种技术。<br>利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合性降低，<br>提高程序的可重用性，同时大大提高了开发效率。因此 AOP 的优势可总结为如下 两点：</li></ul><p>1）、无侵入性。<br>2）、修改方便。</p><p>此外，AOP 不同于 OOP 将问题划分到单个模块之中，它把 涉及到众多模块的同一类问题进行了统一处理。<br>比如我们可以设计两个切面，一个是用于处理 App 中所有模块的日志输出功能，<br>另外一个则是用于处理 App 中一些特殊函数调用的权限检查。<br>下面👇，我们就来看看要掌握 AspectJ 的使用，我们需要了解的一些 核心概念。</p><ul><li>1、横切关注点<br>对哪些方法进行拦截，拦截后怎么处理。</li><li>2、切面（Aspect）<br>类是对物体特征的抽象，切面就是对横切关注点的抽象。</li><li>3、连接点（JoinPoint）<br>JPoint 是一个程序的关键执行点，也是我们关注的重点。<br>它就是指被拦截到的点（如方法、字段、构造器等等）。</li><li>4、切入点（PointCut）<br>对 JoinPoint 进行拦截的定义。<br>PointCut 的目的就是提供一种方法使得开发者能够选择自己感兴趣的 JoinPoint。</li><li>5、通知（Advice）<br>切入点仅用于捕捉连接点集合，但是，除了捕捉连接点集合以外什么事情都没有做。<br>事实上实现横切行为我们要使用通知。<br>它 一般指拦截到 JoinPoint 后要执行的代码，分为 前置、后置、环绕 三种类型。<br>这里，我们需要 注意 Advice Precedence（优先权） 的情况，<br>比如我们对同一个切面方法同时使用了 @Before 和 @Around 时就会报错，<br>此时会提示需要设置 Advice 的优先级。<br>AspectJ 作为一种基于 Java 语言实现的一套面向切面程序设计规范。<br>它向 Java 中加入了 连接点(Join Point) 这个新概念 ，<br>其实它也只是现存的一个 Java 概 念的名称而已。它向 Java 语言中加入了少许新结构，<br>譬如 切入点(pointcut)、通知(Advice)、类型间声明(Inter-type declaration) 和 切面(Aspect)。切入点和通知动态地影响程序流程，<br>类型间声明则是静态的影响程序的类等级结构，而切面则是对所有这些新结构的封装。<br>对于 AsepctJ 中的各个核心概念来说，其 连接点就恰如程序流中适当的一点。<br>而切入点收集特定的连接点集合和在这些点中的值。<br>一个通知则是当一个连接点到达时执行的代码，这些都是 AspectJ 的动态部分。<br>其实连接点就好比是 程序中那一条一条的语句，<br>而切入点就是特定一条语句处设置的一个断点，它收集了断点处程序栈的信息，<br>而通知就是在这个断点前后想要加入的程序代码。<br>此外，AspectJ 中也有许多不同种类的类型间声明，<br>这就允许程序员修改程序的静态结构、名称、类的成员以及类之间的关系。<br>AspectJ 中的切面是横切关注点的模块单元。它们的行为与 Java 语言中的类很象，<br>但是切面 还封装了切入点、通知以及类型间声明。</li></ul><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>AspectJ 的三种织入方式中，个人觉得前面的两种会比较实用一些，因为第三种需要修改启动脚本，对于大型公司来说会比较不友好，<br>需要专门找运维人员配置。 在实际生产中，我们用得最多的还是纯 Spring AOP，通过本文的介绍，相信大家对于 AspectJ 的使用应该也没什么压力了。<br>大家如果对于本文介绍的内容有什么不清楚的，请直接在评论区留言，如果对于 Spring + AspectJ 感兴趣的读者，碰到问题也可以在评论区和大家互动讨论。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><p><a href="https://javadoop.com/post/aspectj">https://javadoop.com/post/aspectj</a><br><a href="https://juejin.cn/post/6844904112396615688">https://juejin.cn/post/6844904112396615688</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-AspectJ-使用介绍&quot;&gt;&lt;a href=&quot;#1-AspectJ-使用介绍&quot; class=&quot;headerlink&quot; title=&quot;1.AspectJ 使用介绍&quot;&gt;&lt;/a&gt;1.AspectJ 使用介绍&lt;/h2&gt;&lt;p&gt;AspectJ 作为 AOP 编程的完全解决</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="字节码" scheme="http://example.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>bytebuddy实现aop</title>
    <link href="http://example.com/2021/08/04/language/java/bytecode/bytebuddy-aop/"/>
    <id>http://example.com/2021/08/04/language/java/bytecode/bytebuddy-aop/</id>
    <published>2021-08-04T06:25:13.666Z</published>
    <updated>2021-08-04T06:25:13.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>最近业务服务需要做一些组件第三方组件监控的事，需要用到字节码修改相关的技术，bytebuddy就是其中一种，<br>网上找了一下bytebuddy相关资料，不少大佬写的不错的帖子就直接拿过来了，下方备注参考连接</p><p>本文主要介绍 bytebuddy-aop相关操作</p><h2 id="2-ByteBuddy简介"><a href="#2-ByteBuddy简介" class="headerlink" title="2.ByteBuddy简介"></a>2.ByteBuddy简介</h2><p>Byte Buddy 是一个代码生成和操作库，用于在 Java 应用程序运行时创建和修改 Java 类，无需编译器的帮助。<br>除了Java 类库附带的代码生成实用程序，Byte Buddy 允许创建任意类，并且不限于实现用于创建运行时代理的接口。<br>此外，Byte Buddy 提供了一个方便的 API，用于手动、使用 Java 代理或在构建期间更改类。</p><p>简单来说，ByteBuddy是一个可以在运行时动态生成java class的类库。在这篇文章中，<br>我们将会使用ByteBuddy这个框架操作已经存在的类，创建指定的新类，甚至拦截方法调用。</p><p>官网：<a href="https://bytebuddy.net/#/">https://bytebuddy.net/#/</a></p><ul><li>代码地址参考：<a href="https://github.com/wuhaocn/jcode-simple.git">https://github.com/wuhaocn/jcode-simple.git</a></li></ul><h2 id="3-AOP注解实现"><a href="#3-AOP注解实现" class="headerlink" title="3.AOP注解实现"></a>3.AOP注解实现</h2><h3 id="3-1-依赖引入"><a href="#3-1-依赖引入" class="headerlink" title="3.1 依赖引入"></a>3.1 依赖引入</h3><p> 依赖byte-buddy、byte-buddy-agent相关类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation group: &#x27;net.bytebuddy&#x27;, name: &#x27;byte-buddy&#x27;, version: &#x27;1.11.8&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-定义相关类"><a href="#3-2-定义相关类" class="headerlink" title="3.2 定义相关类"></a>3.2 定义相关类</h3><p>定义 注解类、业务类、监听类;</p><ul><li>注解类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Monitor &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务类<br>此处定义监控方法并加上Monitor注解<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BizAnnotationService &#123;</span><br><span class="line">@Monitor</span><br><span class="line">    public int foo(int value) &#123;</span><br><span class="line">        System.out.println(&quot;foo: &quot; + value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int bar(int value) &#123;</span><br><span class="line">        System.out.println(&quot;bar: &quot; + value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>监听类<br>实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MonitorAnnotationAdvisor &#123;</span><br><span class="line">    @Advice.OnMethodEnter</span><br><span class="line">    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) &#123;</span><br><span class="line">if (method.getAnnotation(Monitor.class) != null) &#123;</span><br><span class="line">System.out.println(&quot;onMethodEnter &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Advice.OnMethodExit</span><br><span class="line">    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) &#123;</span><br><span class="line">if (method.getAnnotation(Monitor.class) != null) &#123;</span><br><span class="line">System.out.println(&quot;onMethodExit &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试类</li></ul><p>测试注解生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class BizAnnotationTest &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">BizAnnotationService service = new ByteBuddy()</span><br><span class="line">.subclass(BizAnnotationService.class)</span><br><span class="line">.method(ElementMatchers.any())</span><br><span class="line">.intercept(Advice.to(MonitorAnnotationAdvisor.class))</span><br><span class="line">.make()</span><br><span class="line">.load(BizAnnotationService.class.getClassLoader())</span><br><span class="line">.getLoaded()</span><br><span class="line">.newInstance();</span><br><span class="line">service.bar(11111);</span><br><span class="line">service.foo(99999);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果输出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :code-gen:bytebuddy:BizAnnotationTest.main()</span><br><span class="line">bar: 11111</span><br><span class="line">onMethodEnter foo with arguments: [99999]</span><br><span class="line">foo: 99999</span><br><span class="line">onMethodExit foo with arguments: [99999]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-AOP监听第三方组件"><a href="#4-AOP监听第三方组件" class="headerlink" title="4.AOP监听第三方组件"></a>4.AOP监听第三方组件</h2><h3 id="4-1-定义相关类"><a href="#4-1-定义相关类" class="headerlink" title="4.1 定义相关类"></a>4.1 定义相关类</h3><p>定义 业务类、监听类、测试类;</p><p>主要原因是调用代码无法增加注解</p><ul><li><p>业务类<br>此处定义监控方法并加上未添加注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BizService &#123;</span><br><span class="line">    public int foo(int value) &#123;</span><br><span class="line">        System.out.println(&quot;foo: &quot; + value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int bar(int value) &#123;</span><br><span class="line">        System.out.println(&quot;bar: &quot; + value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监听类<br>实现 @Advice.OnMethodEnter    @Advice.OnMethodExit 监听业务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MonitorAdvisor &#123;</span><br><span class="line">    @Advice.OnMethodEnter</span><br><span class="line">    public static void onMethodEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments) &#123;</span><br><span class="line">System.out.println(&quot;onMethodEnter &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Advice.OnMethodExit</span><br><span class="line">    public static void onMethodExit(@Advice.Origin Method method, @Advice.AllArguments Object[] arguments, @Advice.Return Object ret) &#123;</span><br><span class="line">System.out.println(&quot;onMethodExit &quot; + method.getName() + &quot; with arguments: &quot; + Arrays.toString(arguments) + &quot; return: &quot; + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p></li></ul><p>测试不添加注解验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class BizServiceTest &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">BizService service = new ByteBuddy()</span><br><span class="line">.subclass(BizService.class)</span><br><span class="line">.method(ElementMatchers.any())</span><br><span class="line">.intercept(Advice.to(MonitorAdvisor.class))</span><br><span class="line">.make()</span><br><span class="line">.load(BizService.class.getClassLoader())</span><br><span class="line">.getLoaded()</span><br><span class="line">.newInstance();</span><br><span class="line">service.bar(00000);</span><br><span class="line">service.foo(99999);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果输出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :code-gen:bytebuddy:BizServiceTest.main()</span><br><span class="line">onMethodEnter bar with arguments: [11111]</span><br><span class="line">bar: 11111</span><br><span class="line">onMethodExit bar with arguments: [11111] return: 11111</span><br><span class="line">onMethodEnter foo with arguments: [99999]</span><br><span class="line">foo: 99999</span><br><span class="line">onMethodExit foo with arguments: [99999] return: 99999</span><br></pre></td></tr></table></figure><h2 id="5-监控耗时"><a href="#5-监控耗时" class="headerlink" title="5.监控耗时"></a>5.监控耗时</h2><h3 id="5-1-定义相关类"><a href="#5-1-定义相关类" class="headerlink" title="5.1 定义相关类"></a>5.1 定义相关类</h3><ul><li><p>业务类<br>耗时处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CostService &#123;</span><br><span class="line">    public int play(int value) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;foo: &quot; + value);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监控类<br>实现    @RuntimeType通过 Object intercept(@SuperCall Callable&lt;?&gt; callable)返回处理结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CostMonitorAdvisor &#123;</span><br><span class="line">@RuntimeType</span><br><span class="line">public static Object intercept(@SuperCall Callable&lt;?&gt; callable) throws Exception &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">try &#123;</span><br><span class="line">return callable.call();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">System.out.println(&quot;方法耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p></li></ul><p>通过方法委托实现 ByteBuddy#intercept(MethodDelegation.to(CostMonitorAdvisor.class))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CostServiceTest &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">CostService service = new ByteBuddy()</span><br><span class="line">.subclass(CostService.class)</span><br><span class="line">.method(ElementMatchers.any())</span><br><span class="line">.intercept(MethodDelegation.to(CostMonitorAdvisor.class))</span><br><span class="line">.make()</span><br><span class="line">.load(CostService.class.getClassLoader())</span><br><span class="line">.getLoaded()</span><br><span class="line">.newInstance();</span><br><span class="line">service.play(11111);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果输出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :code-gen:bytebuddy:CostServiceTest.main()</span><br><span class="line">play: 11111</span><br><span class="line">方法耗时：35ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>带参传递<br>部分构造函数携带参数，这里以redis为例简单写了下带参数传递的类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ByteBuddy byteBuddy = new ByteBuddy();</span><br><span class="line">Class aClass = byteBuddy.subclass(Jedis.class)</span><br><span class="line">        .method(ElementMatchers.any())</span><br><span class="line">        .intercept(MethodDelegation.to(RedisMonitorAdvisor.class))</span><br><span class="line">        .make()</span><br><span class="line">        .load(Jedis.class.getClassLoader())</span><br><span class="line">        .getLoaded();</span><br><span class="line">Class[] p = &#123;String.class, int.class&#125;;</span><br><span class="line">Constructor&lt;Jedis&gt; classDeclaredConstructor = aClass.getDeclaredConstructor(p);</span><br><span class="line">Jedis jedis = classDeclaredConstructor.newInstance(&quot;10.3.4.111&quot;, 6379);</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><ul><li><p>通过ByteBuddy创建实例，并注入切面可实现横切</p><ul><li>可执行onMethodEnter onMethodExit相关操作</li><li>RuntimeType监听方法耗时</li></ul></li><li><p>对象创建需要通过ByteBuddy创建，自己创建类无法实现</p></li><li><p>无法监控静态对象</p></li></ul><h2 id="7-注解含义"><a href="#7-注解含义" class="headerlink" title="7.注解含义"></a>7.注解含义</h2><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Argument</td><td>绑定单个参数</td></tr><tr><td>@AllArguments</td><td>绑定所有参数的数组</td></tr><tr><td>@This</td><td>当前被拦截的、动态生成的那个对象</td></tr><tr><td>@Super</td><td>当前被拦截的、动态生成的那个对象的父类对象</td></tr><tr><td>@Origin</td><td>可以绑定到以下类型的参数：Method 被调用的原始方法 Constructor 被调用的原始构造器 Class 当前动态创建的类 MethodHandle MethodType String 动态类的toString()的返回值 int 动态方法的修饰符</td></tr><tr><td>@DefaultCall</td><td>调用默认方法而非super的方法</td></tr><tr><td>@SuperCall</td><td>用于调用父类版本的方法</td></tr><tr><td>@Super</td><td>注入父类型对象，可以是接口，从而调用它的任何方法</td></tr><tr><td>@RuntimeType</td><td>可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</td></tr><tr><td>@Empty</td><td>注入参数的类型的默认值</td></tr><tr><td>@StubValue</td><td>注入一个存根值。对于返回引用、void的方法，注入null；对于返回原始类型的方法，注入0</td></tr><tr><td>@FieldValue</td><td>注入被拦截对象的一个字段的值</td></tr><tr><td>@Morph</td><td>类似于@SuperCall，但是允许指定调用参数</td></tr></tbody></table><ul><li>代码参考:<br><a href="https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy">https://github.com/wuhaocn/jcode-simple/tree/master/code-gen/bytebuddy</a></li></ul><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8.参考"></a>8.参考</h2><p><a href="https://zhuanlan.zhihu.com/p/151843984">https://zhuanlan.zhihu.com/p/151843984</a><br><a href="https://bytebuddy.net/#/">https://bytebuddy.net/#/</a><br><a href="https://www.jianshu.com/p/be2efc2b0e4c">https://www.jianshu.com/p/be2efc2b0e4c</a><br><a href="https://blog.csdn.net/generalfu/article/details/106086475">https://blog.csdn.net/generalfu/article/details/106086475</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.背景&quot;&gt;&lt;/a&gt;1.背景&lt;/h2&gt;&lt;p&gt;最近业务服务需要做一些组件第三方组件监控的事，需要用到字节码修改相关的技术，bytebuddy就是其中一种，&lt;br&gt;网上找了</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM软引用和弱引用</title>
    <link href="http://example.com/2021/08/04/language/jvm/JVM%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
    <id>http://example.com/2021/08/04/language/jvm/JVM%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8/</id>
    <published>2021-08-04T06:25:13.665Z</published>
    <updated>2021-08-04T06:25:13.666Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景"></a>一个场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果有一个值，对应的键已经不再使用了, 将会出现什么情况呢？假定对某个键的最后一次引用已经消亡, </span><br><span class="line">不再有任何途径引用这个值的对象了, 但是, 由于在程序中的任何部分没有再出现这个键, </span><br><span class="line">所以, 这个 键/值 对无法从映射中删除.</span><br><span class="line"></span><br><span class="line">垃圾收集器怎么处理这样的场景呢? 引用出现了!</span><br></pre></td></tr></table></figure><h4 id="JAVA-中的引用"><a href="#JAVA-中的引用" class="headerlink" title="JAVA 中的引用"></a>JAVA 中的引用</h4><p><strong>强引用 StrongReference</strong>: 普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略</p><p><strong>软引用 SoftReference</strong>: 一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存, 维护一种非强制性的映射关系</p><p><strong>弱引用 WeakReference</strong>: 并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系,如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。这个类对象的引用，一般主要是在 major collection 的时候回收，所以它可能在 minor collection 后仍然存在。</p><p>**虚引用 PhantomReference: **The object is the referent of a PhantomReference, and it has already been selected for collection and its finalizer (if any) has run. The term “reachable” is really a misnomer in this case, as there’s no way for you to access the actual object. 不可达, 不影响对象的生命周期, 通过虚引用的 get() 方法永远返回 null.</p><p>正如您可能猜到的，向对象生命周期图添加三个新的可选状态会造成混乱。尽管文档指出了从强可达到软、弱和虚到回收的逻辑过程，但实际过程取决于程序创建的引用对象。如果创建 WeakReference 但不创建SoftReference，则对象将直接从强可达到弱可达，再从最终确定到收集。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12487950/1619438588692-902fee26-a911-48f8-8556-09bbe528b41a.png#clientId=u1abc7148-9485-4&from=paste&height=206&id=u6a33dc73&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=656&originalType=binary&size=8628&status=done&style=none&taskId=u0e0ed8d5-e6b2-418d-a350-ed9052bcb93&width=656" alt="image.png"></p><h4 id="References-and-Referents"><a href="#References-and-Referents" class="headerlink" title="References and Referents"></a>References and Referents</h4><p>A reference object is a layer of indirection between your program code and some other object, called a referent. Each reference object is constructed around its referent, and the referent cannot be changed.<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12487950/1619605033615-5ec8b4a0-689c-4d6f-bdee-effa11da7b26.png#clientId=u406342b3-8a6c-4&from=paste&height=82&id=Qh0bD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=490&originalType=binary&size=3281&status=done&style=none&taskId=u2755513c-92e7-4ec9-9371-4629adea141&width=490" alt="image.png"></p><h4 id="引用意义"><a href="#引用意义" class="headerlink" title="引用意义"></a>引用意义</h4><p>垃圾回收时的垃圾判定方式: <a href="https://rongcloud.yuque.com/ofnwgp/xdbvrt/scix1x">垃圾回收</a><br>JVM 在进行垃圾回收的时候，会判定对象是否还存在引用，它会针对不同的引用类型分别对待。<br>弱引用可以用来访问对象，但进行垃圾回收时，如果对象仅有弱引用指向，则仍然会被 GC 回收。</p><h4 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 软引用和弱引用的一个例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;str-value&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> SoftReference&lt;String&gt;(str); <span class="comment">// 软引用</span></span><br><span class="line">str = <span class="keyword">null</span>; <span class="comment">// 去掉强引用</span></span><br><span class="line">System.gc(); <span class="comment">// 垃圾回收器进行回收</span></span><br><span class="line">System.out.println(softRef.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String abc = <span class="keyword">new</span> String(<span class="string">&quot;abc-value&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(abc); <span class="comment">// 弱引用</span></span><br><span class="line">abc = <span class="keyword">null</span>;<span class="comment">// 去掉强引用</span></span><br><span class="line">System.gc(); <span class="comment">// 垃圾回收器进行回收</span></span><br><span class="line">System.out.println(weakRef.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">str-value</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;key-a&quot;</span>);</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;key-b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(a, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        map.put(b, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map weakmap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">        weakmap.put(a, <span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        weakmap.put(b, <span class="string">&quot;bbbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        map.remove(a);</span><br><span class="line">        </span><br><span class="line">        a = <span class="keyword">null</span>; <span class="comment">// 移除 a 的强引用, key-a 也没人引用了; map.size();</span></span><br><span class="line">        b = <span class="keyword">null</span>; <span class="comment">// 移除 b 的强引用, key-b 还被 map 引用着 map.get(b); map.get(&quot;key-b&quot;);</span></span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        Iterator i = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Map.Entry en = (Map.Entry) i.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;map:&quot;</span> + en.getKey() + <span class="string">&quot;:&quot;</span> + en.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator j = weakmap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (j.hasNext()) &#123;</span><br><span class="line">            Map.Entry en = (Map.Entry) j.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;weakmap:&quot;</span> + en.getKey() + <span class="string">&quot;:&quot;</span> + en.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">map:key-b:bbb</span><br><span class="line">weakmap:key-b:bbbb</span><br></pre></td></tr></table></figure><h4 id="想说的话"><a href="#想说的话" class="headerlink" title="想说的话"></a>想说的话</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平时使用的缓存存在的问题</span></span><br><span class="line"><span class="number">1.</span> 对象都是强引用的</span><br><span class="line"><span class="number">2.</span> 不确定单个对象占用的 <span class="keyword">byte</span> size 大小</span><br><span class="line"><span class="number">3.</span> 无法准确的估算创建缓存的时候为其指定一个准确的大小</span><br><span class="line"><span class="number">4.</span> JVM 即使报 OOM 也不会清理这些缓存, 失去缓存的意义 =&gt; LRU </span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱引用缓存 WeakHashMap</span></span><br><span class="line"><span class="number">1.</span> key 是经过弱引用化处理的, value 不是</span><br><span class="line"><span class="number">2.</span> 即使不被主动调用 remove, clear 方法，元素也是会有机会清除的</span><br><span class="line"><span class="number">3.</span> key-value 的清理时机, key 伴随 gc 清理, value 根据 ReferenceQueue 进行清理</span><br><span class="line"><span class="number">4.</span> ReferenceQueue</span><br><span class="line"><span class="number">5.</span> 为什么会存在 ReferenceQueue ? </span><br><span class="line">    我们可以通过 reference.get() 的返回值确定 referent 是否被回收了, </span><br><span class="line">但是现实是我们有大量的引用对象，这么操作是不实际的，一个好的解决方案就出来了 - 引用队列，</span><br><span class="line">    在构造时将引用与队列相关联，并且在清除引用后将其放在队列上。要发现哪些引用已被清除,</span><br><span class="line">    可以轮询队列。这可以通过后台线程完成，但是在创建新引用时轮询队列通常更简单(WeakHashMap就是这么做的)</span><br><span class="line">引用队列更像是监听器.</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 弱引用的特点更适合高速缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用的状态</span></span><br><span class="line"><span class="number">1.</span> Active: </span><br><span class="line">新创建的实例处于活动状态, 由垃圾收集者进行特殊处理,</span><br><span class="line">收集器检测到引用对象的可访问性已更改为适当的状态后的一段时间，它会将实例的状态更改为挂起或不活动，</span><br><span class="line">    这取决于创建实例时是否向队列注册了实例, 在前一种情况下，它还将实例添加到挂起引用列表中.</span><br><span class="line"><span class="number">2.</span> Pending: </span><br><span class="line">挂起引用列表的元素，等待引用处理程序线程排队,未注册的实例从不处于此状态.</span><br><span class="line"><span class="number">3.</span> Enqueued</span><br><span class="line">在创建实例时向其注册的队列元素. 当实例从其引用队列中移除时,它将变为非活动状态.</span><br><span class="line">    未注册的实例从不处于此状态</span><br><span class="line"><span class="number">4.</span> Inactive</span><br><span class="line">一旦实例变为非活动状态,其状态将永远不会再改变.</span><br></pre></td></tr></table></figure><h4 id="弱引用的应用"><a href="#弱引用的应用" class="headerlink" title="弱引用的应用"></a>弱引用的应用</h4><p>WeakHashMap (源码分析)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 根据 API 文档，当 Map 中的键不再使用，键对应的键值也将自动在 WeakHashMap 中删除。WeakHashMap 中的键为弱键，和其他 Map 接口的实现有些不同；</span><br><span class="line"><span class="number">2.</span> 和 HashMap 类似; 但是支持 key 和 value 为 <span class="keyword">null</span>, 不存在红黑树结构，因为没必要</span><br><span class="line"><span class="number">3.</span> 同样不是线程安全的，可以使用 Collections.synchronizedMap(Map map) 来使之线程安全</span><br><span class="line"><span class="number">4.</span> 没有实现 Cloneable, Serializable接口, 没有必要</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 基本组成属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br><span class="line">    Entry&lt;K,V&gt;[] table; <span class="comment">// 这个 Entry 继承了 WeakReference</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Reference queue for cleared WeakEntries</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 队列放的是什么 ?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> modCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. put 方法分析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 table[i] 链表, 如果找到相同的 key 则将老的 value 用新的 value 替换</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modCount++;<span class="comment">// 修改次数++</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];<span class="comment">// 取得链表的第一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建新的链表（将新元素放在链表最前面）,同时将 key 注册到引用队列</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry&lt;&gt;(k, value, queue, h, e); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k.hashCode();</span><br><span class="line">    </span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将引用队列里的元素拿出来，修正 table 中的无效数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;<span class="comment">// queue 放的是元素, 将要被清理的元素</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);<span class="comment">// 定位在 table 数组的位置</span></span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 取得 table [i] 处链表的第一个元素</span></span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;<span class="comment">// 链表是否为空或者是否是链表的最后一个元素</span></span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123; <span class="comment">// 找到了要被清理的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (prev == e)<span class="comment">// prev 不一定和 p 相同</span></span><br><span class="line">                        table[i] = next; <span class="comment">// 用下一个元素对 e 元素替换</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next; <span class="comment">// 修复链接</span></span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p; <span class="comment">// 没找到要被清理的元素,交换指针,移动位置,继续比对</span></span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">super</span>(key, queue);</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">    <span class="keyword">this</span>.next  = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new weak reference that refers to the given object and is</span></span><br><span class="line"><span class="comment"> * registered with the given queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> referent object the new weak reference will refer to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment"> *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 监听器效果, 如果引用的对象被回收(reference.get() == null)，则将其加入该队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(referent, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line"><span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. get 方法分析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. remove 方法, 分析过 expungeStaleEntries 方法，该方法就没必要看了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过分析可以看到 getTable() 经常被调用到，它和 ReferenceQueue 一起完成的对 k-v 的清理工作</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一个场景&quot;&gt;&lt;a href=&quot;#一个场景&quot; class=&quot;headerlink&quot; title=&quot;一个场景&quot;&gt;&lt;/a&gt;一个场景&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能调优的6大步骤-关键调优参数详解</title>
    <link href="http://example.com/2021/08/04/language/jvm/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9A%846%E5%A4%A7%E6%AD%A5%E9%AA%A4-%E5%85%B3%E9%94%AE%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/08/04/language/jvm/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9A%846%E5%A4%A7%E6%AD%A5%E9%AA%A4-%E5%85%B3%E9%94%AE%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-08-04T06:25:13.664Z</published>
    <updated>2021-08-04T06:25:13.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JVM-内存调优"><a href="#一、JVM-内存调优" class="headerlink" title="一、JVM 内存调优"></a>一、JVM 内存调优</h2><p>对 JVM 内存的系统级的调优主要的目的是减少 GC 的频率和 Full GC 的次数。<br><img src="https://pic2.zhimg.com/80/v2-c256a1d88bd0a626a4583778d2c13bc9_720w.jpg"></p><h3 id="1-Full-GC"><a href="#1-Full-GC" class="headerlink" title="1.Full GC"></a>1.Full GC</h3><p>会对整个堆进行整理，包括 Young、Tenured 和 Perm。Full GC 因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少 Full GC 的次数。</p><h3 id="2-导致-Full-GC-的原因"><a href="#2-导致-Full-GC-的原因" class="headerlink" title="2.导致 Full GC 的原因"></a>2.导致 Full GC 的原因</h3><p>1)年老代（Tenured）被写满</p><p>调优时尽量让对象在新生代 GC 时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。</p><p>2)持久代 Pemanet Generation 空间不足</p><p>增大 Perm Gen 空间，避免太多静态对象 ， 控制好新生代和旧生代的比例</p><p>3)System.gc()被显示调用</p><p>垃圾回收不要手动触发，尽量依靠 JVM 自身的机制</p><p>在对 JVM 调优的过程中，很大一部分工作就是对于 FullGC 的调节，下面详细介绍对应 JVM 调优的方法和步骤。</p><h2 id="二、JVM-性能调优方法和步骤"><a href="#二、JVM-性能调优方法和步骤" class="headerlink" title="二、JVM 性能调优方法和步骤"></a>二、JVM 性能调优方法和步骤</h2><p><img src="https://pic1.zhimg.com/80/v2-5e1966122f124e4034a4c4f281cf7458_720w.jpg"></p><h3 id="1-监控-GC-的状态"><a href="#1-监控-GC-的状态" class="headerlink" title="1.监控 GC 的状态"></a>1.监控 GC 的状态</h3><p>使用各种 JVM 工具，查看当前日志，分析当前 JVM 参数设置，并且分析当前堆内存快照和 gc 日志，根据实际的各区域内存划分和 GC 执行时间，觉得是否进行优化。</p><p>举一个例子： 系统崩溃前的一些现象：</p><p>每次垃圾回收的时间越来越长，由之前的 10ms 延长到 50ms 左右，FullGC 的时间也有之前的 0.5s 延长到 4、5s FullGC 的次数越来越多，最频繁时隔不到 1 分钟就进行一次 FullGC<br>年老代的内存越来越大并且每次 FullGC 后年老代没有内存被释放 之后系统会无法响应新的请求，逐渐到达 OutOfMemoryError 的临界值，这个时候就需要分析 JVM 内存快照 dump。</p><h3 id="2-生成堆的-dump-文件"><a href="#2-生成堆的-dump-文件" class="headerlink" title="2.生成堆的 dump 文件"></a>2.生成堆的 dump 文件</h3><p>通过 JMX 的 MBean 生成当前的 Heap 信息，大小为一个 3G（整个堆的大小）的 hprof 文件，如果没有启动 JMX 可以通过 Java 的 jmap 命令来生成该文件。</p><h3 id="3-分析-dump-文件"><a href="#3-分析-dump-文件" class="headerlink" title="3.分析 dump 文件"></a>3.分析 dump 文件</h3><p>打开这个 3G 的堆信息文件，显然一般的 Window 系统没有这么大的内存，必须借助高配置的 Linux，几种工具打开该文件：</p><p>Visual VM IBM HeapAnalyzer JDK 自带的 Hprof 工具 Mat(Eclipse 专门的静态内存分析工具)推荐使用 备注：文件太大，建议使用 Eclipse 专门的静态内存分析工具 Mat 打开分析。</p><h3 id="4-分析结果，判断是否需要优化"><a href="#4-分析结果，判断是否需要优化" class="headerlink" title="4.分析结果，判断是否需要优化"></a>4.分析结果，判断是否需要优化</h3><p>如果各项参数设置合理，系统没有超时日志出现，GC 频率不高，GC 耗时不高，那么没有必要进行 GC 优化，如果 GC 时间超过 1-3 秒，或者频繁 GC，则必须优化。</p><p>注：如果满足下面的指标，则一般不需要进行 GC：</p><p>Minor GC 执行时间不到 50ms； Minor GC 执行不频繁，约 10 秒一次； Full GC 执行时间不到 1s； Full GC 执行频率不算频繁，不低于 10 分钟 1 次；</p><h3 id="5-调整-GC-类型和内存分配"><a href="#5-调整-GC-类型和内存分配" class="headerlink" title="5.调整 GC 类型和内存分配"></a>5.调整 GC 类型和内存分配</h3><p>如果内存分配过大或过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数，并且先找 1 台或几台机器进行 beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。</p><h3 id="6-不断的分析和调整"><a href="#6-不断的分析和调整" class="headerlink" title="6.不断的分析和调整"></a>6.不断的分析和调整</h3><p>通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。</p><p>cms 参数优化步流程<br><img src="https://pic3.zhimg.com/80/v2-1acebd36d4d6777d87e594c1572c11ba_720w.jpg"><br>下面我再继续介绍下 JVM 的关键参数配置(仅用于参考)。</p><h2 id="JVM-调优参数参考"><a href="#JVM-调优参数参考" class="headerlink" title="JVM 调优参数参考"></a>JVM 调优参数参考</h2><h3 id="1-针对-JVM-堆的设置，一般可以通过-Xms-Xmx-限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值"><a href="#1-针对-JVM-堆的设置，一般可以通过-Xms-Xmx-限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值" class="headerlink" title="1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;"></a>1.针对 JVM 堆的设置，一般可以通过-Xms -Xmx 限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;</h3><h3 id="2-年轻代和年老代将根据默认的比例（1：2）分配堆内存，-可以通过调整二者之间的比率-NewRadio-来调整二者之间的大小，也可以针对回收代。"><a href="#2-年轻代和年老代将根据默认的比例（1：2）分配堆内存，-可以通过调整二者之间的比率-NewRadio-来调整二者之间的大小，也可以针对回收代。" class="headerlink" title="2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。"></a>2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率 NewRadio 来调整二者之间的大小，也可以针对回收代。</h3><p>比如年轻代，通过 -XX:newSize -XX:MaxNewSize 来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize 设置为同样大小。</p><h3 id="3-年轻代和年老代设置多大才算合理"><a href="#3-年轻代和年老代设置多大才算合理" class="headerlink" title="3.年轻代和年老代设置多大才算合理"></a>3.年轻代和年老代设置多大才算合理</h3><p>1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通 GC 的周期，但会增加每次 GC 的时间；小的年老代会导致更频繁的 Full GC<br>2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通 GC 很频繁，但每次的 GC 时间会更短；大的年老代会减少 Full GC 的频率 如何选择应该依赖应用程序对象生命周期的分布情况：<br>如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。 但很多应用都没有这样明显的特性。 在抉择时应该根 据以下两点：</p><ul><li><p>（1）本着 Full GC 尽量少的原则，让年老代尽量缓存常用对象，JVM 的默认比例 1：2 也是这个道理 。</p></li><li><p>（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响 Full GC 的前提下，根据实际情况加大年轻代，比如可以把比例控制在 1：1。 但应该给年老代至少预留 1/3 的增长空间。</p></li></ul><h3 id="4-在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：-XX-UseParallelOldGC-。"><a href="#4-在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：-XX-UseParallelOldGC-。" class="headerlink" title="4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。"></a>4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。</h3><h3 id="5-线程堆栈的设置：每个线程默认会开启-1M-的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般-256K-就足用。"><a href="#5-线程堆栈的设置：每个线程默认会开启-1M-的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般-256K-就足用。" class="headerlink" title="5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。"></a>5.线程堆栈的设置：每个线程默认会开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般 256K 就足用。</h3><p>理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p><p>觉得不错请点赞支持下。</p><p>—-end—-</p><p>JVM 相关技术干货推荐：</p><ul><li>深入详解 JVM 内存模型与 JVM 参数详细配置</li><li>7 种 JVM 垃圾收集器特点，优劣势、及使用场景</li><li>JVM 的 4 种垃圾回收算法、垃圾回收机制与总结</li><li>深入剖析 JVM：G1 收集器+回收流程+推荐用例</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://zhuanlan.zhihu.com/p/58897189">https://zhuanlan.zhihu.com/p/58897189</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、JVM-内存调优&quot;&gt;&lt;a href=&quot;#一、JVM-内存调优&quot; class=&quot;headerlink&quot; title=&quot;一、JVM 内存调优&quot;&gt;&lt;/a&gt;一、JVM 内存调优&lt;/h2&gt;&lt;p&gt;对 JVM 内存的系统级的调优主要的目的是减少 GC 的频率和 Full G</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载机制</title>
    <link href="http://example.com/2021/08/04/language/jvm/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/08/04/language/jvm/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-08-04T06:25:13.664Z</published>
    <updated>2021-08-04T06:25:13.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h3 id="1-类的加载过程"><a href="#1-类的加载过程" class="headerlink" title="1. 类的加载过程"></a>1. 类的加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7 个阶段。其中准备、验证、解析 3 个部分统称为连接（Linking）。如图所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">加载--&gt;验证</span><br><span class="line">验证--&gt;准备</span><br><span class="line">准备--&gt;解析</span><br><span class="line">解析--&gt;初始化</span><br><span class="line">初始化--&gt;使用</span><br><span class="line">使用--&gt;卸载</span><br></pre></td></tr></table></figure><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已 HotSpot 为基准。</p><h4 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h4><p>虚拟机在加载阶段需要完成三件事:</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流，如 Class 文件,网络,动态生成,数据库等</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口<br>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</li></ol><h4 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，验证阶段大致会完成 4 个阶段的检验动作：</p><ol><li>文件格式验证：验证字节流是否符合 Class 文件格式的规范；例如：是否以魔术 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object 之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。<br>验证阶段可能抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如 java.lang.IllegalAccessError、 java. lang. NoSuchFieldError、<br>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li></ol><h4 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值.</p><p>如下定义:public static int value=123; 那变量 value 在准备阶段过后的初始值为 0 而不是 123.因为这时候尚未开始执行任何 java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器()方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。</p><p>如下定义：public static final int value=123; 即当类字段的字段属性是 ConstantValue 时，会在准备阶段初始化为指定的值，所以标注为 final 之后，value 的值在准备阶段初始化为 123 而非 0.</p><h4 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析针对如下 7 类符号引用进行：</p><blockquote><p>类或接口<br>字段<br>类方法<br>接口方法<br>方法类型<br>方法句柄<br>调用点限定符</p></blockquote><h4 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h4><p>类初始化阶段是类加载过程的最后一步，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。</p><p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。我们放到后面再讲<clinit>()方法是怎么生成的，在这里，我们先看一下<clinit>()方法执行过程中可能会影响程序运行行为的一些特点和细节，这部分相对更贴近于普通的程序开发人员[7]：<br>·<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。<br>·<clinit>()方法与类的构造函数（或者说实例构造器<clinit>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是 java.lang.Object。<br>·由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下代码执行字段 B 的值将会是 2 而不是 1。<br><clinit>()方法执行顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sf.jvm.load;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> A;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> B;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> Parent();</span><br><span class="line">        System.out.println(Sub.B);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Sub().getB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Compiled from &quot;Parent.java&quot;</span></span><br><span class="line"><span class="comment"> class sf.jvm.load.Parent &#123;</span></span><br><span class="line"><span class="comment"> public static int A;</span></span><br><span class="line"><span class="comment"> sf.jvm.load.Parent();</span></span><br><span class="line"><span class="comment"> Code:</span></span><br><span class="line"><span class="comment"> 0: aload_0</span></span><br><span class="line"><span class="comment"> 1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="comment"> 4: return</span></span><br><span class="line"><span class="comment"> public int getA();</span></span><br><span class="line"><span class="comment"> Code:</span></span><br><span class="line"><span class="comment"> 0: getstatic     #2                  // Field A:I</span></span><br><span class="line"><span class="comment"> 3: ireturn</span></span><br><span class="line"><span class="comment"> static &#123;&#125;;</span></span><br><span class="line"><span class="comment"> Code:</span></span><br><span class="line"><span class="comment"> 0: iconst_1</span></span><br><span class="line"><span class="comment"> 1: putstatic     #2                  // Field A:I</span></span><br><span class="line"><span class="comment"> 4: iconst_2</span></span><br><span class="line"><span class="comment"> 5: putstatic     #2                  // Field A:I</span></span><br><span class="line"><span class="comment"> 8: return</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>·<clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。<br>·接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。<br>·虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sf.jvm.load;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//如果不加上这个if语句，编译器将提示&quot;Initializerdoesnotcompletenormally&quot;并拒绝编译</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;initDeadLoopClass&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;runover&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> &quot;C:\Program Files\Java\jdk1.8.0_91\bin\javap.exe&quot; -c sf.jvm.load.DeadLoopClass</span></span><br><span class="line"><span class="comment"> Compiled from &quot;DeadLoopClass.java&quot;</span></span><br><span class="line"><span class="comment"> class sf.jvm.load.DeadLoopClass &#123;</span></span><br><span class="line"><span class="comment"> sf.jvm.load.DeadLoopClass();</span></span><br><span class="line"><span class="comment"> Code:</span></span><br><span class="line"><span class="comment"> 0: aload_0</span></span><br><span class="line"><span class="comment"> 1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="comment"> 4: return</span></span><br><span class="line"><span class="comment"> public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> Code:</span></span><br><span class="line"><span class="comment"> 0: new           #2                  // class sf/jvm/load/DeadLoopClass$1</span></span><br><span class="line"><span class="comment"> 3: dup</span></span><br><span class="line"><span class="comment"> 4: invokespecial #3                  // Method sf/jvm/load/DeadLoopClass$1.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="comment"> 7: astore_1</span></span><br><span class="line"><span class="comment"> 8: new           #4                  // class java/lang/Thread</span></span><br><span class="line"><span class="comment"> 11: dup</span></span><br><span class="line"><span class="comment"> 12: aload_1</span></span><br><span class="line"><span class="comment"> 13: invokespecial #5                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class="line"><span class="comment"> 16: astore_2</span></span><br><span class="line"><span class="comment"> 17: new           #4                  // class java/lang/Thread</span></span><br><span class="line"><span class="comment"> 20: dup</span></span><br><span class="line"><span class="comment"> 21: aload_1</span></span><br><span class="line"><span class="comment"> 22: invokespecial #5                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class="line"><span class="comment"> 25: astore_3</span></span><br><span class="line"><span class="comment"> 26: aload_2</span></span><br><span class="line"><span class="comment"> 27: invokevirtual #6                  // Method java/lang/Thread.start:()V</span></span><br><span class="line"><span class="comment"> 30: aload_3</span></span><br><span class="line"><span class="comment"> 31: invokevirtual #6                  // Method java/lang/Thread.start:()V</span></span><br><span class="line"><span class="comment"> 34: return</span></span><br><span class="line"><span class="comment"> static &#123;&#125;;</span></span><br><span class="line"><span class="comment"> Code:</span></span><br><span class="line"><span class="comment"> 0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> 3: new           #8                  // class java/lang/StringBuilder</span></span><br><span class="line"><span class="comment"> 6: dup</span></span><br><span class="line"><span class="comment"> 7: invokespecial #9                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="comment"> 10: invokestatic  #10                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span></span><br><span class="line"><span class="comment"> 13: invokevirtual #11                 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="comment"> 16: ldc           #12                 // String initDeadLoopClass</span></span><br><span class="line"><span class="comment"> 18: invokevirtual #13                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="comment"> 21: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> 24: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="comment"> 27: goto          27</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,<span class="number">5</span>,main]initDeadLoopClass</span><br><span class="line">通过分析：一条线程正在死循环以模拟长时间操作，另外一条线程在阻塞等待.</span><br><span class="line">线程堆栈如下:</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">29</span> <span class="number">20</span>:<span class="number">05</span>:<span class="number">00</span></span><br><span class="line"><span class="function">Full thread dump Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(<span class="number">25.91</span>-b14 mixed mode)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;Monitor Ctrl-Break&quot; #10 daemon prio</span>=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x0000000018554800</span> nid=<span class="number">0x4920</span> runnable [<span class="number">0x00000000190de000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.accept0(Native Method)</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:<span class="number">131</span>)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class="number">409</span>)</span><br><span class="line">        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:<span class="number">199</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000d79d67c0</span>&gt; (a java.net.SocksSocketImpl)</span><br><span class="line">        at java.net.ServerSocket.implAccept(ServerSocket.java:<span class="number">545</span>)</span><br><span class="line">        at java.net.ServerSocket.accept(ServerSocket.java:<span class="number">513</span>)</span><br><span class="line">        at com.intellij.rt.execution.application.AppMain$<span class="number">1.</span>run(AppMain.java:<span class="number">79</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Finalizer&quot;</span> #<span class="number">3</span> daemon prio=<span class="number">8</span> os_prio=<span class="number">1</span> tid=<span class="number">0x00000000027d8800</span> nid=<span class="number">0x2d14</span> in Object.wait() [<span class="number">0x000000001837e000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x00000000d7808ee0</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">143</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000d7808ee0</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">164</span>)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class="number">209</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Reference Handler&quot;</span> #<span class="number">2</span> daemon prio=<span class="number">10</span> os_prio=<span class="number">2</span> tid=<span class="number">0x00000000027d3000</span> nid=<span class="number">0x4914</span> in Object.wait() [<span class="number">0x000000001827f000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x00000000d7806b50</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000d7806b50</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">153</span>)</span><br><span class="line"><span class="string">&quot;main&quot;</span> #<span class="number">1</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x000000000220e000</span> nid=<span class="number">0x450c</span> runnable [<span class="number">0x00000000026de000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at sf.jvm.load.DeadLoopClass.&lt;clinit&gt;(DeadLoopClass.java:<span class="number">8</span>)</span><br><span class="line">        at java.lang.Class.forName0(Native Method)</span><br><span class="line">        at java.lang.Class.forName(Class.java:<span class="number">264</span>)</span><br><span class="line">        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">123</span>)</span><br><span class="line"><span class="string">&quot;VM Thread&quot;</span> os_prio=<span class="number">2</span> tid=<span class="number">0x0000000016ff7000</span> nid=<span class="number">0x6d4</span> runnable</span><br><span class="line"><span class="string">&quot;GC task thread#0 (ParallelGC)&quot;</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00000000026f7800</span> nid=<span class="number">0x4890</span> runnable</span><br><span class="line"><span class="string">&quot;GC task thread#1 (ParallelGC)&quot;</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00000000026f9000</span> nid=<span class="number">0x4514</span> runnable</span><br><span class="line"><span class="string">&quot;VM Periodic Task Thread&quot;</span> os_prio=<span class="number">2</span> tid=<span class="number">0x00000000184e1800</span> nid=<span class="number">0x4934</span> waiting on condition</span><br><span class="line">JNI global references: <span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2 类加载器"></a>2 类加载器</h3><h4 id="2-1-类加载器概述"><a href="#2-1-类加载器概述" class="headerlink" title="2.1 　类加载器概述"></a>2.1 　类加载器概述</h4><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。<br>类加载器可以说是 Java 语言的一项创新，也是 Java 语言流行的重要原因之一，它最初是为了满足 JavaApplet 的需求而被开发出来的。如今 JavaApplet 技术基本上已经死掉[1]，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了 Java 技术体系中一块重要的基石。<br>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h4 id="2-2-类加载器的结构"><a href="#2-2-类加载器的结构" class="headerlink" title="2.2 类加载器的结构"></a>2.2 类加载器的结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">启动类加载器--&gt;扩展类加载器</span><br><span class="line">扩展类加载器--&gt;应用类加载器</span><br><span class="line">应用类加载器--&gt;自定义加载器1</span><br><span class="line">应用类加载器--&gt;自定义加载器2</span><br></pre></td></tr></table></figure><p>Java 虚拟机的角度讲，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用 C++语言实现[2]，是虚拟机自身的一部分；另外一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度来看，类加载器就还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下三种系统提供的类加载器：：<br>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。<br>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br>应用程序类加载器（application class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。<br>除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p>破坏双亲委派模型<br>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即 JDK1.2 发布之前。由于双亲委派模型在 JDK1.2 之后才被引入的，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()，<br>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办了？这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK1.3 时代放进去的 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，ServiceProviderInterface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ThreadContextClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。<br>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热”门的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的电脑外设那样，插上鼠标或 U 盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。在 JSR-297[4]、JSR-277[5]规范从纸上标准变成真正可运行的程序之前，OSGi 是当前业界“事实上”的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。<br>在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p><blockquote><p>（1）将以 java.*开头的类，委派给父类加载器加载。<br>（2）否则，将委派列表名单内的类，委派给父类加载器加载。<br>（3）否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载。<br>（4）否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。<br>（5）否则，查找类是否在自己的 FragmentBundle 中，如果在，则委派给 FragmentBundle 的类加载器加载。<br>（6）否则，查找 DynamicImport 列表的 Bundle，委派给对应 Bundle 的类加载器加载。<br>（7）否则，类查找失败。上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p></blockquote><p>虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可算作一种创新。正如 OSGi 中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在 Java 程序员中基本有一个共识：OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，自然就明白了类加载器的精粹。<br>//TODO<br>OSGI</p><h4 id="2-3-自定义类加载器实例"><a href="#2-3-自定义类加载器实例" class="headerlink" title="2.3 自定义类加载器实例:"></a>2.3 自定义类加载器实例:</h4><h5 id="2-3-1-文件加载"><a href="#2-3-1-文件加载" class="headerlink" title="2.3.1 文件加载:"></a>2.3.1 文件加载:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sf.jvm.load.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">      <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">      String path = classNameToPath(className);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">          ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">          <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">          <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">          <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">              baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> rootDir + File.separatorChar + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String classDataRootPath = <span class="string">&quot;D:\\Code\\Jcode\\notes\\java-jlp\\java-jvm\\target\\classes&quot;</span>;</span><br><span class="line">      FileSystemClassLoader fileSystemClassLoader1 = <span class="keyword">new</span> FileSystemClassLoader(classDataRootPath);</span><br><span class="line">      FileSystemClassLoader fileSystemClassLoader2 = <span class="keyword">new</span> FileSystemClassLoader(classDataRootPath);</span><br><span class="line">      String className = <span class="string">&quot;sf.jvm.load.simple.Sample&quot;</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Class&lt;?&gt; class1 = fileSystemClassLoader1.loadClass(className);</span><br><span class="line">          Object obj1 = class1.newInstance();</span><br><span class="line">          Class&lt;?&gt; class2 = fileSystemClassLoader1.loadClass(className);</span><br><span class="line">          Object obj2 = class2.newInstance();</span><br><span class="line">          Method setSampleMethod = class1.getMethod(<span class="string">&quot;setSample&quot;</span>, Object.class);</span><br><span class="line">          setSampleMethod.invoke(obj1, obj2);</span><br><span class="line">          Method setSampleMethod2 = class1.getMethod(<span class="string">&quot;compare&quot;</span>, Object.class);</span><br><span class="line">          setSampleMethod2.invoke(obj1, obj2);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-网络加载"><a href="#2-3-2-网络加载" class="headerlink" title="2.3.2 网络加载:"></a>2.3.2 网络加载:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sf.jvm.load.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sf.jvm.load.api.ICalculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String rootUrl;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NetworkClassLoader</span><span class="params">(String rootUrl)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.rootUrl = rootUrl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">      <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">      String path = classNameToPath(className);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">          InputStream ins = url.openStream();</span><br><span class="line">          ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">          <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">          <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">          <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">              baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> rootUrl + <span class="string">&quot;/&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String url = <span class="string">&quot;http://localhost:8080/ClassloaderTest/classes&quot;</span>;</span><br><span class="line">      NetworkClassLoader ncl = <span class="keyword">new</span> NetworkClassLoader(url);</span><br><span class="line">      String basicClassName = <span class="string">&quot;sf.jvm.load.simple.CalculatorBasic&quot;</span>;</span><br><span class="line">      String advancedClassName = <span class="string">&quot;sf.jvm.load.simple.CalculatorAdvanced&quot;</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Class&lt;?&gt; clazz = ncl.loadClass(basicClassName);</span><br><span class="line">          ICalculator calculator = (ICalculator) clazz.newInstance();</span><br><span class="line">          System.out.println(calculator.getVersion());</span><br><span class="line">          clazz = ncl.loadClass(advancedClassName);</span><br><span class="line">          calculator = (ICalculator) clazz.newInstance();</span><br><span class="line">          System.out.println(calculator.getVersion());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载机制&quot;&gt;&lt;a href=&quot;#类加载机制&quot; class=&quot;headerlink&quot; title=&quot;类加载机制&quot;&gt;&lt;/a&gt;类加载机制&lt;/h1&gt;&lt;h3 id=&quot;1-类的加载过程&quot;&gt;&lt;a href=&quot;#1-类的加载过程&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM常见参数设置</title>
    <link href="http://example.com/2021/08/04/language/jvm/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"/>
    <id>http://example.com/2021/08/04/language/jvm/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-08-04T06:25:13.663Z</published>
    <updated>2021-08-04T06:25:13.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看"><a href="#1-查看" class="headerlink" title="1. 查看"></a>1. 查看</h2><p><strong>-XX:+PrintFlagsFinal</strong></p><ul><li><p>查看堆的默认值，使用下面的代码。<br>其中 InitialHeapSize 为最开始的堆的大小，MaxHeapSize 为堆的最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br><span class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 134217728                           &#123;product&#125;</span><br><span class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 2147483648                          &#123;product&#125;</span><br><span class="line">java version &quot;1.8.0_25&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_25-b17)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看栈的默认值, 其中 ThreadStackSize 为栈内存的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</span><br><span class="line"> intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class="line"> intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class="line"> intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class="line">java version &quot;1.8.0_25&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_25-b17)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/804884/1627721065789-f0943cfd-fbc6-4efd-847f-5661628e8a9e.png#clientId=ud7a2e44c-082c-4&from=paste&id=uac2b358e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=593&originalType=url&ratio=1&size=88416&status=done&style=none&taskId=u6a74a41e-6989-4ec2-b966-583063cd2d7" alt="image.png"></p></li><li><p>-Xmx：初始堆的大小</p></li><li><p>-Xms：最大堆大小，建议这两个参数大小保持一致，为物理内存的 1/4</p></li><li><p>-Xmn：指定新生代的大小（Eden + Survior from + Survior to）的大小，增大新生代的大小，老年代的大小将被减小，sun 官方推荐 新生代的大小：堆 = 3 : 8</p></li><li><p>-XX:NewSize：设置新生代大小</p></li><li><p>-XX:MaxNewSize：设置新生代的最大值-Xmn 相当于设同时设置 NewSize=MaxNewSize</p></li><li><p>-XX:NewRation：老年代：新生代 = 4，即 old：(Eden + Survivor from + Survivor to) ，则说明新生代为整个堆区的 1/5</p></li><li><p>-XX:SurvivorRation：设置 Eden 区和 Survivor。<br>默认值为8；即：Eden：Survivor=8:1 ==&gt; Eden：Survivor from：Survivor to = 8:1:1<br>若值为3，即：Eden：Survivor=8:1 ==&gt; Eden：Survivor from：Survivor to = 3:1:1</p><h2 id="3-方法区（非堆）"><a href="#3-方法区（非堆）" class="headerlink" title="3. 方法区（非堆）"></a>3. 方法区（非堆）</h2></li><li><p>-XX:PermSize：设置方法区大小</p></li><li><p>-XX:MaxPermSize： 设置方法区的最大值</p></li><li><p>1.8 之前可以理解为 永久区（PerSize，MaxPerSize）。</p></li><li><p>1.8 之后使用 元数据区 取代。（MaxMetaspaceSize）。</p><h2 id="4-栈"><a href="#4-栈" class="headerlink" title="4. 栈"></a>4. 栈</h2></li><li><p>-Xss：栈内存的大小</p><h2 id="5-详细参数"><a href="#5-详细参数" class="headerlink" title="5. 详细参数"></a>5. 详细参数</h2><h3 id="5-1-基础参数"><a href="#5-1-基础参数" class="headerlink" title="5.1.基础参数"></a>5.1.基础参数</h3><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th></th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td><strong>注意</strong>：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。</td></tr><tr><td>整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.</td><td></td><td></td><td></td></tr><tr><td>增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td><td></td><td></td><td></td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K. 根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右</td></tr><tr><td>一般小的应用， 如果栈不是很深， 应该128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。</td><td></td><td></td><td></td></tr><tr><td>和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”. 一般设置128k或者256k这个值就可以了。</td><td></td><td></td><td></td></tr><tr><td>-<em>XX:ThreadStackSize</em></td><td>Thread Stack Size</td><td></td><td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5</td></tr><tr><td>Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td><td></td><td></td><td></td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:LargePageSizeInBytes</td><td>内存页的大小不可设置过大， 会影响Perm的大小</td><td></td><td>=128m</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>原始类型的快速优化</td><td></td><td></td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td></td><td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率</td></tr><tr><td>该参数只有在串行GC时才有效.</td><td></td><td></td><td></td></tr><tr><td>-XX:+AggressiveOpts</td><td>加快编译</td><td></td><td></td></tr><tr><td>-XX:+UseBiasedLocking</td><td>锁机制的性能改善</td><td></td><td></td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收</td><td></td><td></td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB</td><td>每兆堆空闲空间中SoftReference的存活时间</td><td>1s</td><td>softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效</td></tr><tr><td>另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td><td></td><td></td><td></td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比</td><td>1%</td><td></td></tr><tr><td>-XX:+<em>CollectGen0First</em></td><td>FullGC时是否先YGC</td><td>false</td><td></td></tr></tbody></table></li></ul><h3 id="5-2-并行收集器相关参数"><a href="#5-2-并行收集器相关参数" class="headerlink" title="5.2 并行收集器相关参数"></a>5.2 并行收集器相关参数</h3><p>| -XX:+UseParallelGC | Full GC采用parallel MSC<br>(此项待验证) |   | 选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证) |<br>| — | — | — | — |<br>| -XX:+UseParNewGC | 设置年轻代为并行收集 |   | 可与CMS收集同时使用<br>JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 |<br>| -XX:ParallelGCThreads | 并行收集器的线程数 |   | 此值最好配置与处理器数目相等 同样适用于CMS |<br>| -XX:+UseParallelOldGC | 年老代垃圾收集方式为并行收集(Parallel Compacting) |   | 这个是JAVA 6出现的参数选项 |<br>| -XX:MaxGCPauseMillis | 每次年轻代垃圾回收的最长时间(最大暂停时间) |   | 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. |<br>| -XX:+UseAdaptiveSizePolicy | 自动选择年轻代区大小和相应的Survivor区比例 |   | 设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. |<br>| -XX:GCTimeRatio | 设置垃圾回收时间占程序运行时间的百分比 |   | 公式为1/(1+n) |<br>| -XX:+<em>ScavengeBeforeFullGC</em> | Full GC前调用YGC | true | Do young generation GC prior to a full GC. (Introduced in 1.4.1.) |</p><h3 id="5-3-CMS相关参数"><a href="#5-3-CMS相关参数" class="headerlink" title="5.3 CMS相关参数"></a>5.3 CMS相关参数</h3><table><thead><tr><th>-XX:+UseConcMarkSweepGC</th><th>使用CMS内存收集</th><th></th><th>测试中配置这个以后,-XX:NewRatio=4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</th></tr></thead><tbody><tr><td>-XX:+AggressiveHeap</td><td></td><td></td><td>试图是使用大量的物理内存</td></tr><tr><td>长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）</td><td></td><td></td><td></td></tr><tr><td>至少需要256MB内存</td><td></td><td></td><td></td></tr><tr><td>大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td><td></td><td></td><td></td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td>多少次后进行内存压缩</td><td></td><td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td></tr><tr><td>-XX:+CMSParallelRemarkEnabled</td><td>降低标记停顿</td><td></td><td></td></tr><tr><td>-XX+UseCMSCompactAtFullCollection</td><td>在FULL GC的时候， 对年老代的压缩</td><td></td><td>CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。</td></tr><tr><td>可能会影响性能,但是可以消除碎片</td><td></td><td></td><td></td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>使用手动定义初始化定义开始CMS收集</td><td></td><td>禁止hostspot自行触发CMS GC</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction=70</td><td>使用cms作为垃圾回收</td><td></td><td></td></tr><tr><td>使用70％后开始CMS收集</td><td>92</td><td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式<a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html#CMSInitiatingOccupancyFraction_value">CMSInitiatingOccupancyFraction计算公式</a></td><td></td></tr><tr><td>-XX:CMSInitiatingPermOccupancyFraction</td><td>设置Perm Gen使用到达多少比率时触发</td><td>92</td><td></td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>设置为增量模式</td><td></td><td>用于单CPU情况</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td></td><td></td><td></td></tr></tbody></table><h3 id="5-4-辅助信息"><a href="#5-4-辅助信息" class="headerlink" title="5.4 辅助信息"></a>5.4 辅助信息</h3><p>| -XX:+PrintGC |   |   | 输出形式:<br>[GC 118250K-&gt;113543K(130112K), 0.0094143 secs]<br>[Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] |<br>| — | — | — | — |<br>| -XX:+PrintGCDetails |   |   | 输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]<br>[GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] |<br>| -XX:+PrintGCTimeStamps |   |   |   |<br>| -XX:+PrintGC:PrintGCTimeStamps |   |   | 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用<br>输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] |<br>| -XX:+PrintGCApplicationStoppedTime | 打印垃圾回收期间程序暂停的时间.可与上面混合使用 |   | 输出形式:Total time for which application threads were stopped: 0.0468229 seconds |<br>| -XX:+PrintGCApplicationConcurrentTime | 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 |   | 输出形式:Application time: 0.5291524 seconds |<br>| -XX:+PrintHeapAtGC | 打印GC前后的详细堆栈信息 |   |   |<br>| -Xloggc:filename | 把相关日志信息记录到文件以便分析.<br>与上面几个配合使用 |   |   |<br>| -XX:+PrintClassHistogram | garbage collects before printing the histogram. |   |   |<br>| -XX:+PrintTLAB | 查看TLAB空间的使用情况 |   |   |<br>| XX:+PrintTenuringDistribution | 查看每次minor GC后新的存活周期的阈值 |   | Desired survivor size 1048576 bytes, new threshold 7 (max 15)<br>new threshold 7即标识新的存活周期的阈值为7。 |</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><p><a href="https://juejin.cn/post/6844903740848242695">https://juejin.cn/post/6844903740848242695</a><br><a href="http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html">http://ssword.cn/f/view-3-be0e37a28e984c9c832a864b70d615cf.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-查看&quot;&gt;&lt;a href=&quot;#1-查看&quot; class=&quot;headerlink&quot; title=&quot;1. 查看&quot;&gt;&lt;/a&gt;1. 查看&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;-XX:+PrintFlagsFinal&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看堆的默认</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能监控及故障分析工具</title>
    <link href="http://example.com/2021/08/04/language/jvm/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2021/08/04/language/jvm/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</id>
    <published>2021-08-04T06:25:13.663Z</published>
    <updated>2021-08-04T06:25:13.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-性能监控及故障分析工具"><a href="#JVM-性能监控及故障分析工具" class="headerlink" title="JVM 性能监控及故障分析工具"></a>JVM 性能监控及故障分析工具</h1><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h2><p>JDK官方提供了不少好用的JAVA故障处理工具,JDK的命令行工具在JDK的bin目录下供用户使用。</p><h2 id="２-jps"><a href="#２-jps" class="headerlink" title="２.jps"></a>２.jps</h2><h3 id="２-1-简介"><a href="#２-1-简介" class="headerlink" title="２.1.简介"></a>２.1.简介</h3><p>jps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。<br>命令格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid] </span><br></pre></td></tr></table></figure><p>options 参数详解:<br>参数 | 解释<br>—-| —-<br> -q | 仅输出VM标识符，不包括classname,jar name,arguments in main method<br> -m | 输出main method的参数<br> -l | 输出完全的包名，应用主类名，jar的完全路径名<br> -v | 输出jvm参数<br> -V | 输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件<br> -J | 传递参数到vm,例如:-J-Xms512m<br>hostid 参数解释:<br>[protocol:][[//]hostname][:port][/servername]</p><h3 id="２-２-实例"><a href="#２-２-实例" class="headerlink" title="２.２.实例"></a>２.２.实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jps</span><br><span class="line"><span class="number">3201</span> Jps</span><br><span class="line"><span class="number">20819</span> AuthBootstrap</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jps -lv</span><br><span class="line"><span class="number">20819</span> com.feinno.urcs.auth.main.AuthBootstrap -Duser.dir=/home/urcs/urcs-as-authentication -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jps -lvm <span class="number">10.10</span><span class="number">.220</span><span class="number">.101</span></span><br><span class="line">RMI Registry not available at <span class="number">10.10</span><span class="number">.220</span><span class="number">.101</span>:<span class="number">1099</span></span><br><span class="line">Connection refused to host: <span class="number">10.10</span><span class="number">.220</span><span class="number">.101</span>; nested exception is:java.net.ConnectException: Connection refused。</span><br><span class="line">需要在远程机器上开启：jstatd</span><br></pre></td></tr></table></figure><h2 id="3-jstat"><a href="#3-jstat" class="headerlink" title="3.jstat"></a>3.jstat</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h3><p>Jstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，它位于Java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。可见，Jstat是轻量级的、专门针对JVM的工具。<br>命令格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [options]</span><br></pre></td></tr></table></figure><h3 id="3-2-options-参数详解"><a href="#3-2-options-参数详解" class="headerlink" title="3.2.options 参数详解:"></a>3.2.options 参数详解:</h3><ul><li>3.2.1. jstat -class <pid> : 显示加载 class 的数量,及所占空间等信息,</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>Loaded</td><td>装载的类的数量</td></tr><tr><td>Bytes</td><td>装载类所占用的字节数</td></tr><tr><td>Unloaded</td><td>卸载类的数量</td></tr><tr><td>Bytes</td><td>卸载类的字节数</td></tr><tr><td>Time</td><td>装载和卸载类所花费的时间</td></tr></tbody></table><ul><li>3.2.2.jstat -compiler <pid>:显示 VM 实时编译的数量等信息,</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>Compiled</td><td>编译任务执行数量</td></tr><tr><td>Failed</td><td>编译任务执行失败数量</td></tr><tr><td>Invalid</td><td>编译任务执行失效数量</td></tr><tr><td>Time</td><td>编译任务消耗时间</td></tr><tr><td>FailedType</td><td>最后一个编译失败任务的类型</td></tr><tr><td>FailedMethod</td><td>最后一个编译失败任务所在的类及方法</td></tr></tbody></table><ul><li>3.2.3.jstat -gc <pid>: 可以显示 gc 的信息,查看 gc 的次数,及时间,</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>S0C</td><td>年轻代中第一个 survivor(幸存区)的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个 survivor(幸存区)的容量(字节)</td></tr><tr><td>S0U</td><td>年轻代中第一个 survivor(幸存区)目前已使用空间(字节)</td></tr><tr><td>S1U</td><td>年轻代中第二个 survivor(幸存区)目前已使用空间(字节)</td></tr><tr><td>EC</td><td>年轻代中 Eden(伊甸园)的容量(字节)</td></tr><tr><td>EU</td><td>年轻代中 Eden(伊甸园)目前已使用空间(字节)</td></tr><tr><td>OC</td><td>Old 代的容量(字节)</td></tr><tr><td>OU</td><td>Old 代目前已使用空间(字节)</td></tr><tr><td>PC</td><td>Perm(持久代)的容量(字节)</td></tr><tr><td>PU</td><td>Perm(持久代)目前已使用空间(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中 gc 次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时 gc 用的总时间(s)</td></tr></tbody></table><ul><li> 3.2.4. jstat -gccapacity <pid>:可以显示,VM 内存中三代(young,old,perm)对象的使用和占用大小</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>NGCMN</td><td>年轻代(young)中初始化(最小)的大小(字节)</td></tr><tr><td>NGCMX</td><td>年轻代(young)的最大容量(字节)</td></tr><tr><td>NGC</td><td>年轻代(young)中当前的容量(字节)</td></tr><tr><td>S0C</td><td>年轻代中第一个 survivor(幸存区)的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个 survivor(幸存区)的容量(字节)</td></tr><tr><td>EC</td><td>年轻代中 Eden(伊甸园)的容量(字节)</td></tr><tr><td>OGCMN</td><td>old 代中初始化(最小)的大小(字节)</td></tr><tr><td>OGCMX</td><td>old 代的最大容量(字节)</td></tr><tr><td>OGC</td><td>old 代当前新生成的容量(字节)</td></tr><tr><td>OC</td><td>Old 代的容量(字节)</td></tr><tr><td>PGCMN</td><td>perm 代中初始化(最小)的大小(字节)</td></tr><tr><td>PGCMX</td><td>perm 代的最大容量(字节)</td></tr><tr><td>PGC</td><td>perm 代当前新生成的容量(字节)</td></tr><tr><td>PC</td><td>Perm(持久代)的容量(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中 gc 次数</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td></tr></tbody></table><ul><li>3.2.5.jstat -gcutil <pid>:统计 gc 信息</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>S0</td><td>年轻代中第一个 survivor(幸存区)已使用的占当前容量百分比</td></tr><tr><td>S1</td><td>年轻代中第二个 survivor(幸存区)已使用的占当前容量百分比</td></tr><tr><td>E</td><td>年轻代中 Eden(伊甸园)已使用的占当前容量百分比</td></tr><tr><td>O</td><td>old 代已使用的占当前容量百分比</td></tr><tr><td>P</td><td>perm 代已使用的占当前容量百分比</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中 gc 次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时 gc 用的总时间(s)</td></tr></tbody></table><ul><li>3.2.6. jstat -gcnew <pid>:年轻代对象的信息,</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>S0C</td><td>年轻代中第一个 survivor(幸存区)的容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个 survivor(幸存区)的容量(字节)</td></tr><tr><td>S0U</td><td>年轻代中第一个 survivor(幸存区)目前已使用空间(字节)</td></tr><tr><td>S1U</td><td>年轻代中第二个 survivor(幸存区)目前已使用空间(字节)</td></tr><tr><td>TT</td><td>持有次数限制</td></tr><tr><td>MTT</td><td>最大持有次数限制</td></tr><tr><td>EC</td><td>年轻代中 Eden(伊甸园)的容量(字节)</td></tr><tr><td>EU</td><td>年轻代中 Eden(伊甸园)目前已使用空间(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中 gc 次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中 gc 所用时间(s)</td></tr></tbody></table><ul><li>3.2.7. jstat -gcnewcapacity <pid>: 年轻代对象的信息及其占用量,</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>NGCMN</td><td>年轻代(young)中初始化(最小)的大小(字节)</td></tr><tr><td>NGCMX</td><td>年轻代(young)的最大容量(字节)</td></tr><tr><td>NGC</td><td>年轻代(young)中当前的容量(字节)</td></tr><tr><td>S0CMX</td><td>年轻代中第一个 survivor(幸存区)的最大容量(字节)</td></tr><tr><td>S0C</td><td>年轻代中第一个 survivor(幸存区)的容量(字节)</td></tr><tr><td>S1CMX</td><td>年轻代中第二个 survivor(幸存区)的最大容量(字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个 survivor(幸存区)的容量(字节)</td></tr><tr><td>ECMX</td><td>年轻代中 Eden(伊甸园)的最大容量(字节)</td></tr><tr><td>EC</td><td>年轻代中 Eden(伊甸园)的容量(字节)</td></tr></tbody></table><ul><li>3.2.8. jstat -gcold <pid>:old 代对象的信息,</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>PC</td><td>Perm(持久代)的容量(字节)</td></tr><tr><td>PU</td><td>Perm(持久代)目前已使用空间(字节)</td></tr><tr><td>OC</td><td>Old 代的容量(字节)</td></tr><tr><td>OU</td><td>Old 代目前已使用空间(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中 gc 次数</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时 gc 用的总时间(s)</td></tr></tbody></table><ul><li>3.2.9.stat -gcoldcapacity <pid>: old 代对象的信息及其占用量</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>OGCMN</td><td>old 代中初始化(最小)的大小(字节)</td></tr><tr><td>OGCMX</td><td>old 代的最大容量(字节)</td></tr><tr><td>OGC</td><td>old 代当前新生成的容量(字节)</td></tr><tr><td>OC</td><td>Old 代的容量(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中 gc 次数</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时 gc 用的总时间(s)</td></tr></tbody></table><ul><li>3.2.10. jstat -gcpermcapacity<pid>: perm 对象的信息及其占用量,</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>PGCMN</td><td>perm 代中初始化(最小)的大小(字节)</td></tr><tr><td>PGCMX</td><td>perm 代的最大容量(字节)</td></tr><tr><td>PGC</td><td>perm 代当前新生成的容量(字节)</td></tr><tr><td>PC</td><td>Perm(持久代)的容量(字节)</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中 gc 次数</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时 old 代(全 gc)gc 次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时 old 代(全 gc)gc 所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时 gc 用的总时间(s)</td></tr></tbody></table><ul><li>3.2.11. jstat -printcompilation <pid>:当前 VM 执行的信息,</li></ul><table><thead><tr><th>显示列名</th><th>具体描述</th></tr></thead><tbody><tr><td>Compiled</td><td>编译任务的数目</td></tr><tr><td>Size</td><td>方法生成的字节码的大小</td></tr><tr><td>Type</td><td>编译类型</td></tr><tr><td>Method</td><td>类名和方法名用来标识编译的方法,类名使用/做为一个命名空间分隔符,方法名是给定类中的方法,上述格式是由-XX:+PrintComplation 选项进行设置的</td></tr></tbody></table><h3 id="3-3-实例"><a href="#3-3-实例" class="headerlink" title="3.3.实例:"></a>3.3.实例:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jstat -gcutil <span class="number">16885</span> <span class="number">1000</span></span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  <span class="number">0.00</span>  <span class="number">93.51</span>  <span class="number">54.24</span>  <span class="number">10.36</span>  <span class="number">98.25</span>  <span class="number">96.86</span>    <span class="number">205</span>   <span class="number">16.720</span>     <span class="number">3</span>    <span class="number">1.041</span>   <span class="number">17.760</span></span><br><span class="line">  <span class="number">0.00</span>  <span class="number">93.51</span>  <span class="number">54.24</span>  <span class="number">10.36</span>  <span class="number">98.25</span>  <span class="number">96.86</span>    <span class="number">205</span>   <span class="number">16.720</span>     <span class="number">3</span>    <span class="number">1.041</span>   <span class="number">17.760</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jstat -<span class="class"><span class="keyword">class</span> 16885 1000</span></span><br><span class="line"><span class="class"><span class="title">Loaded</span>  <span class="title">Bytes</span>  <span class="title">Unloaded</span>  <span class="title">Bytes</span>     <span class="title">Time</span></span></span><br><span class="line"><span class="class"> 10051 19327.1       32    44.2      27.15</span></span><br><span class="line"><span class="class"> 10051 19327.1       32    44.2      27.15</span></span><br></pre></td></tr></table></figure><h2 id="4-jinfo"><a href="#4-jinfo" class="headerlink" title="4.jinfo"></a>4.jinfo</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1.简介"></a>4.1.简介</h3><p>jinfo(Java Configuration Information)，主要用于查看指定Java进程(或核心文件、远程调试服务器)的Java配置信息。<br>命令格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jinfo [options] pid</span><br><span class="line">jinfo [options] executable core</span><br><span class="line">jinfo [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure><p>参数详解:<br>参数 | 解释<br>—-| —-<br> pid  | 进程号<br> executable | 产生core dump的java executable<br> core  | core file<br> remote-hostname-or-IP  | 主机名或ip<br> server-id | 远程主机上的debug server的唯一id</p><p>options 参数详解:</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>no option</td><td>打印命令行参数和系统属性</td></tr><tr><td>-flags</td><td>打印命令行参数</td></tr><tr><td>-sysprops</td><td>打印系统属性</td></tr><tr><td>-h</td><td>帮助</td></tr></tbody></table><h3 id="4-2-实例"><a href="#4-2-实例" class="headerlink" title="4.2.实例"></a>4.2.实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jinfo <span class="number">16885</span></span><br><span class="line">Attaching to process ID <span class="number">16885</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.65</span>-b01</span><br><span class="line">Java System Properties:</span><br><span class="line">java.runtime.name = Java(TM) SE Runtime Environment</span><br><span class="line">java.vm.version = <span class="number">25.65</span>-b01</span><br><span class="line">sun.boot.library.path = /usr/local/jdk8u65/jre/lib/amd64</span><br><span class="line">java.vendor.url = http:<span class="comment">//java.oracle.com/</span></span><br><span class="line">java.vm.vendor = Oracle Corporation</span><br><span class="line">path.separator = :</span><br><span class="line">file.encoding.pkg = sun.io</span><br><span class="line">java.vm.name = <span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM</span></span><br><span class="line"><span class="function">.....</span></span><br><span class="line"><span class="function">VM Flags:</span></span><br><span class="line"><span class="function">Non-<span class="keyword">default</span> VM flags: -XX:CICompilerCount</span>=<span class="number">2</span> -XX:InitialHeapSize=<span class="number">1073741824</span> -XX:MaxHeapSize=<span class="number">1073741824</span> -XX:MaxNewSize=<span class="number">357564416</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">357564416</span> -XX:OldSize=<span class="number">716177408</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC</span><br><span class="line">Command line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jinfo -flags <span class="number">16885</span></span><br><span class="line">Attaching to process ID <span class="number">16885</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.65</span>-b01</span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:CICompilerCount=<span class="number">2</span> -XX:InitialHeapSize=<span class="number">1073741824</span> -XX:MaxHeapSize=<span class="number">1073741824</span> -XX:MaxNewSize=<span class="number">357564416</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">357564416</span> -XX:OldSize=<span class="number">716177408</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC</span><br><span class="line">Command line:  -Duser.dir=/home/urcs/urcs-as-im -Xmx1024m -Xms1024m</span><br></pre></td></tr></table></figure><h2 id="5-jmap"><a href="#5-jmap" class="headerlink" title="5.jmap"></a>5.jmap</h2><h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1.简介"></a>5.1.简介</h3><p>jps是jdk提供的查看当前java进程的工具，简单看作为JavaVirtual Machine Process Status Tool。<br>命令格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap [options] pid</span><br><span class="line">jmap [options] executable core</span><br><span class="line">jmap [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure><p>参数详解:<br>参数 | 解释<br>—-| —-<br> pid  | 进程号<br> executable | 产生core dump的java executable<br> core  | core file<br> remote-hostname-or-IP  | 主机名或ip<br> server-id | 远程主机上的debug server的唯一id</p><p>options 参数详解:<br>参数 | 解释<br>—-| —-<br>-dump:[live,]format=b,file=<filename> | 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件.<br>-finalizerinfo | 打印正等候回收的对象的信息.<br>-heap  | 打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况.<br>-histo[:live] | 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀”*”. 如果live子参数加上后,只统计活的对象数量.<br>-permstat | 打印classload和jvm heap长久层的信息. 包含每个classloader的名字,活泼性,地址,父classloader和加载的class数量. 另外,内部String的数量和占用内存数也会打印出来.<br>-F | 强迫.在pid没有相应的时候使用-dump或者-histo参数. 在这个模式下,live子参数无效.<br>-h | -help 打印辅助信息<br>-J | 传递参数给jmap启动的jvm.</p><h3 id="5-2-实例"><a href="#5-2-实例" class="headerlink" title="5.2.实例"></a>5.2.实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jmap -dump:live,format=b,file=/tmp/heap.dump <span class="number">16885</span></span><br><span class="line">Dumping heap to /tmp/heap.dump ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h2 id="6-jstack"><a href="#6-jstack" class="headerlink" title="6.jstack"></a>6.jstack</h2><h3 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1.简介"></a>6.1.简介</h3><p>jstack（ Stack Trace for Java） 命令 用于 生成 虚拟 机 当前 时刻 的 线程 快照（ 一般 称为 threaddump 或 javacore 文件）。 线程 快照 就是 当前 虚拟 机内 每一 条 线程 正在 执行 的 方法 堆栈 的 集合， 生成 线程 快照 的 主要 目的 是 定位 线程 出现 长时间 停顿 的 原因， 如 线程间死锁,死 循环,请求 外部 资源 导致 的 长时间 等待 等 都是 导致 线程 长时间 停顿 的 常见 原因。</p><p>命令格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack [options] pid</span><br><span class="line">jstack [options] executable core</span><br><span class="line">jstack [options] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure><p>参数详解:</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>pid</td><td>进程号</td></tr><tr><td>executable</td><td>产生 core dump 的 java executable</td></tr><tr><td>core</td><td>core file</td></tr><tr><td>remote-hostname-or-IP</td><td>主机名或 ip</td></tr><tr><td>server-id</td><td>远程主机上的 debug server 的唯一 id</td></tr></tbody></table><p>options 参数详解:</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-F</td><td>当 jstack [-l] pid 没有相应的时候强制打印栈信息</td></tr><tr><td>-l</td><td>长列表. 打印关于锁的附加信息,例如属于 java.util.concurrent 的 ownable synchronizers 列表.</td></tr><tr><td>-m</td><td>打印 java 和 native c/c++框架的所有栈信息.</td></tr><tr><td>-h</td><td>-help 打印帮助信息</td></tr></tbody></table><h3 id="6-2-实例"><a href="#6-2-实例" class="headerlink" title="6.2.实例"></a>6.2.实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[java<span class="meta">@RCS</span>-AS-<span class="number">01</span> root]$ jstack <span class="number">16885</span> &gt; /tmp/stack16885<span class="number">.1</span></span><br><span class="line"></span><br><span class="line">查看文件显示：</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">29</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">51</span></span><br><span class="line"><span class="function">Full thread dump Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(<span class="number">25.65</span>-b01 mixed mode)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;HikariCP connection <span class="title">filler</span> <span class="params">(pool HikariPool-<span class="number">11</span>)</span>&quot; #26011 daemon prio</span>=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x0000000000f46000</span> nid=<span class="number">0x2bde</span> waiting on condition [<span class="number">0x00007f334e8b4000</span>]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000000c25016e8</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:<span class="number">215</span>)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:<span class="number">2078</span>)</span><br><span class="line">        at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:<span class="number">467</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class="number">1066</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1127</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">............</span><br></pre></td></tr></table></figure><h2 id="7-jhat"><a href="#7-jhat" class="headerlink" title="7.jhat"></a>7.jhat</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1.简介"></a>7.1.简介</h3><p>提供 jhat（ JVM Heap Analysis Tool） 命令 与 jmap 搭配 使用， 来 分析 jmap 生成 的 堆 转储 快照。<br>命令格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　jhat -J-Xmx512m &lt;heap dump file&gt;</span><br></pre></td></tr></table></figure><p>备注:<br>jhat 内置 了 一个 微型 的 HTTP/ HTML 服务器， 生成 dump 文件 的 分析 结果 后， 可以 在 浏览器 中 查看。 不过 实事求是 地说， 在 实际 工作中， 除非 笔者 手上 真的 没有 别的 工具 可用， 否则 一般 都 不会 去 直接 使用 jhat 命令 来 分析 dump 文件， 主要原因 有 二： 一是 一般 不会 在 部署 应用 程序 的 服务器 上 直接 分析 dump 文件， 即使 可以 这样做， 也会 尽量 将dump 文件 拷贝 到 其他 机器[ 4] 上进 行 分析， 因为 分析 工作 是一 个 耗时 而且 消耗 硬件 资源 的 过程， 既然 都要 在 其他 机器 上 进行， 就 没 必要 受到 命令行 工具 的 限制 了。 另外 一个 原因 是 jhat 的 分析 功能 相对来说 比较 简陋， 后文 将会 介绍 到 的 VisualVM</p><h3 id="7-2-实例"><a href="#7-2-实例" class="headerlink" title="7.2.实例:"></a>7.2.实例:</h3><p>1、产生dump文件 c:&gt;jmap -dump:file=f:\yown\dump.bin   16912<br>Dumping heap to F:\apps\dump.txt …<br>Heap dump file created</p><p>2、生成站点分析报告，便于网络访问 c:&gt;jhat -J-Xmx512m -port 88f:\yown\dump.bin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Reading from f:\apps\dump.bin...</span><br><span class="line">Dump file created Thu Jul 26 16:31:36 CST 2012</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 2194971 objects...</span><br><span class="line">Chasing references, expect 438 dots.............................................</span><br><span class="line">................................................................................</span><br><span class="line">................................................................................</span><br><span class="line">................................................................................</span><br><span class="line">................................................................................</span><br><span class="line">.........................................................................</span><br><span class="line">Eliminating duplicate references................................................</span><br><span class="line">................................................................................</span><br><span class="line">................................................................................</span><br><span class="line">................................................................................</span><br><span class="line">................................................................................</span><br><span class="line">......................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 88</span><br><span class="line">Server is ready. 3.访问 http://localhost:88/ 这里记录了进程中所有类及实例个数</span><br></pre></td></tr></table></figure><h2 id="8-jvisualvm"><a href="#8-jvisualvm" class="headerlink" title="8.jvisualvm"></a>8.jvisualvm</h2><h3 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1.简介:"></a>8.1.简介:</h3><p>VisualVM（ All- in- One Java Troubleshooting Tool） 是 到 目前 为止， 随 JDK 发布 的 功能 最强 大的 运行 监视 和 故障 处理 程序， 并且 可以 预见 在 未来 一段时间 内 都是 官方 主力 发展 的 虚拟 机 故障 处理 工具。 官方 在 VisualVM 的 软件 说明 中写 上了“ All- in- One” 的 描述 字样， 预示 着 它 除了 运行 监视、 故障 处理 外， 还 提供 了 很多 其他 方面 的 功能。VisualVM 基于 NetBeans 平台 开发， 因此 它 一 开始 就 具备 了 插件 扩展 功能 的 特性， 通过 插件 扩展 支持， VisualVM 可以 做到：<br>·显示 虚拟 机 进程 及 进程 的 配置 和 环境 信息（ jps、 jinfo）<br>·监视 应用 程序 的 CPU、 GC、 堆、 方法 区 及 线程 的 信息（ jstat、 jstack）。<br>·dump 及 分析 堆 转储 快照（ jmap、 jhat）<br>·方法 级 的 程序 运行 性能 分析， 找出 被 调用 最多、 运行 时间 最长 的 方法<br>·离 线程 序 快照： 收集 程序 的 运行时 配置、 线程 dump、 内存 dump 等 信息 建立 一个 快照， 可以 将 快照 发送 开发者 处 进行 Bug 反馈。<br>·其他 plugins 的 无限 的 可能性</p><h3 id="8-2-界面展示如下图"><a href="#8-2-界面展示如下图" class="headerlink" title="8.2.界面展示如下图"></a>8.2.界面展示如下图</h3><p><img src="http://img.blog.csdn.net/20170729163459058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20170729163624195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="9-开启Java服务远程监控"><a href="#9-开启Java服务远程监控" class="headerlink" title="9.开启Java服务远程监控"></a>9.开启Java服务远程监控</h2><h3 id="9-1-启动脚本中添加如下参数"><a href="#9-1-启动脚本中添加如下参数" class="headerlink" title="9.1.启动脚本中添加如下参数"></a>9.1.启动脚本中添加如下参数</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_ARGS[<span class="number">2</span>]=<span class="string">&quot;-Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=10.10.220.101&quot;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-通过jvisualvm可以监控远程java服务，如下："><a href="#9-2-通过jvisualvm可以监控远程java服务，如下：" class="headerlink" title="9.2.通过jvisualvm可以监控远程java服务，如下："></a>9.2.通过jvisualvm可以监控远程java服务，如下：</h3><p><img src="http://img.blog.csdn.net/20170729163143819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM-性能监控及故障分析工具&quot;&gt;&lt;a href=&quot;#JVM-性能监控及故障分析工具&quot; class=&quot;headerlink&quot; title=&quot;JVM 性能监控及故障分析工具&quot;&gt;&lt;/a&gt;JVM 性能监控及故障分析工具&lt;/h1&gt;&lt;h2 id=&quot;1-概要&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="http://example.com/2021/08/04/language/jvm/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/08/04/language/jvm/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-08-04T06:25:13.662Z</published>
    <updated>2021-08-04T06:25:13.662Z</updated>
    
    <content type="html"><![CDATA[<p>##<center>JVM 内存模型</center> 1.内存模型结构图</p><p><img src="http://img.blog.csdn.net/20170724161538339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="**这里写图片描述**"></p><table><thead><tr><th>名称</th><th>特征</th><th>作用</th><th>配置参数</th><th>异常</th></tr></thead><tbody><tr><td>程序计数器</td><td>占用内存小，线程私有， 生命周期与线程相同</td><td>大致为字节码行号指示器</td><td>无</td><td>无</td></tr><tr><td>虚拟机栈</td><td>线程私有，生命周期与线程相同，使用连续的内存空间</td><td>Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息</td><td>-Xss</td><td>OutOfMemoryError，StackOverflowError</td></tr><tr><td>java 堆</td><td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td><td>保存对象实例，所有对象实例（包括数组）都要在堆上分配</td><td>-Xms-Xsx -Xmn</td><td>OutOfMemoryError</td></tr><tr><td>方法区</td><td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td><td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</td><td>-XX:PermSize:16M-XX:MaxPermSize64M</td><td>OutOfMemoryError</td></tr><tr><td>运行时常量池</td><td>方法区的一部分，具有动态性</td><td>存放字面量及符号引用</td><td>无</td><td>无</td></tr></tbody></table><h5>1.1 程序计数器</h5>程序 计数器（ Program Counter Register） 是一 块 较小 的 内存 空间， 它的 作用 可以 看做 是 当前 线程 所 执行 的 字节 码 的 行号 指示器。 在 虚拟 机 的 概念 模型 里（ 仅是 概念 模型， 各种 虚拟 机 可能 会 通过 一些 更 高效 的 方式 去 实现）， 字节 码 解释器 工作 时 就是 通过 改变 这个 计数器 的 值 来 选取 下一 条 需要 执行 的 字节 码 指令， 分支、 循环、 跳 转、 异常 处理、 线程 恢复 等 基础 功能 都 需要 依赖 这个 计数器 来 完成。由于 Java 虚拟 机 的 多 线程 是 通过 线程 轮流 切换 并 分配 处理器 执行 时间 的 方式 来 实现 的， 在任 何 一个 确定 的 时刻， 一个 处理器（ 对于 多 核 处理器 来说 是一 个 内核） 只会 执行 一条 线程 中的 指令。 因此， 为了 线程 切换 后能 恢复 到 正确 的 执行 位置， 每条 线程 都 需要 有一个 独立 的 程序 计数器， 各条 线程 之间 的 计数器 互不 影响， 独立 存储， 我们 称 这类 内存 区域 为“ 线程 私有” 的 内存。 如果 线程 正在 执行 的 是 一个 Java 方法， 这个 计数器 记录 的 是 正在 执行 的 虚拟 机 字节 码 指令 的 地址； 如果 正在 执 行的 是 Natvie 方法， 这个 计数器 值 则为 空（ Undefined）。 此 内存 区域 是 唯一 一个 在 Java 虚拟 机 规范 中 没有 规定 任何 OutOfMemoryError 情况 的 区域。<h5>1.2 Java 虚拟 机 栈</h5>与 程序 计数器 一样， Java 虚拟 机 栈（ Java Virtual Machine Stacks） 也是 线程 私有 的， 它的 生命 周期 与 线程 相同。 虚拟 机 栈 描述 的 是 Java 方法 执行 的 内存 模型： 每个 方法 被 执行 的 时候 都会 同时 创建 一个 栈 帧（ Stack Frame[ 1]） 用于 存储 局部 变 量表、 操作 栈、 动态 链接、 方法 出口 等 信息。 每一个 方法 被 调用 直至 执行 完成 的 过程， 就 对应 着 一个 栈 帧 在 虚拟 机 栈 中 从 入栈 到 出 栈 的 过程,对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。 经常 有人 把 Java 内存 区 分为 堆 内存（ Heap） 和 栈 内存（ Stack）， 这种 分法 比较 粗糙， Java 内存 区域 的 划分 实际上 远比 这 复杂。 这种 划分 方式 的 流行 只能 说明 大多数 程序员 最 关注 的、 与 对象 内存 分配 关系 最 密切 的 内存 区域 是 这 两块。 其中 所指 的“ 堆” 在后面 会 专门 讲述， 而 所指 的“ 栈” 就是 现在 讲的 虚拟 机 栈， 或者 说是 虚拟 机 栈 中的 局部 变量 表 部分。 局部 变量 表 存放 了 编译 期 可知 的 各种 基本 数据 类型（ boolean、 byte、 char、 short、 int、 float、 long、 double）、 对象 引用（ reference 类型， 它不 等同 于 对象 本身， 根据 不同 的 虚拟 机 实现， 它可 能 是一 个 指向 对象 起始 地址 的 引用 指针， 也可能 指向 一个 代表 对象 的 句柄 或者 其他 与此 对象 相关 的 位置） 和 returnAddress 类型（ 指向 了 一条 字节 码 指令 的 地址）。 其中 64 位 长度 的 long 和 double 类型 的 数据 会 占用 2 个 局部 变量 空间（Slot）， 其余 的 数据 类型 只占 用 1 个。 局部 变量 表 所需 的 内存 空间 在编 译 期间 完成 分配， 当 进入 一个 方法 时， 这个 方法 需 要在 帧 中 分配 多大 的 局部 变量 空间 是 完全 确定 的， 在 方法 运行 期间 不会 改变 局部 变 量表 的 大小。 在 Java 虚拟 机 规范 中， 对这 个 区域 规定了 两种 异常 状况： 如果 线程 请求 的 栈 深度 大于 虚拟 机 所 允许 的 深度， 将 抛出 StackOverflowError 异常； 如果 虚拟 机 栈 可以 动态 扩展（ 当前 大部分 的 Java 虚拟 机 都可 动态 扩展， 只不过 Java 虚拟 机 规范 中 也 允许 固定 长度 的 虚拟 机 栈）， 当 扩展 时 无法 申请 到 足够 的 内存 时会 抛出 OutOfMemoryError 异常。<h6>1.2.1 局部变量表</h6>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。 Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。<h6>1.2.2 操作数栈</h6>和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中。如下演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin  </span><br><span class="line">iload_0    <span class="comment">// push the int in local variable 0 ontothe stack  </span></span><br><span class="line">iload_1    <span class="comment">//push the int in local variable 1 onto the stack  </span></span><br><span class="line">iadd       <span class="comment">// pop two ints, add them, push result  </span></span><br><span class="line">istore_2   <span class="comment">// pop int, store into local variable 2  </span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>1. 指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中2. iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈3. istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。4. 局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。<p><img src="http://img.blog.csdn.net/20170727201918687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="**这里写图片描述**"><center></p><h6>1.2.3 动态连接<h6>虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接。<h6> 1.2.4 返回地址 <h6>方法的返回分为两种情况，一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者，一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置，如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址,，果是因为异常退出的，则是需要通过异常处理表来确定。方法的的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。<p><img src="http://img.blog.csdn.net/20170727204302809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></center></p><h6> 1.2.5 异常 <h6>在Java 虚拟机规范中，对虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。如下代码为请求大于虚拟机堆栈深度所出现的异常<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    java</span><br><span class="line">package com.sf.jvm;</span><br><span class="line">/**</span><br><span class="line">* VM Args：- Xss128k</span><br><span class="line">*/</span><br><span class="line">public class JavaVMStackSOF &#123;</span><br><span class="line">  private intstackLength=1;</span><br><span class="line">  public void stackLeak() &#123;</span><br><span class="line">    stackLength++;</span><br><span class="line">    stackLeak();</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args)throwsThrowable &#123;</span><br><span class="line">    JavaVMStackSOF oom =newJavaVMStackSOF();</span><br><span class="line">    try&#123;</span><br><span class="line">      oom.stackLeak();</span><br><span class="line">    &#125;catch(Throwable e) &#123;</span><br><span class="line">      System.out.println(&quot; stack length:&quot; + oom.stackLength);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行出现如下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack length:22337</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class="line">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class="line">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class="line">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class="line">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br><span class="line">at com.sf.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</span><br></pre></td></tr></table></figure><h4>1.3 本地 方法 栈</h4><p>本地 方法 栈（ Native Method Stacks） 与 虚拟 机 栈 所 发挥 的 作用 是非 常 相似 的， 其 区别 不过 是 虚拟 机 栈 为 虚拟 机 执行 Java 方法（ 也就是 字节 码） 服务， 而 本地 方法 栈 则是 为 虚拟 机 使 用到 的 Native 方法 服务。 虚拟 机 规范 中 对本 地 方法 栈 中的 方法 使用 的 语言、 使用 方式 与 数据 结构 并没有 强制 规定， 因此 具体 的 虚拟 机 可以 自由 实现 它。 甚至 有的 虚拟 机（ 譬如 Sun HotSpot 虚拟 机） 直接 就把 本地 方法 栈 和 虚拟 机 栈 合二为一。 与 虚拟 机 栈 一样， 本地 方法 栈 区域 也会 抛出 StackOverflowError 和 OutOfMemoryError 异常。</p><p>对于一个运行中的 Java 程序而言，它还可能会用到一些跟本地方法相关的数据区。当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。<br>　　本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让 Java 程序调用本地方法。<br>　　任何本地方法接口都会使用某种本地方法栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。<br>　　如果某个虚拟机实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当 C 程序调用一个 C 函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。<br>　　很可能本地方法接口需要回调 Java 虚拟机中的 Java 方法，在这种情况下，该线程会保存本地方法栈的状态并进入到另一个 Java 栈。<br>　　<img src="http://img.blog.csdn.net/20170727205440144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>　　这幅图展示了 JAVA 虚拟机内部线程运行的全景图。当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个 Java 方法，一个线程可能在整个生命周期中都执行 Java 方法，操作它的 Java 栈；或者它可能毫无障碍地在 Java 栈和本地方法栈之间跳转。</p><p>该线程首先调用了两个 Java 方法，而第二个 Java 方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。假设这是一个 C 语言栈，其间有两个 C 函数，第一个 C 函数被第二个 Java 方法当做本地方法调用，而这个 C 函数又调用了第二个 C 函数。之后第二个 C 函数又通过本地方法接口回调了一个 Java 方法（第三个 Java 方法），最终这个 Java 方法又调用了一个 Java 方法（它成为图中的当前方法）。<br>内存溢出实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">packagecom.sf.jvm;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：</span></span><br><span class="line"><span class="comment">* -Xss2M</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> classJavaVMStackOOM &#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">           Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> threadNum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    Thread thread =newThread(newRunnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dontStop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">threadNum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>throwsThrowable </span>&#123;</span><br><span class="line">JavaVMStackOOM oom =newJavaVMStackOOM();</span><br><span class="line">oom.stackLeakByThread();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行程序抛出如下异常：</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java. lang. OutOfMemoryError: unable to create <span class="keyword">new</span> <span class="keyword">native</span> thread</span><br></pre></td></tr></table></figure><h4>1.4 Java 堆<h4><p>Java 堆（ Java Heap） 是 Java 虚拟 机 所 管理 的 内存 中最 大的 一块。 Java 堆 是 被 所有 线程 共享 的 一块 内存 区域， 在 虚拟 机 启动 时 创建。 此 内存 区域 的 唯一 目的 就是 存放 对象 实例， 几乎 所有 的 对象 实例 都在 这里 分配 内存。 这一 点在 Java 虚拟 机 规范 中的 描述 是： 所有 的 对象 实例 以及 数组 都 要在 堆 上 分配[ 2]， 但是 随着 JIT 编译器 的 发展 与 逃逸 分析 技术 的 逐渐 成熟， 栈 上 分配、 标量 替换[ 3] 优化 技术 将会 导致 一些 微妙 的 变化 发生， 所有 的 对象 都 分配 在 堆 上 也 渐渐 变得 不是 那么“ 绝对” 了。 Java 堆 是 垃圾 收集 器 管理 的 主要 区域， 因此 很多 时候 也 被 称做“ GC 堆”（ Garbage Collected Heap）。 如果 从内 存 回收 的 角度 看， 由于 现在 收集 器 基本 都是 采 用的 分 代收 集 算法， 所以 Java 堆 中 还可以 细分 为： 新生代 和 老 年代； 再 细致 一点 的 有 Eden 空间、 From Survivor 空间、 To Survivor 空间 等。 如果 从内 存 分配 的 角度 看， 线程 共享 的 Java 堆 中 可能 划分 出 多个 线程 私有 的 分配 缓冲区（ Thread Local Allocation Buffer， TLAB）。 不过， 无论如何 划分， 都与 存放 内容 无关， 无论 哪个 区域， 存储 的 都 仍然是 对象 实例， 进一步 划分 的 目的 是 为了 更好 地 回收 内存， 或者 更快 地 分配 内存。 在 本章 中， 我们 仅仅 针对 内存 区域 的 作用 进行 讨论， Java 堆 中的 上述 各个 区域 的 分配 和 回收 等 细节 将会 是 下 一章 的 主题。 根据 Java 虚拟 机 规范 的 规定， Java 堆 可以 处于 物理上 不连续 的 内存 空间 中， 只要 逻辑上 是 连续 的 即可， 就 像 我们 的 磁盘 空间 一样。 在 实现 时， 既可以 实现 成 固定 大小 的， 也可以 是 可扩展 的， 不过 当前 主流 的 虚拟 机 都是 按照 可扩展 来 实现 的（ 通过- Xmx 和- Xms 控制）。<br>Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。<br>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。如下图所示：</p><p><img src="http://img.blog.csdn.net/20170727210308831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></center></p><p>从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。<br>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。<br>老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。<br>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。<br>因此，新生代实际可用的内存空间为 9/10 ( 即 90% )的新生代空间。</p><p>GC 堆<br>Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。<br>Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。<br>新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。<br>当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。<br>当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳<br>( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为 1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。<br>但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。<br>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。<br>现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。<br>另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。</p><p>设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息，执行上面代码，下面是其中一次执行的结果。</p><table><thead><tr><th>jvm 参数</th><th>解释</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小。如：-Xms256m</td></tr><tr><td>-Xmx</td><td>最大堆大小。如：-Xmx512m</td></tr><tr><td>-Xmn</td><td>新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</td></tr><tr><td>-Xss</td><td>JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</td></tr><tr><td>-XX:NewRatio</td><td>新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的 1/3，老年代占 2/3</td></tr><tr><td>-XX:SurvivorRatio</td><td>新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</td></tr><tr><td>-XX:PermSize</td><td>永久代(方法区)的初始大小</td></tr><tr><td>-XX:MaxPermSize</td><td>永久代(方法区)的最大值</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印 GC 信息</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</td></tr></tbody></table><p>Java 堆 用于 储存 对象 实例， 我们 只要 不断 地 创建 对象， 并且 保证 GC Roots 到 对象 之间 有可 达 路径 来 避免 垃圾 回收 机制 清除 这些 对象， 就会 在 对象 数量 到达 最 大堆 的 容量 限制 后 产生 内存 溢出 异常。实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">packagecom.sf.jvm;</span><br><span class="line">importjava.util.ArrayList;</span><br><span class="line">importjava.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：</span></span><br><span class="line"><span class="comment">* -Xms20m -Xmx20m</span></span><br><span class="line"><span class="comment">* -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">* -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> classHeapOutOfMemory &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">outOfMemory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noOutOfMemory</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">newOOMObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outOfMemory</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;OOMObject&gt; list =newArrayList&lt;OOMObject&gt;();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">list.add(newOOMObject());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">classOOMObject &#123;</span><br><span class="line">bytemem[] =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2014</span>];</span><br><span class="line">&#125;</span><br><span class="line">异常信息如下：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 5632K-&gt;512K(6144K)] 5632K-&gt;5024K(19968K), <span class="number">0.0027725</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 6144K-&gt;504K(6144K)] 10656K-&gt;11432K(19968K), <span class="number">0.0022202</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 504K-&gt;0<span class="title">K</span><span class="params">(6144K)</span>] [ParOldGen: 10928K-&gt;10092<span class="title">K</span><span class="params">(13824K)</span>] 11432K-&gt;10092<span class="title">K</span><span class="params">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class="title">K</span><span class="params">(1056768K)</span>], 0.0149535 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line">........</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 5632K-&gt;5632<span class="title">K</span><span class="params">(6144K)</span>] [ParOldGen: 13823K-&gt;13823<span class="title">K</span><span class="params">(13824K)</span>] 19455K-&gt;19455<span class="title">K</span><span class="params">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class="title">K</span><span class="params">(1056768K)</span>], 0.0086009 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid2780.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">20898436</span> bytes in <span class="number">0.027</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="function">at com.sf.jvm.OOMObject.&lt;init&gt;<span class="params">(HeapOutOfMemory.java:<span class="number">29</span>)</span></span></span><br><span class="line"><span class="function">at com.sf.jvm.HeapOutOfMemory.<span class="title">outOfMemory</span><span class="params">(HeapOutOfMemory.java:<span class="number">23</span>)</span></span></span><br><span class="line"><span class="function">at com.sf.jvm.HeapOutOfMemory.<span class="title">main</span><span class="params">(HeapOutOfMemory.java:<span class="number">12</span>)</span></span></span><br><span class="line"><span class="function">[PSYoungGen: 5632K-&gt;0<span class="title">K</span><span class="params">(6144K)</span>] [ParOldGen: 13823K-&gt;579<span class="title">K</span><span class="params">(13824K)</span>] 19455K-&gt;579<span class="title">K</span><span class="params">(19968K)</span>, [Metaspace: 2973K-&gt;2973<span class="title">K</span><span class="params">(1056768K)</span>], 0.0096016 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line">Heap</span><br><span class="line">PSYoungGen total 6144K, used 177K [<span class="number">0x00000000ff980000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">eden space 5632K, <span class="number">3</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ff9ac4a0</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">to space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line">ParOldGen total 13824K, used 579K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff980000</span>, <span class="number">0x00000000ff980000</span>)</span><br><span class="line">object space 13824K, <span class="number">4</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000fec90c20</span>,<span class="number">0x00000000ff980000</span>)</span><br><span class="line">Metaspace used 3005K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">space</span> <span class="title">used</span> 326<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>用 jvisualvm.exe 打开查看 dump，发现主要是 OOMobject 不被释放。</p><h4>1.5 方法 区<h4>      <h5>1.5.1 方法区</h5> 方法 区（ Method Area） 与 Java 堆 一样， 是 各个 线程 共享 的 内存 区域， 它 用于 存储 已被 虚拟 机 加载 的 类 信息、 常量、 静态 变量、 即时 编译器 编译 后的 代码 等 数据。 虽然 Java 虚拟 机 规范 把 方法 区 描述为 堆 的 一个 逻辑 部分， 但是 它 却有 一个 别名 叫做 Non- Heap（ 非 堆）， 目的 应该 是与 Java 堆 区分 开来。 对于 习惯 在 HotSpot 虚拟 机上 开发 和 部署 程序 的 开发者 来说， 很多人 愿意 把 方法 区 称为“ 永久 代”（ Permanent Generation）， 本质上 两者 并不 等价， 仅仅 是因为 HotSpot 虚拟 机 的 设计 团队 选择 把 GC 分 代收 集 扩展 至 方法 区， 或者说 使用 永久 代 来 实现 方法 区 而已。 对于 其他 虚拟 机（ 如 BEA JRockit、 IBM J9 等） 来说 是 不存在 永久 代 的 概念 的。 即使是 HotSpot 虚拟 机 本身， 根据 官方 发布 的 路线 图 信息， 现在 也有 放弃 永久 代 并“ 搬家” 至 Native Memory 来 实现 方法 区 的 规划 了。 Java 虚拟 机 规范 对这 个 区域 的 限制 非常 宽松， 除了 和 Java 堆 一样 不需要 连续 的 内存 和 可以 选择 固定 大小 或者 可扩展 外， 还可以 选择 不实 现 垃圾 收集。 相对而言， 垃圾 收集 行为 在这 个 区域 是 比较 少 出现 的， 但 并非 数据 进入 了 方法 区 就 如 永久 代 的 名字 一样“ 永久” 存在 了。 这个 区域 的 内存 回收 目标 主要 是 针对 常量 池 的 回收 和 对 类型 的 卸载， 一般来说 这个 区域 的 回收“ 成绩” 比较 难以 令人满意， 尤其是 类型 的 卸载， 条件 相当 苛刻， 但是 这部 分 区域 的 回收 确实 是有 必要 的。 在 Sun 公司 的 BUG 列表 中， 曾 出现 过 的 若干个 严重 的 BUG 就是 由于 低 版本 的 HotSpot 虚拟 机 对此 区域 未完 全 回收 而 导致 内存 泄漏。 根据 Java 虚拟 机 规范 的 规定， 当 方法 区 无法 满足 内存 分配 需求 时， 将 抛出 OutOfMemoryError 异常。方法 区 用于 存放 Class 的 相关 信息， 如 类 名、 访问 修饰 符、 常量 池、 字段 描述、 方法 描述 等。 对于 这个 区域 的 测试， 基本 的 思路 是 运行时 产生 大量 的 类 去 填满 方法 区， 直到 溢出。 虽然 直接 使用 Java SE API 也可以 动态 产生 类（ 如 反射 时 的 GeneratedConstructorAccessor 和 动态 代理 等）， 但在 本次 实验 中 操作 起来 比较 麻烦。 在 代码 清单 2- 5 中， 笔者 借助 CGLib[ 3] 直接 操作 字节 码 运行时， 生成 了 大量 的 动态 类。 值得 特别 注意 的 是， 我们 在这 个 例子 中 模拟 的 场景 并非 纯粹 是一 个 实验， 这样 的 应用 经常 会 出现 在 实际 应用 中： 当前 的 很多 主流 框架， 如 Spring 和 Hibernate 对 类 进行 增强 时， 都会 使用 到 CGLib 这类 字节 码 技术， 增 强的 类 越多， 就 需要 越大 的 方法 区 来 保证 动态 生成 的 Class 可以 加载 入 内存。方法 区 溢出 也是 一种 常见 的 内存 溢出 异常， 一个 类 如果 要被 垃圾 收集 器 回收 掉， 判定 条件 是非 常 苛刻 的。 在 经常 动态 生成 大量 Class 的 应用 中， 需要 特别 注意 类 的 回收 状况。 这类 场景 除了 上面 提到 的 程序 使用 了 GCLib 字节 码 增强 外， 常见 的 还有： 大量 JSP 或 动态 产生 JSP 文件 的 应用（ JSP 第一次 运行时 需要 编译 为 Java 类）、 基于 OSGi 的 应用（ 即使是 同一个 类 文件， 被 不同 的 加载 器 加载 也会 视为 不同 的 类） 等。代码 清单 2- 5 　 借助 CGLib 使得 方法 区 出现 内存 溢出 异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">packagecom.sf.jvm;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args： -XX: PermSize= 10M -XX: MaxPermSize= 10M</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">Enhancer enhancer =newEnhancer();</span><br><span class="line">enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">enhancer.setCallback(newMethodInterceptor() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, </span></span></span><br><span class="line"><span class="params"><span class="function">Object[] args, MethodProxy proxy)</span>throwsThrowable </span>&#123;</span><br><span class="line">returnproxy.invokeSuper(obj, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">enhancer.create();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> classOOMObject &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">运行 结果：</span><br><span class="line">Caused by: </span><br><span class="line">java. lang. OutOfMemoryError: </span><br><span class="line">PermGen space at java. lang. ClassLoader. defineClass1( Native Method)</span><br><span class="line">at java. lang. ClassLoader. defineClassCond( ClassLoader. java: <span class="number">632</span>) </span><br><span class="line">at java. lang. ClassLoader. defineClass( ClassLoader. java: <span class="number">616</span>）</span><br></pre></td></tr></table></figure><h5>1.5.2 运行时常量池</h5> 运行时 常量 池（ Runtime Constant Pool） 是 方法 区 的 一部分。 Class 文件 中 除了 有 类 的 版本、 字段、 方法、接口 等 描述 等 信息 外， 还有 一项 信息 是 常量 池（ Constant Pool Table）， 用于 存放 编译 期 生成 的 各种 字面 量 和 符号 引用， 这部 分 内容 将 在 类 加载 后 存放 到 方法 区 的 运行时 常量 池 中。 Java 虚拟 机 对 Class 文件 的 每一 部分（ 自然 也 包括 常量 池） 的 格式 都有 严格 的 规定， 每一个 字节 用于 存储 哪种 数据 都 必须 符合 规范 上 的 要求， 这样 才会 被 虚拟 机 认可、 装载 和 执行。 但 对于 运行时 常量 池， Java 虚拟 机 规范 没有 做 任何 细节 的 要求， 不同 的 提供 商 实现 的 虚拟 机 可以 按照 自己的 需要 来 实现 这个 内存 区域。 不过， 一般来说， 除了 保存 Class 文件 中 描述 的 符号 引用 外， 还会 把 翻译 出来 的 直接 引用 也 存储 在 运行时 常量 池 中[ 4]。 运行时 常量 池 相对于 Class 文件 常量 池 的 另外 一个 重要 特征 是 具备 动态 性， Java 语言 并不 要求 常量 一定 只能 在 编译 期 产生， 也就是 并非 预置 入 Class 文件 中 常量 池 的 内容 才能 进入 方法 区 运行时 常量 池， 运行 期间 也可 能将 新的 常量 放入 池 中， 这种 特性 被 开发 人员 利用 得比 较多 的 便是 String 类 的 intern() 方法。 既然 运行时 常量 池 是 方法 区 的 一部分， 自然 会受 到 方法 区 内存 的 限制， 当 常量 池 无法 再 申请 到 内存 时会 抛出 OutOfMemoryError 异常。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sf.jvm;</span><br><span class="line">importjava.util.ArrayList;</span><br><span class="line">importjava.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：- XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用 List 保持 着 常量 池 引用， 避免 Full GC 回收 常量 池 行为</span></span><br><span class="line">List&lt;String&gt; list =<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 10MB 的 PermSize 在 integer 范围内 足够 产生 OOM 了</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">list.add(String.valueOf(i++ +<span class="string">&quot;xxxxxxxxxxxxxxxxxxxxx&quot;</span>).intern());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">运行异常：</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java. lang. OutOfMemoryError: </span><br><span class="line">PermGen space at java. lang. String. intern( Native Method) </span><br><span class="line">at org. fenixsoft. oom. RuntimeConstantPoolOOM. main( RuntimeConstantPoolOOM. java:...</span><br></pre></td></tr></table></figure><h4>1.7 直接 内存</h4> 直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。在JDK1.4中新加入了NIO（NewInput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。越过了DirectByteBuffer类，直接通过反射获取Unsafe实例并进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。如下实例为直接内存溢出。    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sf.jvm;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> staticcom.sun.deploy.util.BufferUtil.MB;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：- Xmx20M -XX: MaxDirectMemorySize= 10M</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> classDirectMemoryOOM &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>throwsException </span>&#123;</span><br><span class="line">Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">unsafe.allocateMemory(_1MB);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">运行异常：</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError</span><br><span class="line">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">at com.sf.jvm.DirectMemoryOOM.main(DirectMemoryOOM.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h4>1.8 对象的访问</h4>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：Objectobj=newObject();假设这句代码出现在方法体中，那“Objectobj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“newObject()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（InstanceData，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（ObjectMemoryLayout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。       如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如图:![这里写图片描述](http://img.blog.csdn.net/20170728094239784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>        如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如图:`<center>`![这里写图片描述](http://img.blog.csdn.net/20170728094300056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</center>         这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机SunHotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。参照：深入理解Java虚拟机http://blog.csdn.net/u012152619/article/details/46968883http://www.importnew.com/14630.html]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##&lt;center&gt;JVM 内存模型&lt;/center&gt; 1.内存模型结构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170724161538339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="http://example.com/2021/08/04/language/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2021/08/04/language/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2021-08-04T06:25:13.662Z</published>
    <updated>2021-08-04T06:25:13.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p> jvm要进行垃圾回收粗略分为两个步骤：找出需要清理的内存(无效的内存区域) ， 清理无效的内存区域<br> 程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收所关注的是这部分内存。</p><h2 id="2-无效内存区域的查找"><a href="#2-无效内存区域的查找" class="headerlink" title="2. 无效内存区域的查找"></a>2. 无效内存区域的查找</h2><h3 id="2-1-概要"><a href="#2-1-概要" class="headerlink" title="2.1 概要"></a>2.1 概要</h3><p>Java堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”。判断方法有引用计数器法和根搜索算法等。</p><h4 id="2-1-1-引用计数算法"><a href="#2-1-1-引用计数算法" class="headerlink" title="2.1.1 引用计数算法"></a>2.1.1 引用计数算法</h4><p>简单解释为给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当该引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。客观地说，引用计数算法（ReferenceCounting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的COM（ComponentObjectModel）技术、使用ActionScript3的FlashPlayer、Python语言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *testGC()方法执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@authorzzm</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span></span>&#123;　　</span><br><span class="line"><span class="keyword">public</span> Object instance=<span class="keyword">null</span>;　　 </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB=<span class="number">1024</span>*<span class="number">1024</span>;　　</span><br><span class="line"><span class="comment">/**　　</span></span><br><span class="line"><span class="comment">*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过　　</span></span><br><span class="line"><span class="comment">*/</span>　　</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];　　</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">ReferenceCountingGC objB = newReferenceCountingGC();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line">objA = <span class="keyword">null</span>; </span><br><span class="line">objB = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//假设在这行发生GC，那么objA和objB是否能被回收？</span></span><br><span class="line">System.gc();　　</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[FullGC(System)</span><br><span class="line">[Tenured:0K-&gt;210K(10240K),0.0149142secs]</span><br><span class="line">4603K-&gt;210K(19456K),</span><br><span class="line">[Perm:2999K-&gt;2999K(21248K)],0.0150007secs][Times:user=0.01sys=0.00,real=0.02secs]</span><br><span class="line">Heapdefnewgenerationtotal9216K,used82K</span><br><span class="line">[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)Edenspace8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)</span><br><span class="line">fromspace1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)</span><br><span class="line">tospace1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)</span><br><span class="line">tenuredgenerationtotal10240K,used210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)</span><br><span class="line">thespace10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)</span><br><span class="line">compactingpermgentotal21248K,</span><br><span class="line">used3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)</span><br><span class="line">thespace21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)</span><br><span class="line">Nosharedspacesconfigured.</span><br></pre></td></tr></table></figure><p>代码中testGC()方法：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们，为引用计数器的缺陷。但从运行结果中可以清楚地看到GC日志中包含“4603K-&gt;210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h4 id="2-1-2-根搜索算法"><a href="#2-1-2-根搜索算法" class="headerlink" title="2.1.2 根搜索算法"></a>2.1.2 根搜索算法</h4><p>在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GCRootsTracing）判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有任何引用链相连（用图论的话来说就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。如下：</p><p><img src="http://img.blog.csdn.net/20170728135643324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>对象object5、object6、object7虽然互相有关联，但是它们到GCRoots是不可达的，所以它们将会被判定为是可回收的对象。<br>在Java语言里，可作为GCRoots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）的引用的对象。</li></ul><h3 id="2-2-java的引用类型"><a href="#2-2-java的引用类型" class="headerlink" title="2.2 java的引用类型"></a>2.2 java的引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。<br>JDK1.2之后，Java对引用的概念进行了扩充，并且引用强度不同。如下</p><table><thead><tr><th>引用类型</th><th>概述</th></tr></thead><tbody><tr><td>强引用（StrongReference）</td><td>强引用就是指在程序代码之中普遍存在的，类似“Objectobj=newObject()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</td></tr><tr><td>软引用（SoftReference）</td><td>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用</td></tr><tr><td>弱引用（WeakReference）</td><td>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用</td></tr><tr><td>虚引用（PhantomReference）</td><td>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用</td></tr></tbody></table><h3 id="2-3-对象自救"><a href="#2-3-对象自救" class="headerlink" title="2.3 对象自救"></a>2.3 对象自救</h3><p>在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经经历两次标记过程：如果对象在进行根搜索后发现没有与GCRoots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***此代码演示了两点：</span></span><br><span class="line"><span class="comment"> *1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment"> *2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@authorzzm</span></span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC(); <span class="comment">//对象 第一次 成功 拯救 自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125; <span class="comment">// 下面 这段 代码 与 上面 的 完全 相同， 但是 这次 自救 却 失败 了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 因为 Finalizer 方法 优先级 很低， 暂停 0. 5 秒， 以 等待 它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; yes, i am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot; finalize mehtod executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">finalize mehtod executed! </span><br><span class="line">yes, i am still alive :) </span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。代码中一次对象自我拯救的演示，在运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时，大家完全可以忘掉Java语言中还有这个方法的存在。</p><h3 id="2-4-回收方法区"><a href="#2-4-回收方法区" class="headerlink" title="2.4 回收方法区"></a>2.4 回收方法区</h3><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。<br>java中同时满足下面3个条件才能算是“无用的类”：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。<br>是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。可以使用-verbose：class及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类的加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，但-XX：+TraceClassLoading参数需要fastdebug版的虚拟机支持。在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h2 id="3-清理无效内存"><a href="#3-清理无效内存" class="headerlink" title="3. 清理无效内存"></a>3. 清理无效内存</h2><h3 id="3-1-垃圾收集算法"><a href="#3-1-垃圾收集算法" class="headerlink" title="3.1 垃圾收集算法"></a>3.1 垃圾收集算法</h3><p>由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及其发展过程。</p><h4 id="3-1-1-标记-清除算法"><a href="#3-1-1-标记-清除算法" class="headerlink" title="3.1.1 标记-清除算法"></a>3.1.1 标记-清除算法</h4><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br>它的主要缺点有两个：</p><ul><li>一个是效率问题，标记和清除过程的效率都不高；</li><li>一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>如下图为执行标记清除算法后的内存区域：</li></ul><p><img src="http://img.blog.csdn.net/20170729100915368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="3-1-2-标记-整理算法"><a href="#3-1-2-标记-整理算法" class="headerlink" title="3.1.2 标记-整理算法"></a>3.1.2 标记-整理算法</h4><p>标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。<br>主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。<br>如下图为执行标记清除算法后的内存区域：</p><p><img src="http://img.blog.csdn.net/20170729100943066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>####3.1.3 复制算法</p><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。<br>复制算法执行后的内存区域：</p><p><img src="http://img.blog.csdn.net/20170729101006020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="3-1-4-分代收集算法"><a href="#3-1-4-分代收集算法" class="headerlink" title="3.1.4 分代收集算法"></a>3.1.4 分代收集算法</h4><p>分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p><h3 id="3-2-垃圾收集器"><a href="#3-2-垃圾收集器" class="headerlink" title="3.2 垃圾收集器"></a>3.2 垃圾收集器</h3><p>垃圾收集器对比</p><table><thead><tr><th>垃圾收集器</th><th>解释</th><th>对比</th></tr></thead><tbody><tr><td>Serial收集器</td><td>新生代复制算法，老年代采用标记整理算法，Serial收集器到JDK1.7为止，它依然是JAVA虚拟机运行在Client模式下的默认新生代收集器。</td><td>它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率</td></tr><tr><td>ParNew收集器</td><td>新生代复制算法，老年代采用标记整理算法，ParNew收集器其实就是Serial收集器的多线程版本</td><td>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</td></tr><tr><td>ParallelScavenge收集器</td><td>新生代收集器采用复制算法</td><td>Parallel Scavenge 收集 器 的 特点 是它 的 关注 点 与其 他 收集 器 不同， CMS 等 收集 器 的 关注 点 尽可能 地 缩短 垃圾 收集 时 用户 线程 的 停顿 时间， 而 Parallel Scavenge 收集 器 的 目标 则是 达到 一个 可 控制 的 吞吐量（ Throughput）。</td></tr><tr><td>Serial Old 收集 器</td><td>Serial Old 是 Serial 收集 器 的 老年 代 版本 标记-整理算法</td><td>这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用</td></tr><tr><td>Parallel Old 收集 器</td><td>Parallel Scavenge 收集 器 的 老年 代 版本 标记-整理算法</td><td>注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。</td></tr><tr><td>CMS收集器</td><td>CMS（ConcurrentMarkSweep）针对老年代进行回收的GC，标记-清除算法</td><td>收集器是一种以获取最短回收停顿时间为目标的收集器</td></tr><tr><td>G1收集器</td><td>内存结构变更，相对于CMS的“标记——清理”算法，G1会使用压缩算法，保证不产生多余的碎片。收集阶段，G1会将某个区域存活的对象拷贝的其他区域，然后将整个区域整个回收。</td><td>服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器。</td></tr></tbody></table><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。<br>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于SunHotSpot虚拟机1.6版Update22，这个虚拟机包含的所有收集器如图所示。</p><p><img src="http://img.blog.csdn.net/20170728221643962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>HotSpotJVM1.6的垃圾收集器展示了7种作用于不同分代的收集器（包括JDK1.6_Update14后引入的EarlyAccess版G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。<br>####3.2.1 Serial收集器<br>         Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。读者不妨试想一下，要是你的计算机每运行一个小时就会暂停响应5分钟，你会有什么样的心情？Serial / Serial Old收集器的运行过程如下：</p><p><img src="http://img.blog.csdn.net/20170728221849904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从 JDK 1.3 开始，一直到现在最新的 JDK 1.7，HotSpot 虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从 Serial 收集器到 Parallel 收集器，再到 Concurrent Mark Sweep（CMS）乃至 GC 收集器的最前沿成果 Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括 RTSJ 中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！</p><p>写到这里，笔者似乎已经把 Serial 收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。</p><h4 id="3-2-2-ParNew收集器"><a href="#3-2-2-ParNew收集器" class="headerlink" title="3.2.2 ParNew收集器"></a>3.2.2 ParNew收集器</h4><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如下</p><p><img src="http://img.blog.csdn.net/20170728221941057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你妈妈打扫房间的时候你还能同时往地上扔纸屑。</p><p>不幸的是，它作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或 Serial 收集器中的一个。ParNew 收集器也是使用 -XX: +UseConcMarkSweepGC 选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC 选项来强制指定它。</p><p>ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证能超越 Serial 收集器。当然，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（譬如 32 个，现在 CPU 动辄就 4 核加超线程，服务器超过 32 个逻辑 CPU 的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。</p><p>注意 从 ParNew 收集器开始，后面还将会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，他们可以解释为： 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个 CPU 上。</p><h4 id="3-2-3-ParallelScavenge收集器"><a href="#3-2-3-ParallelScavenge收集器" class="headerlink" title="3.2.3 ParallelScavenge收集器"></a>3.2.3 ParallelScavenge收集器</h4><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？</p><p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的-XX:GCTimeRatio 参数。</p><p>MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p><p>GCTimeRatio 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 /（1+19）），默认值为 99，就是允许最大 1%（即 1 /（1+99））的垃圾收集时间。</p><p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数-XX:+UseAdaptiveSizePolicy 值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</p><p>####3.2.4 Serial Old 收集 器<br>   Serial Old 是 Serial 收集 器 的 老年 代 版本， 它 同样是 一个 单线 程 收集 器， 使用“ 标记- 整理” 算法。 这个 收集 器 的 主要 意义 也是 被 Client 模式 下 的 虚拟 机 使用。 如果 在 Server 模式 下， 它 主要 还有 两大 用途： 一个 是在 JDK 1. 5 及 之前 的 版本 中 与 Parallel Scavenge 收集 器 搭配 使用[ 4]， 另外 一个 就是 作为 CMS 收集 器 的 后备 预 案， 在 并发 收集 发生 Concurrent Mode Failure 的 时候 使用。 这 两点 都将 在后 面的 内容 中 详细 讲解。 Serial Old 收集 器 的 工作 过程 如图 所示。</p><p><img src="http://img.blog.csdn.net/20170729114927185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>####3.2.5 Parallel Old 收集 器<br>  Parallel Old 是 Parallel Scavenge 收集 器 的 老年 代 版本， 使用 多 线程 和“ 标记－整理” 算法。 这个 收集 器 是在 JDK 1. 6 中 才 开始 提供 的， 在此之前， 新生代 的 Parallel Scavenge 收集 器 一直 处于 比较 尴尬 的 状态。 原因 是， 如果 新生代 选择 了 Parallel Scavenge 收集 器， 老年 代 除了 Serial Old（ PS MarkSweep） 收集 器 外 别无选择（ 还 记得 上面 说过 Parallel Scavenge 收集 器 无法 与 CMS 收集 器 配合 工作 吗？）。 由于 单 线程 的 老 年代 Serial Old 收集 器 在 服务 端 应用 性 能上 的“ 拖累”， 即便 使用 了 Parallel Scavenge 收集 器 也 未必 能在 整体 应用 上 获得 吞吐量 最大化 的 效果， 又因 为 老年 代收 集中 无法 充分 利用 服务器 多 CPU 的 处理 能力， 在 老年 代 很大 而且 硬件 比较 高级的 环境 中， 这种 组合 的 吞吐量 甚至 还不 一 定有 ParNew 加 CMS 的 组合“ 给 力”。 直到 Parallel Old 收集 器 出现 后，“ 吞吐量 优先” 收集 器 终于 有了 比较 名副其实 的 应用 组合， 在 注重 吞吐量 及 CPU 资源 敏感 的 场合， 都可以 优先 考虑 Parallel Scavenge 加 Parallel Old 收集 器。 Parallel Old 收集 器 的 工作 过程 如图所示。<br> <img src="http://img.blog.csdn.net/20170728222929126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="3-2-6-CMS收集器"><a href="#3-2-6-CMS收集器" class="headerlink" title="3.2.6 CMS收集器"></a>3.2.6 CMS收集器</h4><p>CMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“MarkSweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分如下步骤，<br>包括：</p><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>(1) 初始标记 (Initial Mark)</td><td>(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable).对象在旧一代“标志”可以包括这些对象可能可以从年轻一代。暂停时间一般持续时间较短,相对小的收集暂停时间.</td></tr><tr><td>(2) 并发标记 (Concurrent Marking)</td><td>在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象. 调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态.</td></tr><tr><td>(3) 再次标记(Remark)</td><td>(Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的.</td></tr><tr><td>(4) 并发清理(Concurrent Sweep)</td><td>回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.</td></tr><tr><td>(5) 重置(Resetting)</td><td>清理数据结构,为下一个并发收集做准备.</td></tr><tr><td>其中初始标记、重新标记这两个步骤仍然需要“StopTheWorld”。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。ConcurrentMarkSweep收集器运行示意图：</td><td></td></tr></tbody></table><p><img src="http://img.blog.csdn.net/20170728222952502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（ConcurrentLowPauseCollector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：</p><ul><li>CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，这也很让人受不了。为了解决这种情况，虚拟机提供了一种称为“增量式并发收集器”（IncrementalConcurrentMarkSweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。</li><li>CMS收集器无法处理浮动垃圾（FloatingGarbage），可能出现“ConcurrentModeFailure”失败而导致另一次FullGC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“ConcurrentModeFailure”失败，这时候虚拟机将启动后备预案：临时启用SerialOld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“ConcurrentModeFailure”失败，性能反而降低。</li><li>还有最后一个缺点，在本节在开头说过，CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC。为了解决这个问题，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数，用于在“享受”完FullGC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的FullGC后，跟着来一次带压缩的。<br>后续分开介绍：</li></ul><h4 id="3-2-7-G1收集器G1（GarbageFirst）收集器"><a href="#3-2-7-G1收集器G1（GarbageFirst）收集器" class="headerlink" title="3.2.7.G1收集器G1（GarbageFirst）收集器"></a>3.2.7.G1收集器G1（GarbageFirst）收集器</h4><p>G1 GC 是 Jdk7 的新特性之一、Jdk7+版本都可以自主配置 G1 作为 JVM GC 选项；作为 JVM GC 算法的一次重大升级、DK7u 后 G1 已相对稳定、且未来计划替代 CMS、所以有必要深入了解下：</p><p>不同于其他的分代回收算法、G1 将堆空间划分成了互相独立的区块。每块区域既有可能属于 O 区、也有可能是 Y 区，且每类区域空间可以是不连续的（对比 CMS 的 O 区和 Y 区都必须是连续的）。这种将 O 区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时 G1 仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。如下：</p><p><img src="http://img.blog.csdn.net/20170729121950668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。<br>平时工作中大多数系统都使用CMS、即使静默升级到JDK7默认仍然采用CMS、那么G1相对于CMS的区别在：</p><p>G1 在压缩空间方面有优势<br>G1 通过将内存空间分成区域（Region）的方式避免内存碎片问题<br>Eden, Survivor, Old 区不再固定、在内存使用效率上来说更灵活<br>G1 可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象<br>G1 在回收内存后会马上同时做合并空闲内存的工作、而 CMS 默认是在 STW（stop the world）的时候做<br>G1 会在 Young GC 中使用、而 CMS 只能在 O 区使用<br>就目前而言、CMS 还是默认首选的 GC 策略、可能在以下场景下 G1 更适合：</p><p>服务端多核 CPU、JVM 内存占用较大的应用（至少大于 4G）<br>应用在运行过程中会产生大量内存碎片、需要经常压缩空间<br>想要更可控、可预期的 GC 停顿周期；防止高并发下应用雪崩现象<br>一次完整 G1GC 的详细过程：</p><p>G1 在运行过程中主要包含如下 4 种操作方式：</p><p>YGC（不同于 CMS）<br>并发阶段<br>混合模式<br>full GC （一般是 G1 出现问题时发生）<br>YGC：</p><p>下面是一次 YGC 前后内存区域是示意图：</p><p><img src="http://img.blog.csdn.net/20170729120730189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>图中每个小区块都代表 G1 的一个区域（Region），区块里面的字母代表不同的分代内存空间类型（如[E]Eden,[O]Old,[S]Survivor）空白的区块不属于任何一个分区；G1 可以在需要的时候任意指定这个区域属于 Eden 或是 O 区之类的。<br>G1 YoungGC 在 Eden 充满时触发，在回收之后所有之前属于 Eden 的区块全变成空白。然后至少有一个区块是属于 S 区的（如图半满的那个区域），同时可能有一些数据移到了 O 区。</p><p>目前淘系的应用大都使用 PrintGCDetails 参数打出 GC 日志、这个参数对 G1 同样有效、但日志内容颇为不同；下面是一个 Young GC 的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">23.430: [GC pause (young), 0.23094400 secs]</span><br><span class="line">...</span><br><span class="line">[Eden: 1286M(1286M)-&gt;0B(1212M)</span><br><span class="line">Survivors: 78M-&gt;152M Heap: 1454M(4096M)-&gt;242M(4096M)][times: user=0.85 sys=0.05, real=0.23 secs]</span><br></pre></td></tr></table></figure><p>上面日志的内容解析：Young GC 实际占用 230 毫秒、其中 GC 线程占用 850 毫秒的 CPU 时间<br>E：内存占用从 1286MB 变成 0、都被移出<br>S：从 78M 增长到了 152M、说明从 Eden 移过来 74M<br>Heap:占用从 1454 变成 242M、说明这次 Young GC 一共释放了 1212M 内存空间<br>很多情况下，S 区的对象会有部分晋升到 Old 区，另外如果 S 区已满、Eden 存活的对象会直接晋升到 Old 区，这种情况下 Old 的空间就会涨</p><p>并发阶段：</p><p>一个并发 G1 回收周期前后内存占用情况如下图所示：</p><p><img src="http://img.blog.csdn.net/20170729120816584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从上面的图表可以看出以下几点：<br>1、Young区发生了变化、这意味着在G1并发阶段内至少发生了一次YGC（这点和CMS就有区别），Eden在标记之前已经被完全清空，因为在并发阶段应用线程同时在工作、所以可以看到Eden又有新的占用<br>2、一些区域被X标记，这些区域属于O区，此时仍然有数据存放、不同之处在G1已标记出这些区域包含的垃圾最多、也就是回收收益最高的区域<br>3、在并发阶段完成之后实际上O区的容量变得更大了（O+X的方块）。这时因为这个过程中发生了YGC有新的对象进入所致。此外，这个阶段在O区没有回收任何对象：它的作用主要是标记出垃圾最多的区块出来。对象实际上是在后面的阶段真正开始被回收</p><p>G1 并发标记周期可以分成几个阶段、其中有些需要暂停应用线程。第一个阶段是初始标记阶段。这个阶段会暂停所有应用线程-部分原因是这个过程会执行一次 YGC、下面是一个日志示例：</p><blockquote><p>50.541: [GC pause (young) (initial-mark), 0.27767100 secs][eden: 1220m(1220m)-&gt;0b(1220m) survivors: 144m-&gt;144m heap: 3242m(4096m)-&gt;2093m(4096m)] [Times: user=1.02 sys=0.04, real=0.28</p><blockquote><p>secs]</p></blockquote></blockquote><p>上面的日志表明发生了 YGC、应用线程为此暂停了 280 毫秒，Eden 区被清空（71MB 从 Young 区移到了 O 区）。<br>日志里面 initial-mark 的字样表明后台的并发 GC 阶段开始了。因为初始标记阶段本身也是要暂停应用线程的，<br>G1 正好在 YGC 的过程中把这个事情也一起干了。为此带来的额外开销不是很大、增加了 20%的 CPU，暂停时间相应的略微变长了些。</p><p>接下来，G1 开始扫描根区域、日志示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50.819: [GC concurrent-root-region-scan-start]</span><br><span class="line">51.408: [GC concurrent-root-region-scan-end, 0.5890230]</span><br></pre></td></tr></table></figure><p>一共花了 580 毫秒，这个过程没有暂停应用线程；是后台线程并行处理的。这个阶段不能被 YGC 所打断、因此后台线程有足够的 CPU 时间很关键。如果 Young 区空间恰好在 Root 扫描的时候<br>满了、YGC 必须等待 root 扫描之后才能进行。带来的影响是 YGC 暂停时间会相应的增加。这时的 GC 日志是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 350.994: [GC pause (young)</span><br><span class="line">&gt; 351.093: [GC concurrent-root-region-scan-end, 0.6100090]</span><br><span class="line">&gt; 351.093: [GC concurrent-mark-start],0.37559600 secs]</span><br></pre></td></tr></table></figure><p>GC 暂停这里可以看出在 root 扫描结束之前就发生了，表明 YGC 发生了等待，等待时间大概是 100 毫秒。<br>在 root 扫描完成后，G1 进入了一个并发标记阶段。这个阶段也是完全后台进行的；GC 日志里面下面的信息代表这个阶段的开始和结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">111.382: [GC concurrent-mark-start] ....</span><br><span class="line">120.905: [GC concurrent-mark-end, 9.5225160 sec]</span><br></pre></td></tr></table></figure><p>并发标记阶段是可以被打断的，比如这个过程中发生了 YGC 就会。这个阶段之后会有一个二次标记阶段和清理阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 120.910: [GC remark 120.959: [GC ref-PRC, 0.0000890 secs], 0.0718990 secs][times: user=0.23 sys=0.01, real=0.08 secs]</span><br><span class="line">&gt; 120.985: [GC cleanup 3510M-&gt;3434M(4096M), 0.0111040 secs][times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>这两个阶段同样会暂停应用线程，但时间很短。接下来还有额外的一次并发清理阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">120.996: [GC concurrent-cleanup-start]</span><br><span class="line">120.996: [GC concurrent-cleanup-end, 0.0004520]</span><br></pre></td></tr></table></figure><p>到此为止，正常的一个 G1 周期已完成–这个周期主要做的是发现哪些区域包含可回收的垃圾最多（标记为 X），实际空间释放较少。</p><p>混合 GC：</p><p>接下来 G1 执行一系列的混合 GC。这个时期因为会同时进行 YGC 和清理上面已标记为 X 的区域，所以称之为混合阶段，下面是一个混合 GC 执行的前后示意图：</p><p><img src="http://img.blog.csdn.net/20170729120910552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>像普通的YGC那样、G1完全清空掉Eden同时调整survivor区。另外，两个标记也被回收了，他们有个共同的特点是包含最多可回收的对象，因此这两个区域绝对部分空间都被释放了。这两个区域任何存活的对象都被移到了其他区域（和YGC存活对象晋升到O区类似）。这就是为什么G1的堆比CMS内存碎片要少很多的原因–移动这些对象的同时也就是在压缩对内存。下面是一个混合GC的日志：</p><blockquote><p>79.826: [GC pause (mixed), 0.26161600 secs] …. [Eden: 1222M(1222M)-&gt;0B(1220M) Survivors: 142M-&gt;144M Heap:<br>3200M(4096M)-&gt;1964M(4096M)][times: user=1.01 sys=0.00, real=0.26 secs]<br>上面的日志可以注意到 Eden 释放了 1222MB、但整个堆的空间释放内存要大于这个数目。数量相差看起来比较少、只有 16MB，但是要考虑同时有 survivor 区的对象晋升到 O 区；另外，每次混合 GC 只是清理一部分的 O 区内存，整个 GC 会一直持续到几乎所有的标记区域垃圾对象都被回收，这个阶段完了之后 G1 会重新回到正常的 YGC 阶段。周期性的，当 O 区内存占用达到一定数量之后 G1 又会开启一次新的并行 GC 阶段.<br>后续分开介绍：。。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>深入理解 java 虚拟机<br><a href="http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM垃圾回收&quot;&gt;&lt;a href=&quot;#JVM垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;JVM垃圾回收&quot;&gt;&lt;/a&gt;JVM垃圾回收&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存与线程</title>
    <link href="http://example.com/2021/08/04/language/jvm/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/08/04/language/jvm/JVM%E5%86%85%E5%AD%98%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-08-04T06:25:13.661Z</published>
    <updated>2021-08-04T06:25:13.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-内存"><a href="#1-内存" class="headerlink" title="1 内存"></a>1 内存</h2><h3 id="1-1-内存一致性"><a href="#1-1-内存一致性" class="headerlink" title="1.1 内存一致性"></a>1.1 内存一致性</h3><p>由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory），如图所示：</p><p><img src="http://img.blog.csdn.net/20170806222602143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY253dWhhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly 及 DragonProtocol，等等。</p><h3 id="1-2-主内存与工作内存"><a href="#1-2-主内存与工作内存" class="headerlink" title="1.2 主内存与工作内存"></a>1.2 主内存与工作内存</h3><p>Java 内存模型的主要目标是定义程序各个变量的访问规则，即在虚拟机机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与 Java 编程中所说的变量略有区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的[3]，不会被共享，自然就不存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权利，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存，线程间无法直接访问对方工作内存的中变量，线程间变量值得传递均需要通过主内存来完成。如图所示：</p><h3 id="1-3-内存间的交互操作"><a href="#1-3-内存间的交互操作" class="headerlink" title="1.3 内存间的交互操作"></a>1.3 内存间的交互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义了以下八种操作来完成：</p><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用</p><p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。</p><p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。</p><p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行 read 和 load 操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java 内存 模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间， store 和 write 之间是可以插入其他指令的，如对主内存中的变量 a、b 进行访问时，可能的顺 序是 read a，read b，load b， load a。</p><p>Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><p>不允许 read 和 load、store 和 write 操作之一单独出现</p><p>不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。</p><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。</p><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p><p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。lock 和 unlock 必须成对出现</p><p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值</p><p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。</p><p>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。</p><h3 id="1-4-重排序"><a href="#1-4-重排序" class="headerlink" title="1.4 重排序"></a>1.4 重排序</h3><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p><p>1.编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</p><p>2.指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>3.内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>从 Java 源代码到最终实际执行的指令序列，会经过下面三种重排序：</p><p>为了保证内存的可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java 内存模型把内存屏障分为 LoadLoad、LoadStore、StoreLoad 和 StoreStore 四种：</p><h3 id="1-5-volatile-型变量"><a href="#1-5-volatile-型变量" class="headerlink" title="1.5 volatile 型变量"></a>1.5 volatile 型变量</h3><p>当一个变量定义为 volatile 之后，它将具备两种特性：</p><p>第一：保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量的值在线程间传递需要通过主内存来完成</p><p>由于 valatile 只能保证可见性，在不符合一下两条规则的运算场景中，我们仍要通过加锁来保证原子性</p><p>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p><p>2.变量不需要与其他的状态变量共同参与不变约束</p><p>第二：禁止指令重排序，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义</p><p>Java 内存模型中对 volatile 变量定义的特殊规则。假定 T 表示一个线程，V 和 W 分别表示两个 volatile 变量，那么在进行 read、load、use、assign、store、write 操作时需要满足如下的规则：</p><p>1.只有当线程 T 对变量 V 执行的前一个动作是 load 的时候，线程 T 才能对变量 V 执行 use 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候，线程 T 才能对变量 V 执行 load 操作。线程 T 对变量 V 的 use 操作可以认为是与线程 T 对变量 V 的 load 和 read 操作相关联的，必须一起连续出现。这条规则要求在工作内存中，每次使用变量 V 之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量 V 所作的修改后的值。</p><p>2.只有当线程 T 对变量 V 执行的前一个动是 assign 的时候，线程 T 才能对变量 V 执行 store 操作；并且，只有当线程 T 对变量 V 执行的后一个动作是 store 操作的时候，线程 T 才能对变量 V 执行 assign 操作。线程 T 对变量 V 的 assign 操作可以认为是与线程 T 对变量 V 的 store 和 write 操作相关联的，必须一起连续出现。这一条规则要求在工作内存中，每次修改 V 后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量 V 的修改。</p><p>3.假定操作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定操作 F 是操作 A 相关联的 load 或 store 操作，假定操作 P 是与操作 F 相应的对变量 V 的 read 或 write 操作；类型地，假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作，假定操作 G 是操作 B 相关联的 load 或 store 操作，假定操作 Q 是与操作 G 相应的对变量 V 的 read 或 write 操作。如果 A 先于 B，那么 P 先于 Q。这条规则要求 valitile 修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。</p><h3 id="1-6-对于-long-和-double-型变量的特殊规则"><a href="#1-6-对于-long-和-double-型变量的特殊规则" class="headerlink" title="1.6 对于 long 和 double 型变量的特殊规则"></a>1.6 对于 long 和 double 型变量的特殊规则</h3><p>Java 模型要求 lock、unlock、read、load、assign、use、store、write 这 8 个操作都具有原子性，但是对于 64 为的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作分为两次 32 为的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性</p><h3 id="1-7-原子性、可见性和有序性"><a href="#1-7-原子性、可见性和有序性" class="headerlink" title="1.7 原子性、可见性和有序性"></a>1.7 原子性、可见性和有序性</h3><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。Java 内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，valatile 特殊规则保障新值可以立即同步到祝内存中。Synchronized 是在对一个变量执行 unlock 之前，必须把变量同步回主内存中（执行 store、write 操作）。被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有吧 this 的引用传递出去，那在其他线程中就能看见 final 字段的值</p><p>可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><h3 id="1-8-先行发生原则"><a href="#1-8-先行发生原则" class="headerlink" title="1.8 先行发生原则"></a>1.8 先行发生原则</h3><p>这些先行发生关系无须任何同步就已经存在，如果不再此列就不能保障顺序性，虚拟机就可以对它们任意地进行重排序</p><p>1.程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构</p><p>2.管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序</p><p>3.Volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序</p><p>4.线程启动规则：Thread 对象的 start()方法先行发生于此线程的每一个动作</p><p>5.线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.joke()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行</p><p>6.线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生</p><p>7.对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始</p><p>8.传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论</p><h2 id="2-Java-线程"><a href="#2-Java-线程" class="headerlink" title="2 Java 线程"></a>2 Java 线程</h2><p>协同式调度：线程的执行时间由线程本身控制</p><p>抢占式调度：线程的执行时间由系统来分配</p><h3 id="2-1-状态转换"><a href="#2-1-状态转换" class="headerlink" title="2.1 状态转换"></a>2.1 状态转换</h3><p>1.新建</p><p>2.运行：可能正在执行。可能正在等待 CPU 为它分配执行时间</p><p>3.无限期等待：不会被分配 CUP 执行时间，它们要等待被其他线程显式唤醒</p><p>4.限期等待：不会被分配 CUP 执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒</p><p>5.阻塞：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生</p><p>6.结束：已终止线程的线程状态，线程已经结束执行</p><h3 id="2-2-线程安全"><a href="#2-2-线程安全" class="headerlink" title="2.2 线程安全"></a>2.2 线程安全</h3><p>1、不可变：不可变的对象一定是线程安全的、无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障。例如：把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。</p><p>2、绝对线程安全</p><p>3、相对线程安全：相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</p><p>4、线程兼容：对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用</p><p>5、线程对立：是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码</p><h3 id="2-3-线程安全的实现方法"><a href="#2-3-线程安全的实现方法" class="headerlink" title="2.3 线程安全的实现方法"></a>2.3 线程安全的实现方法</h3><p>1.互斥同步：</p><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。互斥是因，同步是果：互斥是方法，同步是目的</p><p>在 Java 中，最基本的互斥同步手段就是 synchronized 关键字，它经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有指明，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，对应的在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止</p><p>Synchronized，ReentrantLock 增加了一些高级功能</p><p>1.等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助</p><p>2.公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；非公平锁则不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁</p><p>3.锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait()和 notify()或 notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition 方法即可</p><p>2.非阻塞同步</p><p>3.无同步方案</p><p>可重入代码：也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p><p>判断一个代码是否具备可重入性：如果一个方法，它的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的</p><p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保障，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题</p><h3 id="2-4-锁优化"><a href="#2-4-锁优化" class="headerlink" title="2.4 锁优化"></a>2.4 锁优化</h3><p>适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁</p><h4 id="2-4-1-自旋锁与自适应自旋"><a href="#2-4-1-自旋锁与自适应自旋" class="headerlink" title="2.4.1 自旋锁与自适应自旋"></a>2.4.1 自旋锁与自适应自旋</h4><p>自旋锁：如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁</p><p>自适应自旋转：是由前一次在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自过程，以避免浪费处理器资源。</p><h4 id="2-4-2-锁消除"><a href="#2-4-2-锁消除" class="headerlink" title="2.4.2 锁消除"></a>2.4.2 锁消除</h4><p>锁消除是指虚拟机即时编辑器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果在一段代码中。推上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行</p><h4 id="2-4-3-锁粗化"><a href="#2-4-3-锁粗化" class="headerlink" title="2.4.3 锁粗化"></a>2.4.3 锁粗化</h4><p>如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</p><h4 id="2-4-4-轻量级锁"><a href="#2-4-4-轻量级锁" class="headerlink" title="2.4.4 轻量级锁"></a>2.4.4 轻量级锁</h4><h4 id="2-4-5-偏向锁"><a href="#2-4-5-偏向锁" class="headerlink" title="2.4.5 偏向锁"></a>2.4.5 偏向锁</h4><p>它的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。如果轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把这个同步都消除掉，CAS 操作都不做了</p><p>如果在接下俩的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步</p><h2 id="3-逃逸分析"><a href="#3-逃逸分析" class="headerlink" title="3 逃逸分析"></a>3 逃逸分析</h2><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</p><p>如果一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化</p><p>栈上分配：如果确定一个对象不会逃逸出方法外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。如果能使用栈上分配，那大量的对象就随着方法的结束而销毁了，垃圾收集系统的压力将会小很多</p><p>同步消除：如果确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉</p><p>标量替换：标量就是指一个数据无法在分解成更小的数据表示了，int、long 等及 refrence 类型等都不能在进一步分解，它们称为标量。</p><p>如果一个数据可以继续分解，就称为聚合量，Java 中的对象就是最典型的聚合量</p><p>如果一个对象不会被外部访问，并且这个对象可以被拆散的化，那程序正整执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-内存&quot;&gt;&lt;a href=&quot;#1-内存&quot; class=&quot;headerlink&quot; title=&quot;1 内存&quot;&gt;&lt;/a&gt;1 内存&lt;/h2&gt;&lt;h3 id=&quot;1-1-内存一致性&quot;&gt;&lt;a href=&quot;#1-1-内存一致性&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
</feed>
